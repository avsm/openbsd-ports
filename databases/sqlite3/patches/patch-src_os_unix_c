$OpenBSD: patch-src_os_unix_c,v 1.4 2008/10/27 17:14:18 simon Exp $
--- src/os_unix.c.orig	Tue Oct 14 20:07:40 2008
+++ src/os_unix.c	Sat Oct 25 19:39:50 2008
@@ -83,6 +83,9 @@
 #if SQLITE_THREADSAFE
 # include <pthread.h>
 # define SQLITE_UNIX_THREADS 1
+# if SQLITE_THREAD_OVERRIDE_LOCK != 1 || defined(SQLITE_TEST)
+#  define SQLITE_NEED_TID_CHECKS 1
+# endif
 #endif
 
 /*
@@ -119,7 +122,7 @@ struct unixFile {
   int h;                    /* The file descriptor */
   unsigned char locktype;   /* The type of lock held on this fd */
   int dirfd;                /* File descriptor for the directory */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;            /* The thread that "owns" this unixFile */
 #endif
   int lastErrno;            /* The unix errno from the last I/O error */
@@ -161,7 +164,7 @@ struct unixFile {
 ** The threadid macro resolves to the thread-id or to 0.  Used for
 ** testing and debugging only.
 */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 #define threadid pthread_self()
 #else
 #define threadid 0
@@ -183,7 +186,7 @@ struct unixFile {
 ** recomputed because its key includes the thread-id.  See the 
 ** transferOwnership() function below for additional information
 */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 # define SET_THREADID(X)   (X)->tid = pthread_self()
 # define CHECK_THREADID(X) (threadsOverrideEachOthersLocks==0 && \
                             !pthread_equal((X)->tid, pthread_self()))
@@ -302,7 +305,7 @@ struct unixFile {
 struct lockKey {
   dev_t dev;       /* Device number */
   ino_t ino;       /* Inode number */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;   /* Thread ID or zero if threads can override each other */
 #endif
 };
@@ -396,7 +399,7 @@ static void leaveMutex(void){
   sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));
 }
 
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This variable records whether or not threads can override each others
 ** locks.
@@ -533,7 +536,7 @@ static void testThreadLockingBehavior(int fd_orig){
   close(fd);
   threadsOverrideEachOthersLocks =  d[0].result==0 && d[1].result==0;
 }
-#endif /* SQLITE_THREADSAFE */
+#endif /* SQLITE_NEED_TID_CHECKS */
 
 /*
 ** Release a lockInfo structure previously allocated by findLockInfo().
@@ -715,7 +718,7 @@ static int findLockInfo(
   memset(&key1, 0, sizeof(key1));
   key1.dev = statbuf.st_dev;
   key1.ino = statbuf.st_ino;
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
   if( threadsOverrideEachOthersLocks<0 ){
     testThreadLockingBehavior(fd);
   }
@@ -808,7 +811,7 @@ static const char *locktypeName(int locktype){
 ** If the unixFile is locked and an ownership is wrong, then return
 ** SQLITE_MISUSE.  SQLITE_OK is returned if everything works.
 */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 static int transferOwnership(unixFile *pFile){
   int rc;
   pthread_t hSelf;
