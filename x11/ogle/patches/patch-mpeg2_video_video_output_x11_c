$OpenBSD: patch-mpeg2_video_video_output_x11_c,v 1.2 2001/11/02 17:38:04 espie Exp $
--- mpeg2_video/video_output_x11.c.orig	Tue Oct  9 01:10:59 2001
+++ mpeg2_video/video_output_x11.c	Mon Oct 22 16:44:44 2001
@@ -291,6 +291,7 @@ static void display_init_xv(yuv_image_t 
 #ifdef HAVE_XV
   int i, j;
   int result;
+  int best;
 
   xv_port = 0; /* We have no port yet. */
   
@@ -299,17 +300,19 @@ static void display_init_xv(yuv_image_t 
 			    &xv_request_base, &xv_event_base, 
 			    &xv_error_base);
   if(result != Success) {
-    fprintf(stderr, "Xv not found\n");
+    fprintf(stderr, "vo: Xv extension not found\n");
     return;
   }
   
-  fprintf(stderr, "Found Xv extension, checking for suitable adaptors\n");
   /* Check for available adaptors */
   result = XvQueryAdaptors(mydisplay, DefaultRootWindow (mydisplay), 
 			   &xv_num_adaptors, &xv_adaptor_info);
-  if(result != Success)
+  if(result != Success) {
+    fprintf(stderr,"vo: no Xv adaptors found\n");
     return;
+  }
   
+  best = 0;
       
   /* Check adaptors */
   for(i = 0; i < xv_num_adaptors; i++) {
@@ -319,18 +322,16 @@ static void display_init_xv(yuv_image_t 
        !(xv_adaptor_info[i].type & XvImageMask))
       continue;
     
+    best = 1;
     xv_port = xv_adaptor_info[i].base_id;
-    fprintf(stderr, "Found adaptor \"%s\" checking for suitable formats\n",
-	    xv_adaptor_info[i].name);
       
     /* Check image formats of adaptor */
     xv_formats = XvListImageFormats(mydisplay, xv_port, &xv_num_formats);
     for(j = 0; j < xv_num_formats; j++) {
       if(xv_formats[j].id == 0x32315659) { /* YV12 */
 	//if(xv_formats[j].id == 0x30323449) { /* I420 */
-	fprintf(stderr, "Found image format \"%s\", using it\n", 
-		xv_formats[j].guid);
 	xv_id = xv_formats[j].id;
+	best = 2;
 	break;
       } 
     }
@@ -338,8 +339,6 @@ static void display_init_xv(yuv_image_t 
     if(j == xv_num_formats)
       continue;
       
-    fprintf(stderr, "Using Xvideo port %li for hw scaling\n", xv_port);
-      
     /* Allocate XvImages */
     xv_image = XvShmCreateImage(mydisplay, xv_port, xv_id, NULL,
 				picture_data->info->picture.padded_width,
@@ -350,6 +349,7 @@ static void display_init_xv(yuv_image_t 
     if(xv_image == NULL)
       continue;
     
+    best = 3;
     /* Test and see if we really got padded_width x padded_height */
     if(xv_image->width != picture_data->info->picture.padded_width ||
        xv_image->height != picture_data->info->picture.padded_height) {
@@ -394,6 +394,19 @@ static void display_init_xv(yuv_image_t 
     /* All set up! */
     break;
   }
+  switch(best) {
+  case 0:
+  	fprintf(stderr, "vo: no Xv adaptors suitable for display\n");
+  	break;
+  case 1:
+  	fprintf(stderr, "vo: no YV12 Xv adaptors\n");
+  	break;
+  case 2:
+  	fprintf(stderr, "vo: can't create YV12 XvImage\n");
+  	break;
+  case 3:
+  	break;
+  }
 #endif /* HAVE_XV */
 }
      
@@ -435,8 +448,8 @@ static void display_init_xshm()
 			  window.ximage->height, 
 			  IPC_CREAT | 0777);
   
-  if(shm_info.shmid < 0) {
-    fprintf(stderr, "vo: shmget failed\n");
+  if(shm_info.shmid == -1) {
+    perror("vo: shmget failed");
     exit(1);
   }
   
@@ -444,7 +457,7 @@ static void display_init_xshm()
   shm_info.shmaddr = (char *) shmat(shm_info.shmid, 0, 0);
   
   if(shm_info.shmaddr == ((char *) -1)) {
-    fprintf(stderr, "vo: shmat failed\n");
+    perror("vo: shmat failed");
     exit(1);
   }
   
@@ -479,7 +492,9 @@ static void display_init_xshm()
   pixel_stride = window.ximage->bits_per_pixel;
 
   
+#if DEBUG
   fprintf(stderr, "vo: pixel_stride: %d\n", pixel_stride);
+#endif
   
 
   // If we have blue in the lowest bit then obviously RGB 
@@ -541,6 +556,7 @@ void display_init(yuv_image_t *picture_d
   dpy_sar_frac_n = dpy_size.height * dpy_size.horizontal_pixels;
   dpy_sar_frac_d = dpy_size.width * dpy_size.vertical_pixels;
   
+#if DEBUG
   fprintf(stderr, "*d* h: %d, w: %d, hp: %d, wp: %d\n",
 	  dpy_size.height, dpy_size.width,
 	  dpy_size.vertical_pixels, dpy_size.horizontal_pixels);
@@ -548,6 +564,7 @@ void display_init(yuv_image_t *picture_d
 	  XHeightMMOfScreen(scr), XWidthMMOfScreen(scr),
 	  XHeightOfScreen(scr), XWidthOfScreen(scr));
   fprintf(stderr, "*** display_sar: %d/%d\n", dpy_sar_frac_n, dpy_sar_frac_d);
+#endif
   
   
   /* Assume (for now) that the window will be the same size as the source. */
@@ -560,12 +577,14 @@ void display_init(yuv_image_t *picture_d
   color_depth = attribs.depth;
   if(color_depth != 15 && color_depth != 16 && 
      color_depth != 24 && color_depth != 32) {
-    fprintf(stderr,"Only 15, 16, 24, and 32bpp supported. Trying 24bpp!\n");
+    fprintf(stderr,"vo: color_depth %d not supported (not 15, 16, 24, 32).  Trying 24bpp!\n", color_depth);
     color_depth = 24;
   }
   
   XMatchVisualInfo(mydisplay, screen, color_depth, TrueColor, &vinfo);
+#if DEBUG
   fprintf(stderr, "vo: X11 visual id is %lx\n", vinfo.visualid);
+#endif
 
   hint.x = 0;
   hint.y = 0;
@@ -651,7 +670,9 @@ void display_init(yuv_image_t *picture_d
   
 
   xshmeventbase = XShmGetEventBase(mydisplay);  
+#if DEBUG
   fprintf(stderr, "xshmeventbase: %d\n", xshmeventbase);
+#endif
 
   /* Try to use XFree86 Xv (X video) extension for display.
      Sets use_xv to true on success. */
@@ -670,15 +691,15 @@ void display_init(yuv_image_t *picture_d
     yuyv_fb = (unsigned int *)mmap(NULL, 4*1024*1024, PROT_READ | PROT_WRITE,
 				   MAP_SHARED, fb_fd, 0x0701a000);
     if(yuyv_fb == MAP_FAILED) {
-      perror("mmap");
-      exit(-1);
+      perror("vo: mmap failed");
+      exit(1);
     }
     
     rgb_fb = (uint8_t *)mmap(NULL, 4*2048*1024, PROT_READ | PROT_WRITE,
 				  MAP_SHARED, fb_fd, 0x05004000);
     if(rgb_fb == MAP_FAILED) {
-      perror("mmap");
-      exit(-1);
+      perror("vo: mmap failed");
+      exit(1);
     }
   }
   /*** end sun ffb2 ***/
@@ -701,7 +722,9 @@ static void display_change_size(yuv_imag
   int padded_height = img->info->picture.padded_height;
   //int alloc_width, alloc_height;
   int alloc_size;
+#if DEBUG
   fprintf(stderr, "vo resize: %d, %d\n", new_width, new_height);
+#endif
   
   
   /* If we cant scale (i.e no Xv or mediaLib) exit give up now. */
@@ -730,12 +753,12 @@ static void display_change_size(yuv_imag
       XShmDetach(mydisplay, &shm_info);
     XDestroyImage(window.ximage);
     shmdt(shm_info.shmaddr);
-    if(shm_info.shmaddr == ((char *) -1)) {
-      fprintf(stderr, "vo: Shared memory: Couldn't detach segment\n");
+    if(shmdt(shm_info.shmaddr) != 0) {
+      perror("vo: Shared memory: shmdt failed");
       exit(1);
     }
     if(shmctl(shm_info.shmid, IPC_RMID, 0) == -1) {
-      perror("vo: shmctl ipc_rmid");
+      perror("vo: shmctl ipc_rmid failed");
       exit(1);
     }
     
@@ -769,15 +792,15 @@ static void display_change_size(yuv_imag
 			    IPC_CREAT | 0777);
 
 
-    if(shm_info.shmid < 0) {
-      fprintf(stderr, "vo: Shared memory: Couldn't get segment\n");
+    if(shm_info.shmid == -1) {
+      perror("vo: Shared memory: shmget failed");
       exit(1);
     }
   
     /* Attach shared memory segment */
     shm_info.shmaddr = (char *) shmat(shm_info.shmid, 0, 0);
     if(shm_info.shmaddr == ((char *) -1)) {
-      fprintf(stderr, "vo: Shared memory: Couldn't attach segment\n");
+      perror("vo: Shared memory: shmat failed");
       exit(1);
     }
     
@@ -825,10 +848,12 @@ static void display_adjust_size(yuv_imag
   scale_frac_n = (int64_t)dpy_sar_frac_n * (int64_t)sar_frac_d; 
   scale_frac_d = (int64_t)dpy_sar_frac_d * (int64_t)sar_frac_n;
   
+#if DEBUG
   fprintf(stderr, "vo: sar: %d/%d, dpy_sar %d/%d, scale: %lld, %lld\n",
 	  sar_frac_n, sar_frac_d,
 	  dpy_sar_frac_n, dpy_sar_frac_d,
 	  scale_frac_n, scale_frac_d); 
+#endif
   
   /* Keep either the height or the width constant. */ 
   if(scale_frac_n > scale_frac_d) {
@@ -867,7 +892,9 @@ static void display_adjust_size(yuv_imag
     new_width  = max_width;
     new_height = (base_height * max_width) / base_width;
   } else {
+#if DEBUG
     fprintf(stderr, "vo: using zoom %d / %d\n", scale.zoom_n, scale.zoom_d);
+#endif
     /* Use the provided zoom value. */
     new_width  = (base_width  * scale.zoom_n) / scale.zoom_d;
     new_height = (base_height * scale.zoom_n) / scale.zoom_d;
@@ -895,7 +922,9 @@ static void display_adjust_size(yuv_imag
       scale.zoom_n = new_height;
       scale.zoom_d = base_height;
     }
+#if DEBUG
     fprintf(stderr, "vo: zoom2 %d / %d\n", scale.zoom_n, scale.zoom_d);
+#endif
   }
   
   /* Don't care about aspect and can't change the window size, use it all. */
