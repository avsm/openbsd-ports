$OpenBSD: patch-arts_flow_audiosubsys_cc,v 1.2 2000/12/29 22:53:53 espie Exp $
--- arts/flow/audiosubsys.cc.orig	Sun Nov 26 17:35:31 2000
+++ arts/flow/audiosubsys.cc	Sun Dec 17 00:32:51 2000
@@ -36,6 +36,10 @@
 #ifdef HAVE_SYS_SOUNDCARD_H
 #include <sys/soundcard.h>
 #endif
+#ifdef HAVE_SOUNDCARD_H
+#include <soundcard.h>
+#define DEVICE_NAME "/dev/audio"
+#endif
 
 #include <assert.h>
 #include <errno.h>
@@ -48,7 +52,9 @@
 #include "debug.h"
 #include "audiosubsys.h"
 
+#ifndef DEVICE_NAME
 #define DEVICE_NAME "/dev/dsp"
+#endif
 
 using namespace std;
 using namespace Arts;
@@ -204,7 +210,7 @@ bool AudioSubSystem::check()
 
 int AudioSubSystem::open()
 {
-#ifdef HAVE_SYS_SOUNDCARD_H
+#if defined(HAVE_SYS_SOUNDCARD_H) || defined(HAVE_SOUNDCARD_H)
 	int mode;
 
 	if(_fullDuplex)
@@ -386,6 +392,7 @@ int AudioSubSystem::open()
 	assert(fragment_buffer == 0);
 	fragment_buffer = new char[_fragmentSize];
 
+#ifndef HAVE_SOUNDCARD_H
 	/*
 	 * Workaround for broken kernel drivers: usually filling up the audio
 	 * buffer is _only_ required if _fullDuplex is true. However, there
@@ -400,6 +407,7 @@ int AudioSubSystem::open()
 		assert(len == _fragmentSize);
 	}
 	free(zbuffer);
+#endif
 
 	/*
 	 * Triggering - the original aRts code did this for full duplex:
@@ -460,7 +468,7 @@ bool AudioSubSystem::running()
 
 void AudioSubSystem::handleIO(int type)
 {
-#ifdef HAVE_SYS_SOUNDCARD_H
+#if defined(HAVE_SYS_SOUNDCARD_H) || defined(HAVE_SOUNDCARD_H)
 	if(type & ioRead)
 	{
 		int len = ::read(audio_fd,fragment_buffer,_fragmentSize);
