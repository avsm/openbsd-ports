$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_cpp,v 1.8 2009/01/16 16:49:29 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.cpp.orig	Wed Jan 14 13:01:37 2009
+++ hotspot/src/os/bsd/vm/os_bsd.cpp	Wed Jan 14 13:03:52 2009
@@ -47,13 +47,26 @@
 # include <semaphore.h>
 # include <fcntl.h>
 # include <string.h>
+#ifdef _ALLBSD_SOURCE
+# include <sys/param.h>
+# include <sys/sysctl.h>
+#else
 # include <syscall.h>
 # include <sys/sysinfo.h>
 # include <gnu/libc-version.h>
+#endif
 # include <sys/ipc.h>
 # include <sys/shm.h>
 # include <link.h>
 
+#if defined(__FreeBSD__)
+# include <elf.h>
+#endif
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
 #define MAX_PATH    (2 * K)
 
 // for timer info max values which include all bits
@@ -64,19 +77,25 @@
 // global variables
 julong os::Bsd::_physical_memory = 0;
 
+#ifndef _ALLBSD_SOURCE
 address   os::Bsd::_initial_thread_stack_bottom = NULL;
 uintptr_t os::Bsd::_initial_thread_stack_size   = 0;
+#endif
 
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+#ifndef _ALLBSD_SOURCE
 int (*os::Bsd::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 Mutex* os::Bsd::_createThread_lock = NULL;
+#endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
+#ifndef _ALLBSD_SOURCE
 bool os::Bsd::_is_floating_stack = false;
 bool os::Bsd::_is_NPTL = false;
 bool os::Bsd::_supports_fast_thread_cpu_time = false;
 const char * os::Bsd::_glibc_version = NULL;
 const char * os::Bsd::_libpthread_version = NULL;
+#endif
 
 static jlong initial_time_count=0;
 
@@ -97,6 +116,76 @@ sigset_t SR_sigset;
 /* Used to protect dlsym() calls */
 static pthread_mutex_t dl_mutex;
 
+#ifdef _ALLBSD_SOURCE
+// XXXBSD: ported from solaris version
+// interruptible infrastructure
+
+// setup_interruptible saves the thread state before going into an
+// interruptible system call.  
+// The saved state is used to restore the thread to
+// its former state whether or not an interrupt is received.  
+// Used by classloader os::read 
+// hpi calls skip this layer and stay in _thread_in_native
+
+void os::Bsd::setup_interruptible(JavaThread* thread) {
+ 
+  JavaThreadState thread_state = thread->thread_state();
+
+  assert(thread_state != _thread_blocked, "Coming from the wrong thread");
+  assert(thread_state != _thread_in_native, "Native threads skip setup_interruptible");
+  OSThread* osthread = thread->osthread();
+  osthread->set_saved_interrupt_thread_state(thread_state);
+  thread->frame_anchor()->make_walkable(thread);
+  ThreadStateTransition::transition(thread, thread_state, _thread_blocked);
+}
+
+// Version of setup_interruptible() for threads that are already in
+// _thread_blocked. Used by os_sleep().
+void os::Bsd::setup_interruptible_already_blocked(JavaThread* thread) {
+  thread->frame_anchor()->make_walkable(thread);
+}
+
+JavaThread* os::Bsd::setup_interruptible() {
+  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();
+  setup_interruptible(thread);
+  return thread;
+}
+
+#ifdef ASSERT
+
+JavaThread* os::Bsd::setup_interruptible_native() {
+  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();
+  JavaThreadState thread_state = thread->thread_state();
+  assert(thread_state == _thread_in_native, "Assumed thread_in_native");
+  return thread;
+}
+
+void os::Bsd::cleanup_interruptible_native(JavaThread* thread) {
+  JavaThreadState thread_state = thread->thread_state();
+  assert(thread_state == _thread_in_native, "Assumed thread_in_native");
+}
+#endif
+
+// cleanup_interruptible reverses the effects of setup_interruptible
+// setup_interruptible_already_blocked() does not need any cleanup.
+
+void os::Bsd::cleanup_interruptible(JavaThread* thread) {
+  OSThread* osthread = thread->osthread();
+
+  ThreadStateTransition::transition(thread, _thread_blocked, osthread->saved_interrupt_thread_state());
+}
+
+// I/O interruption related counters called in _INTERRUPTIBLE
+
+void os::Bsd::bump_interrupted_before_count() {
+  RuntimeService::record_interrupted_before_count();
+}
+
+void os::Bsd::bump_interrupted_during_count() {
+  RuntimeService::record_interrupted_during_count();
+}
+#endif
+
 ////////////////////////////////////////////////////////////////////////////////
 // utility functions
 
@@ -108,11 +197,16 @@ julong os::available_memory() {
 }
 
 julong os::Bsd::available_memory() {
+#ifdef _ALLBSD_SOURCE
+  // XXXBSD: this is just a stopgap implementation
+  return physical_memory() >> 2;
+#else
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
 
   return (julong)si.freeram * si.mem_unit;
+#endif
 }
 
 julong os::physical_memory() {
@@ -160,6 +254,7 @@ bool os::have_special_privileges() {
 }
 
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_gettid
 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 #ifdef __ia64__
@@ -174,6 +269,7 @@ bool os::have_special_privileges() {
 #error define gettid for the arch
 #endif
 #endif
+#endif
 
 // Cpu architecture string
 #if   defined(IA64)
@@ -193,6 +289,7 @@ static char cpu_arch[] = "sparc";
 #endif
 
 
+#ifndef _ALLBSD_SOURCE
 // pid_t gettid()
 //
 // Returns the kernel thread id of the currently running thread. Kernel
@@ -219,8 +316,48 @@ static bool unsafe_chroot_detected = false;
 static const char *unstable_chroot_error = "/proc file system not found.\n"
                      "Java may be unstable running multithreaded in a chroot "
                      "environment on Bsd when /proc filesystem is not mounted.";
+#endif
 
+#ifdef _ALLBSD_SOURCE
 void os::Bsd::initialize_system_info() {
+  int mib[2];
+  size_t len;
+  int cpu_val;
+  u_long mem_val;
+
+  /* get processors count via hw.ncpus sysctl */
+  mib[0] = CTL_HW;
+  mib[1] = HW_NCPU;
+  len = sizeof(cpu_val);
+  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1)
+        _processor_count = cpu_val;
+
+  if (_processor_count < 1)
+       _processor_count = 1;   // fallback
+
+  /* get physical memory via hw.usermem sysctl (hw.usermem is used
+   * instead of hw.physmem because we need size of allocatable memory
+   */
+  mib[0] = CTL_HW;
+  mib[1] = HW_USERMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+       _physical_memory = mem_val;
+  else
+       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+
+#ifdef __OpenBSD__
+  {
+       // limit _physical_memory memory view on OpenBSD since
+       // datasize maximum limits us anyway.
+       struct rlimit limits;
+       getrlimit(RLIMIT_DATA, &limits);
+       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);
+  }
+#endif
+}
+#else
+void os::Bsd::initialize_system_info() {
   _processor_count = sysconf(_SC_NPROCESSORS_CONF);
   if (_processor_count == 1) {
     pid_t pid = os::Bsd::gettid();
@@ -236,6 +373,7 @@ void os::Bsd::initialize_system_info() {
   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);
   assert(_processor_count > 0, "bsd error");
 }
+#endif
 
 void os::init_system_properties_values() {
 //  char arch[12];
@@ -279,7 +417,9 @@ void os::init_system_properties_values() {
  *        ...
  *        7: The default directories, normally /lib and /usr/lib.
  */
+#ifndef DEFAULT_LIBPATH
 #define DEFAULT_LIBPATH "/lib:/usr/lib"
+#endif
 
 #define EXTENSIONS_DIR  "/lib/ext"
 #define ENDORSED_DIR    "/lib/endorsed"
@@ -515,6 +655,7 @@ void os::Bsd::hotspot_sigmask(Thread* thread) {
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 //////////////////////////////////////////////////////////////////////////////
 // detecting pthread library
 
@@ -678,6 +819,7 @@ bool os::Bsd::manually_expand_stack(JavaThread * t, ad
   }
   return false;
 }
+#endif
 
 //////////////////////////////////////////////////////////////////////////////
 // create new thread
@@ -686,6 +828,9 @@ static address highest_vm_reserved_address();
 
 // check if it's safe to start a new thread
 static bool _thread_safety_check(Thread* thread) {
+#ifdef _ALLBSD_SOURCE
+    return true;
+#else
   if (os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack()) {
     // Fixed stack BsdThreads (SuSE Bsd/x86, and some versions of Redhat)
     //   Heap is mmap'ed at lower end of memory space. Thread stacks are
@@ -719,6 +864,7 @@ static bool _thread_safety_check(Thread* thread) {
     //   here, that means enough space has been reserved for stack.
     return true;
   }
+#endif
 }
 
 // Thread start routine for all newly created threads
@@ -746,6 +892,10 @@ static void *java_start(Thread *thread) {
     return NULL;
   }
 
+#ifdef _ALLBSD_SOURCE
+  // thread_id is pthread_id on BSD
+  osthread->set_thread_id(::pthread_self());
+#else
   // thread_id is kernel thread id (similar to Solaris LWP id)
   osthread->set_thread_id(os::Bsd::gettid());
 
@@ -755,6 +905,7 @@ static void *java_start(Thread *thread) {
       thread->set_lgrp_id(lgrp_id);
     }
   }
+#endif
   // initialize signal mask for this thread
   os::Bsd::hotspot_sigmask(thread);
 
@@ -835,17 +986,22 @@ bool os::create_thread(Thread* thread, ThreadType thr_
     // let pthread_create() pick the default value.
   }
 
+#ifndef _ALLBSD_SOURCE
   // glibc guard page
   pthread_attr_setguardsize(&attr, os::Bsd::default_guard_size(thr_type));
+#endif
 
   ThreadState state;
 
   {
+
+#ifndef _ALLBSD_SOURCE
     // Serialize thread creation if we are running with fixed stack BsdThreads
     bool lock = os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack();
     if (lock) {
       os::Bsd::createThread_lock()->lock_without_safepoint_check();
     }
+#endif
 
     pthread_t tid;
     int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
@@ -859,7 +1015,9 @@ bool os::create_thread(Thread* thread, ThreadType thr_
       // Need to clean up stuff we've allocated so far
       thread->set_osthread(NULL);
       delete osthread;
+#ifndef _ALLBSD_SOURCE
       if (lock) os::Bsd::createThread_lock()->unlock();
+#endif
       return false;
     }
 
@@ -875,9 +1033,11 @@ bool os::create_thread(Thread* thread, ThreadType thr_
       }
     }
 
+#ifndef _ALLBSD_SOURCE
     if (lock) {
       os::Bsd::createThread_lock()->unlock();
     }
+#endif
   }
 
   // Aborted due to thread limit being reached
@@ -915,7 +1075,11 @@ bool os::create_attached_thread(JavaThread* thread) {
   }
 
   // Store pthread info into the OSThread
+#ifdef _ALLBSD_SOURCE
+  osthread->set_thread_id(::pthread_self());
+#else
   osthread->set_thread_id(os::Bsd::gettid());
+#endif
   osthread->set_pthread_id(::pthread_self());
 
   // initialize floating point control register
@@ -926,6 +1090,7 @@ bool os::create_attached_thread(JavaThread* thread) {
 
   thread->set_osthread(osthread);
 
+#ifndef _ALLBSD_SOURCE
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
@@ -952,6 +1117,7 @@ bool os::create_attached_thread(JavaThread* thread) {
     os::Bsd::manually_expand_stack(jt, addr);
     osthread->clear_expanding_stack();
   }
+#endif
 
   // initialize signal mask for this thread
   // and save the caller's signal mask
@@ -1010,6 +1176,7 @@ extern "C" Thread* get_thread() {
 //////////////////////////////////////////////////////////////////////////////
 // initial thread
 
+#ifndef _ALLBSD_SOURCE
 // Check if current thread is the initial thread, similar to Solaris thr_main.
 bool os::Bsd::is_initial_thread(void) {
   char dummy;
@@ -1240,6 +1407,7 @@ void os::Bsd::capture_initial_stack(size_t max_size) {
   _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());
   _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;
 }
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 // time support
@@ -1283,7 +1451,18 @@ jlong os::javaTimeMillis() {
 #define CLOCK_MONOTONIC (1)
 #endif
 
+#ifdef _ALLBSD_SOURCE
 void os::Bsd::clock_init() {
+  struct timespec res;
+  struct timespec tp;
+  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
+      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
+    // yes, monotonic clock is supported
+    _clock_gettime = ::clock_gettime;
+  }
+}
+#else
+void os::Bsd::clock_init() {
   // we do dlopen's in this particular order due to bug in bsd
   // dynamical loader (see 6348968) leading to crash on exit
   void* handle = dlopen("librt.so.1", RTLD_LAZY);
@@ -1318,7 +1497,9 @@ void os::Bsd::clock_init() {
     }
   }
 }
+#endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_clock_getres
 
 #if defined(IA32) || defined(AMD64)
@@ -1357,6 +1538,7 @@ void os::Bsd::fast_thread_clock_init() {
     _pthread_getcpuclockid = pthread_getcpuclockid_func;
   }
 }
+#endif
 
 jlong os::javaTimeNanos() {
   if (Bsd::supports_monotonic_clock()) {
@@ -1562,6 +1744,23 @@ bool os::dll_address_to_function_name(address addr, ch
   }
 }
 
+#ifdef _ALLBSD_SOURCE
+// ported from solaris version
+bool os::dll_address_to_library_name(address addr, char* buf,
+                                     int buflen, int* offset) {
+  Dl_info dlinfo;
+
+  if (dladdr((void*)addr, &dlinfo)){
+     if (buf) jio_snprintf(buf, buflen, "%s", dlinfo.dli_fname);
+     if (offset) *offset = addr - (address)dlinfo.dli_fbase;
+     return true;
+  } else {
+     if (buf) buf[0] = '\0';
+     if (offset) *offset = -1;
+     return false;
+  }
+}
+#else
 struct _address_to_library_name {
   address addr;          // input : memory address
   size_t  buflen;        //         size of fname
@@ -1636,6 +1835,7 @@ bool os::dll_address_to_library_name(address addr, cha
      return false;
   }
 }
+#endif
 
   // Loads .dll/.so and
   // in case of error it checks if .dll/.so was built for the
@@ -1693,6 +1893,18 @@ void * os::dll_load(const char *filename, char *ebuf, 
   #define EM_486          6               /* Intel 80486 */
   #endif
 
+  #ifndef EM_PPC64
+  #define EM_PPC64        21              /* PowerPC64 */
+  #endif
+
+  #ifndef EM_IA_64
+  #define EM_IA_64        50              /* HP/Intel IA-64 */ 
+  #endif
+
+  #ifndef EM_X86_64
+  #define EM_X86_64       62              /* AMD x86-64 */ 
+  #endif
+
   static const arch_t arch_array[]={
     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
@@ -1806,7 +2018,41 @@ bool _print_ascii_file(const char* filename, outputStr
 
 void os::print_dll_info(outputStream *st) {
    st->print_cr("Dynamic libraries:");
+#ifdef _ALLBSD_SOURCE
+#ifdef RTLD_DI_LINKMAP
+    Dl_info dli;
+    void *handle;
+    Link_map *map;
+    Link_map *p;
 
+    if (!dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli)) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    handle = dlopen(dli.dli_fname, RTLD_LAZY);
+    if (handle == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    dlinfo(handle, RTLD_DI_LINKMAP, &map);
+    if (map == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+
+    while (map->l_prev != NULL)
+        map = map->l_prev;
+
+    while (map != NULL) {
+        st->print_cr(PTR_FORMAT " \t%s", map->l_addr, map->l_name);
+        map = map->l_next;
+    }
+
+    dlclose(handle);
+#else
+   st->print_cr("Error: Cannot print dynamic libraries.");
+#endif
+#else
    char fname[32];
    pid_t pid = os::Bsd::gettid();
 
@@ -1815,6 +2061,7 @@ void os::print_dll_info(outputStream *st) {
    if (!_print_ascii_file(fname, st)) {
      st->print("Can not get library information for pid = %d\n", pid);
    }
+#endif
 }
 
 
@@ -1847,6 +2094,7 @@ void os::print_os_info(outputStream* st) {
   st->print(name.machine);
   st->cr();
 
+#ifndef _ALLBSD_SOURCE
   // Print warning if unsafe chroot environment detected
   if (unsafe_chroot_detected) {
     st->print("WARNING!! ");
@@ -1861,6 +2109,7 @@ void os::print_os_info(outputStream* st) {
      st->print("(%s stack)", os::Bsd::is_floating_stack() ? "floating" : "fixed");
   }
   st->cr();
+#endif
 
   // rlimit
   st->print("rlimit:");
@@ -1886,6 +2135,7 @@ void os::print_os_info(outputStream* st) {
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifndef _ALLBSD_SOURCE
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
@@ -1898,6 +2148,7 @@ void os::print_os_info(outputStream* st) {
   os::loadavg(loadavg, 3);
   st->print("%0.02f %0.02f %0.02f", loadavg[0], loadavg[1], loadavg[2]);
   st->cr();
+#endif
 }
 
 void os::print_memory_info(outputStream* st) {
@@ -1905,18 +2156,22 @@ void os::print_memory_info(outputStream* st) {
   st->print("Memory:");
   st->print(" %dk page", os::vm_page_size()>>10);
 
+#ifndef _ALLBSD_SOURCE
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
+#endif
 
   st->print(", physical " UINT64_FORMAT "k",
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
+#ifndef _ALLBSD_SOURCE
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             ((jlong)si.freeswap * si.mem_unit) >> 10);
+#endif
   st->cr();
 }
 
@@ -2256,10 +2511,15 @@ void bsd_wrap_code(char* base, size_t size) {
 //       left at the time of mmap(). This could be a potential
 //       problem.
 bool os::commit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC) == 0;
+#else
   uintptr_t res = (uintptr_t) ::mmap(addr, size,
                                    PROT_READ|PROT_WRITE|PROT_EXEC,
                                    MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res != (uintptr_t) MAP_FAILED;
+#endif
 }
 
 bool os::commit_memory(char* addr, size_t size, size_t alignment_hint) {
@@ -2403,10 +2663,15 @@ os::Bsd::numa_interleave_memory_func_t os::Bsd::_numa_
 unsigned long* os::Bsd::_numa_all_nodes;
 
 bool os::uncommit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return mprotect(addr, size, PROT_NONE) == 0;
+#else
   return ::mmap(addr, size,
                 PROT_READ|PROT_WRITE|PROT_EXEC,
                 MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0)
     != MAP_FAILED;
+#endif
 }
 
 static address _highest_vm_reserved_address = NULL;
@@ -2508,6 +2773,9 @@ bool os::unguard_memory(char* addr, size_t size) {
 static size_t _large_page_size = 0;
 
 bool os::large_page_init() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   if (!UseLargePages) return false;
 
   if (LargePageSizeInBytes) {
@@ -2562,6 +2830,7 @@ bool os::large_page_init() {
   // We optimistically assume the support is available. If later it turns out
   // not true, VM will automatically switch to use regular page size.
   return true;
+#endif
 }
 
 #ifndef SHM_HUGETLB
@@ -2736,7 +3005,7 @@ char* os::attempt_reserve_memory_at(size_t bytes, char
 }
 
 size_t os::read(int fd, void *buf, unsigned int nBytes) {
-  return ::read(fd, buf, nBytes);
+  INTERRUPTIBLE_RETURN_INT_VM(::read(fd, buf, nBytes), os::Bsd::clear_interrupted);
 }
 
 // TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.
@@ -2872,9 +3141,28 @@ void os::loop_breaker(int attempts) {
 // this reason, the code should not be used as default (ThreadPriorityPolicy=0).
 // It is only used when ThreadPriorityPolicy=1 and requires root privilege.
 
+#ifdef _ALLBSD_SOURCE
 int os::java_to_os_priority[MaxPriority + 1] = {
   19,              // 0 Entry should never be used
 
+   0,              // 1 MinPriority
+   3,              // 2
+   6,              // 3
+
+   10,              // 4
+   15,              // 5 NormPriority
+   18,              // 6
+
+   21,              // 7
+   25,              // 8
+   28,              // 9 NearMaxPriority
+
+   31              // 10 MaxPriority
+};
+#else
+int os::java_to_os_priority[MaxPriority + 1] = {
+  19,              // 0 Entry should never be used
+
    4,              // 1 MinPriority
    3,              // 2
    2,              // 3
@@ -2889,6 +3177,7 @@ int os::java_to_os_priority[MaxPriority + 1] = {
 
   -5               // 10 MaxPriority
 };
+#endif
 
 static int prio_init() {
   if (ThreadPriorityPolicy == 1) {
@@ -2908,8 +3197,17 @@ static int prio_init() {
 OSReturn os::set_native_priority(Thread* thread, int newpri) {
   if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;
 
+#ifdef __OpenBSD__
+  // OpenBSD pthread_setprio starves low priority threads
+  return OS_OK;
+#else
+#ifdef _ALLBSD_SOURCE
+  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+#else
   int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);
   return (ret == 0) ? OS_OK : OS_ERR;
+#endif
+#endif
 }
 
 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
@@ -2919,7 +3217,11 @@ OSReturn os::get_native_priority(const Thread* const t
   }
 
   errno = 0;
+#ifdef _ALLBSD_SOURCE
+  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());
+#else
   *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());
+#endif
   return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);
 }
 
@@ -3029,7 +3331,7 @@ static int SR_initialize() {
   /* Get signal number to use for suspend/resume */
   if ((s = ::getenv("_JAVA_SR_SIGNUM")) != 0) {
     int sig = ::strtol(s, 0, 10);
-    if (sig > 0 || sig < _NSIG) {
+    if (sig > 0 || sig < NSIG) {
         SR_signum = sig;
     }
   }
@@ -3392,6 +3694,7 @@ void os::Bsd::install_signal_handlers() {
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 // This is the fastest way to get thread cpu time on Bsd.
 // Returns cpu time (user+sys) for any thread, not only for current.
 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
@@ -3406,6 +3709,7 @@ jlong os::Bsd::fast_thread_cpu_time(clockid_t clockid)
 
   return (tp.tv_sec * SEC_IN_NANOSECS) + tp.tv_nsec;
 }
+#endif
 
 /////
 // glibc on Bsd platform uses non-documented flag
@@ -3627,13 +3931,13 @@ void os::init(void) {
 
   _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();
 
-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);
+  clock_tics_per_sec = CLK_TCK;
 
   init_random(1234567);
 
   ThreadCritical::initialize();
 
-  Bsd::set_page_size(sysconf(_SC_PAGESIZE));
+  Bsd::set_page_size(getpagesize());
   if (Bsd::page_size() == -1) {
     fatal1("os_bsd.cpp: os::init: sysconf failed (%s)", strerror(errno));
   }
@@ -3659,7 +3963,9 @@ extern "C" {
 // this is called _after_ the global arguments have been parsed
 jint os::init_2(void)
 {
+#ifndef _ALLBSD_SOURCE
   Bsd::fast_thread_clock_init();
+#endif
 
   // Allocate a single page and mark it as readable for safepoint polling
   address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
@@ -3708,6 +4014,7 @@ jint os::init_2(void)
   JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,
         vm_page_size()));
 
+#ifndef _ALLBSD_SOURCE
   Bsd::capture_initial_stack(JavaThread::stack_size_at_create());
 
   Bsd::libpthread_init();
@@ -3716,6 +4023,7 @@ jint os::init_2(void)
           Bsd::glibc_version(), Bsd::libpthread_version(),
           Bsd::is_floating_stack() ? "floating stack" : "fixed stack");
   }
+#endif
 
   if (UseNUMA) {
     if (!Bsd::libnuma_init()) {
@@ -3749,8 +4057,10 @@ jint os::init_2(void)
     }
   }
 
+#ifndef _ALLBSD_SOURCE
   // Initialize lock used to serialize thread creation (see os::create_thread)
   Bsd::set_createThread_lock(new Mutex(Mutex::leaf, "createThread_lock", false));
+#endif
 
   // Initialize HPI.
   jint hpi_result = hpi::initialize();
@@ -3798,11 +4108,15 @@ void os::make_polling_page_readable(void) {
 };
 
 int os::active_processor_count() {
+#ifdef _ALLBSD_SOURCE
+  return _processor_count;
+#else
   // Bsd doesn't yet have a (official) notion of processor sets,
   // so just return the number of online processors.
   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
   assert(online_cpus > 0 && online_cpus <= processor_count(), "sanity check");
   return online_cpus;
+#endif
 }
 
 bool os::distribute_processes(uint length, uint* distribution) {
@@ -3844,6 +4158,9 @@ ExtendedPC os::get_thread_pc(Thread* thread) {
 
 int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)
 {
+#ifdef _ALLBSD_SOURCE
+  return pthread_cond_timedwait(_cond, _mutex, _abstime);
+#else
    if (is_NPTL()) {
       return pthread_cond_timedwait(_cond, _mutex, _abstime);
    } else {
@@ -3859,6 +4176,7 @@ int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond
 #endif // IA64
       return status;
    }
+#endif
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -3994,17 +4312,17 @@ int os::create_binary_file(const char* path, bool rewr
   if (!rewrite_existing) {
     oflags |= O_EXCL;
   }
-  return ::open64(path, oflags, S_IREAD | S_IWRITE);
+  return ::open(path, oflags, S_IREAD | S_IWRITE);
 }
 
 // return current position of file pointer
 jlong os::current_file_offset(int fd) {
-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
 }
 
 // move file pointer to the specified offset
 jlong os::seek_to_file_offset(int fd, jlong offset) {
-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
 }
 
 // Map a block of memory.
@@ -4054,6 +4372,7 @@ bool os::unmap_memory(char* addr, size_t bytes) {
   return munmap(addr, bytes) == 0;
 }
 
+#ifndef _ALLBSD_SOURCE
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);
 
 static clockid_t thread_cpu_clockid(Thread* thread) {
@@ -4065,6 +4384,7 @@ static clockid_t thread_cpu_clockid(Thread* thread) {
   assert(rc == 0, "pthread_getcpuclockid is expected to return 0 code");
   return clockid;
 }
+#endif
 
 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
 // are used by JVM M&M and JVMTI to get user+sys or user CPU time
@@ -4074,39 +4394,48 @@ static clockid_t thread_cpu_clockid(Thread* thread) {
 // the fast estimate available on the platform.
 
 jlong os::current_thread_cpu_time() {
+#ifndef _ALLBSD_SOURCE
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     // return user + sys since the cost is the same
     return slow_thread_cpu_time(Thread::current(), true /* user + sys */);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread* thread) {
+#ifndef _ALLBSD_SOURCE
   // consistent with what current_thread_cpu_time() returns
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, true /* user + sys */);
   }
+#endif
 }
 
 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
+#ifndef _ALLBSD_SOURCE
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
+#ifndef _ALLBSD_SOURCE
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, user_sys_cpu_time);
   }
+#endif
 }
 
+#ifndef _ALLBSD_SOURCE
 //
 //  -1 on error.
 //
@@ -4195,6 +4524,7 @@ static jlong slow_thread_cpu_time(Thread *thread, bool
     return (jlong)user_time * (1000000000 / clock_tics_per_sec);
   }
 }
+#endif
 
 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
   info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
@@ -4211,7 +4541,11 @@ void os::thread_cpu_time_info(jvmtiTimerInfo *info_ptr
 }
 
 bool os::is_thread_cpu_time_supported() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   return true;
+#endif
 }
 
 // System loadavg support.  Returns -1 if load average cannot be obtained.
@@ -4344,7 +4678,7 @@ jdk_pthread_sigmask(int how , const sigset_t* newmask,
 // abstime will be the absolute timeout time
 // TODO: replace compute_abstime() with unpackTime()
 
-static struct timespec* compute_abstime(timespec* abstime, jlong millis) {
+static struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
   struct timeval now;
   int status = gettimeofday(&now, NULL);
@@ -4396,7 +4730,7 @@ void os::PlatformEvent::park() {       // AKA "down()"
         status = pthread_cond_wait(_cond, _mutex);
         // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
         // Treat this the same as if the wait was interrupted
-        if (status == ETIME) { status = EINTR; }
+        if (status == ETIMEDOUT) { status = EINTR; } 
         assert_status(status == 0 || status == EINTR, status, "cond_wait");
      }
      -- _nParked ;
@@ -4454,10 +4788,10 @@ int os::PlatformEvent::park(jlong millis) {
       pthread_cond_init (_cond, NULL) ;
     }
     assert_status(status == 0 || status == EINTR ||
-                  status == ETIME || status == ETIMEDOUT,
+		  status == ETIMEDOUT, 
                   status, "cond_timedwait");
     if (!FilterSpuriousWakeups) break ;                 // previous semantics
-    if (status == ETIME || status == ETIMEDOUT) break ;
+    if (status == ETIMEDOUT) break ; 
     // We consume and ignore EINTR and spurious wakeups.
   }
   --_nParked ;
@@ -4549,7 +4883,7 @@ void os::PlatformEvent::unpark() {
  * years from "now".
  */
 
-static void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {
+static void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
 
   struct timeval now;
@@ -4608,7 +4942,7 @@ void Parker::park(bool isAbsolute, jlong time) {
   }
 
   // Next, demultiplex/decode time arguments
-  timespec absTime;
+  struct timespec absTime;
   if (time < 0) { // don't wait at all
     return;
   }
@@ -4661,7 +4995,7 @@ void Parker::park(bool isAbsolute, jlong time) {
     }
   }
   assert_status(status == 0 || status == EINTR ||
-                status == ETIME || status == ETIMEDOUT,
+                status == ETIMEDOUT, 
                 status, "cond_timedwait");
 
 #ifdef ASSERT
@@ -4705,28 +5039,19 @@ void Parker::unpark() {
 
 extern char** environ;
 
-#ifndef __NR_fork
-#define __NR_fork IA32_ONLY(2) IA64_ONLY(not defined) AMD64_ONLY(57)
-#endif
-
-#ifndef __NR_execve
-#define __NR_execve IA32_ONLY(11) IA64_ONLY(1033) AMD64_ONLY(59)
-#endif
-
 // Run the specified command in a separate process. Return its exit value,
 // or -1 on failure (e.g. can't fork a new process).
 // Unlike system(), this function can be called from signal handler. It
 // doesn't block SIGINT et al.
 int os::fork_and_exec(char* cmd) {
-  const char * argv[4] = {"sh", "-c", cmd, NULL};
+  char * const argv[4] = {"sh", "-c", cmd, NULL};
 
   // fork() in BsdThreads/NPTL is not async-safe. It needs to run
   // pthread_atfork handlers and reset pthread library. All we need is a
   // separate process to execve. Make a direct syscall to fork process.
   // On IA64 there's no fork syscall, we have to use fork() and hope for
   // the best...
-  pid_t pid = NOT_IA64(syscall(__NR_fork);)
-              IA64_ONLY(fork();)
+  pid_t pid = fork();
 
   if (pid < 0) {
     // fork failed
@@ -4742,8 +5067,7 @@ int os::fork_and_exec(char* cmd) {
     // in the new process, so make a system call directly.
     // IA64 should use normal execve() from glibc to match the glibc fork()
     // above.
-    NOT_IA64(syscall(__NR_execve, "/bin/sh", argv, environ);)
-    IA64_ONLY(execve("/bin/sh", (char* const*)argv, environ);)
+    execve("/bin/sh", argv, environ);
 
     // execve failed
     _exit(-1);
