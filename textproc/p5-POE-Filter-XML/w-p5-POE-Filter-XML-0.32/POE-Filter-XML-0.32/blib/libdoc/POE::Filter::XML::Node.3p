.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POE::Filter::XML::Node 3"
.TH POE::Filter::XML::Node 3 "2007-01-02" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
POE::Filter::XML::Node \- Fully featured XML node representation.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use POE::Filter::XML::Node;
.PP
my \f(CW$node\fR = POE::Filter::XML::Node\->new('iq'); 
.PP
$node\->attr('to', 'nickperez@jabber.org'); 
\&\f(CW$node\fR\->attr('from', 'POE::Filter::XML::Node@jabber.org'); 
\&\f(CW$node\fR\->attr('type', 'get'); 
.PP
my \f(CW$query\fR = \f(CW$node\fR\->insert_tag('query', 'jabber:iq:foo');
\&\f(CW$query\fR\->insert_tag('foo_tag')\->data('bar');
my \f(CW$foo\fR = \f(CW$query\fR\->get_tag('foo_tag');
my \f(CW$foo2\fR = \f(CW$foo\fR\->\fIclone()\fR;
\&\f(CW$foo2\fR\->data('new_data');
\&\f(CW$query\fR\->insert_tag($foo2);
.PP
print \f(CW$node\fR\->\fIto_str()\fR . \*(L"\en\*(R";
.PP
\&\-\- 
.PP
(newlines and tabs for example only)
.PP
.Vb 7
\& <iq to='nickperez@jabber.org' 
\&  from='POE::Filter::XML::Node@jabber.org' type='get'>
\&   <query xmlns='jabber:iq:foo'>
\&     <foo_tag>bar</foo_tag>
\&     <foo_tag>new_data</foo_tag>
\&   </query>
\& </iq>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Filter::XML::Node aims to be a very simple yet powerful, memory/speed 
conscious module that allows \s-1JABBER\s0(tm) developers to have the flexibility 
they need to build custom nodes, use it as the basis of their higher level
libraries, or manipulating \s-1XML\s0 and then putting it out to a file.
.PP
Note that this is not a parser. This is merely the node representation that 
can be used to build \s-1XML\s0 objects that will give stringified versions of 
themselves.
.SH "METHODS"
.IX Header "METHODS"
.IP "\fInew()\fR" 4
.IX Item "new()"
\&\fInew()\fR accepts as arguments the (1) name of the actual tag (ie. 'iq'), (2) an 
arrayref of attribute pairs for \fIinsert_attrs()\fR. All of the arguments are 
optional and can be specified through other methods at a later time.
.IP "\fIstream_start()\fR" 4
.IX Item "stream_start()"
\&\fIstream_start()\fR called without arguments returns a bool on whether or not the
node in question is the top level document tag. In an xml stream such as
\&\s-1XMPP\s0 this is the <stream:stream> tag. Called with a single argument (a bool)
sets whether this tag should be considered a stream starter.
.Sp
This method is significant because it determines the behavior of the \fIto_str()\fR
method. If \fIstream_start()\fR returns bool true, the tag will not be terminated.
(ie. <iq to='test' from='test'> instead of <iq to='test' from='test'\fB/\fR>)
.IP "\fIstream_end()\fR" 4
.IX Item "stream_end()"
\&\fIstream_end()\fR called without arguments returns a bool on whether or not the
node in question is the closing document tag in a stream. In an xml stream
such as \s-1XMPP\s0, this is the </stream:stream>. Called with a single argument (a 
bool) sets whether this tag should be considered a stream ender.
.Sp
This method is significant because it determines the behavior of the \fIto_str()\fR
method. If \fIstream_end()\fR returns bool true, then any data or attributes or
children of the node is ignored and an ending tag is constructed. 
.Sp
(ie. </iq> instead of <iq to='test' from='test'><child/></iq>)
.IP "\fIclone()\fR" 4
.IX Item "clone()"
\&\fIclone()\fR does a \fBdeep\fR copy of the node and returns it. This includes all of
its children, data, attributes, etc. The returned node stands on its own and 
does not hold any references to the node cloned. Also note that it has its own 
unique creation \s-1ID\s0.
.Sp
Note: This method works but is expensive with self-referential nodes.
.IP "\fIget_id()\fR" 4
.IX Item "get_id()"
\&\fIget_id()\fR returns the creation \s-1ID\s0 of the node. Useful for sorting. Creation IDs 
are unique to each Node.
.IP "\fIparent()\fR" 4
.IX Item "parent()"
\&\fIparent()\fR returns the nodes parent reference
.IP "\fIname()\fR" 4
.IX Item "name()"
\&\fIname()\fR with no arguments returns the name of the node. With an argument, the
name of the node is changed.
.IP "\fIinsert_attrs()\fR" 4
.IX Item "insert_attrs()"
\&\fIinsert_attrs()\fR accepts a single arguement: an array reference. Basically you
pair up all the attributes you want to be into the node (ie. [attrib, value])
and this method will process them using \fIattr()\fR. This is just a convenience 
method.
.IP "\fIattr()\fR" 4
.IX Item "attr()"
\&\fIattr()\fR with one argument returns the value of that attrib (ie. 
my \f(CW$attrib\fR = \f(CW$node\fR\->attr('x') ). With another argument it sets that attribute
to the value supplie (ie. \f(CW$node\fR\->attr('x', 'value')). If the second argument
is an empty string, then that attribute will be deleted and returned.
.IP "\fIget_attrs()\fR" 4
.IX Item "get_attrs()"
\&\fIget_attrs()\fR returns a hash reference to the stored attribute/value pairs
within the node.
.IP "\fIdata()\fR" 4
.IX Item "data()"
\&\fIdata()\fR with no arguments returns the data stored in the node \fBdecoded\fR. With
one argument, data is stored into the node \fBencoded\fR. To access raw data with
out going through the encoding mechanism, see \fIrawdata()\fR.
.IP "\fIrawdata()\fR" 4
.IX Item "rawdata()"
\&\fIrawdata()\fR is similar to \fIdata()\fR but without the encoding/decocing implictly
occuring. Be cautious with this, because you may inadvertently send malformed
xml over the wire if you are not careful to encode your data for transport.
.IP "\fIinsert_tag()\fR" 4
.IX Item "insert_tag()"
\&\fIinsert_tag()\fR accepts two arguments, with (1) being either the name as a string 
of a new tag to build and then insert into the parent node, or (1) being a 
POE::Filter::XML::Node reference to add to the parents children, and (2) if 
(1) is a string then you pass along an optional arrayref of attribute pairs 
for \fIinsert_attrs()\fR to be built into the new child. \fIinsert_tag()\fR returns either
newly created node, or the reference passed in originally, respectively.
.Sp
Note: You may safely insert yourself or any of your ascendants including your
direct parent.
.IP "\fIto_str()\fR" 4
.IX Item "to_str()"
\&\fIto_str()\fR returns a string representation of the entire node structure. Note
there is no caching of stringifying nodes, so each operation is expensive. It
really should wait until it's time to serialized to be sent over the wire.
.Sp
Note: Any self-referential or circular-referential links in your Node will only
output the tag of the referent. ie. <parent><child><parent/></child></parent>
Otherwise there is the problem with infinite recursion and we can't have that.
.IP "\fIget_tag()\fR" 4
.IX Item "get_tag()"
\&\fIget_tag()\fR takes one argument, (1) the name of the tag wanted. Depending on 
the context of the return value (array or scalar), \fIget_tag()\fR either returns an
array of nodes match the name of the tag/filter supplied, or a single 
POE::Filter::XML::Node reference that matches, respectively. If there is no 
tag matching the specified argument, undef is returned.
.IP "\fIdetach_child()\fR \s-1DEPRECATED:\s0 \s-1PLEASE\s0 \s-1SEE\s0 \s-1DETACH\s0" 4
.IX Item "detach_child() DEPRECATED: PLEASE SEE DETACH"
\&\fIdetach_child()\fR takes one argument: a POE::Filter::XML::Node reference that is 
a child of the node. It then removes that child from its children and returns 
it as a stand alone node on its own.
.IP "\fIdetach()\fR" 4
.IX Item "detach()"
\&\fIdetach()\fR takes no arguments and will sever itself from the tree to be a stand 
alone Node. In the case of self-referential Nodes, the internal counter is 
decremented by one and its position is removed. If multiple references exist 
(ie. you store yourself as several children), one of those children is removed.
The invoking object will return itself.
.IP "\fIget_children()\fR" 4
.IX Item "get_children()"
\&\fIget_children()\fR returns an array reference to all the children of that node.
.IP "\fIget_children_hash()\fR" 4
.IX Item "get_children_hash()"
\&\fIget_children_hash()\fR returns a hash reference to all the children of that node.
Note: for more than one child with the same name, the entry in the hash will be
an array reference.
.IP "\fIget_sort_children()\fR" 4
.IX Item "get_sort_children()"
\&\fIget_sort_children()\fR returns an array reference to all children of that node
in sorted order according to their creation \s-1ID\s0.
.SH "BUGS AND NOTES"
.IX Header "BUGS AND NOTES"
By request, parent and parent related functions are returned and safely 
implemented using Scalar::Util::weaken. The performance penalty has not been
fully assessed, so proper testing should be utilized to ascertain the full
extent of the added (mis)features.
.PP
Also note that ancesants are carefully tracked to avoid infinite recursion for 
methods such as \fIto_str()\fR and \fIclone()\fR. Although the functionality has been 
been tested, managing self-referential decendants is highly discouraged and may
introduce weird behaviors because weakened references must be tracked by hand. 
You have been warned.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2003, 2004, 2006 Nicholas Perez. Released and distributed under the \s-1GPL\s0.
