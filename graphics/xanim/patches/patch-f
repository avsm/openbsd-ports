--- xa_acodec.c.orig	Wed Dec  2 03:05:20 1998
+++ xa_acodec.c	Wed Dec  2 03:05:34 1998
@@ -161,6 +161,7 @@
   return(ocnt);
 }
 
+
 /********** XA_ADecode_PCMXM_PCM1M *********************************
  * Convert PCM 1+2 BPS Mono Samples into PCM 1 BPS Mono Samples
  * The order flag takes care of the various linear/signed/endian
@@ -192,7 +193,17 @@
   {
     if (inc_cnt < (1<<24))
     {	/*** Decode Sample ***/
-      dataL = (spec & 4)?(ibuf[1]):(*ibuf);	
+	   if (snd_hdr->volume_boost)
+			{
+			unsigned c = snd_hdr->volume_boost;
+			unsigned d = 8 - c;
+			if (spec & 4)
+				dataL = (ibuf[1]<<c) | (ibuf[0]>>d);
+			else
+				dataL = (ibuf[0]<<c) | (ibuf[1]>>d);
+			}
+		else
+			dataL = (spec & 4)?(ibuf[1]):(*ibuf);	
       ibuf += bps;	byte_cnt += bps;	samp_cnt--;
       inc_cnt += inc;
     }
@@ -1799,6 +1810,19 @@
   finc = (double)(fadj_freq)/ (double)(ifreq);
   new_snd->inc = inc = (xaULONG)( finc * (double)(1<<24) );
   new_snd->inc_cnt = 0;
+
+  if (vaudiof->amp_scale < 2.0)
+  	new_snd->volume_boost = 0;
+  else if (vaudiof->amp_scale < 4.0)
+  	new_snd->volume_boost = 1;
+  else if (vaudiof->amp_scale < 8.0)
+  	new_snd->volume_boost = 2;
+  else if (vaudiof->amp_scale < 16.0)
+  	new_snd->volume_boost = 3;
+  else if (vaudiof->amp_scale < 32.0)
+  	new_snd->volume_boost = 4;
+  else 
+  	new_snd->volume_boost = 5;
 
   /* Determine Chunk Time */
   ftime = ((double)(xa_vaudio_hard_buff) * 1000.0) / (double)(hfreq);
