$OpenBSD: patch-kopete_libkopete_avdevice_videodevice_cpp,v 1.1 2006/04/29 01:02:24 brad Exp $
--- kopete/libkopete/avdevice/videodevice.cpp.orig	Fri Mar 17 05:12:32 2006
+++ kopete/libkopete/avdevice/videodevice.cpp	Fri Apr 28 15:52:51 2006
@@ -141,6 +141,9 @@ int VideoDevice::checkDevice()
 		m_driver=VIDEODEV_DRIVER_NONE;
 #if defined(__linux__) && defined(ENABLE_AV)
 #ifdef HAVE_V4L2
+
+if(!getWorkaroundBrokenDriver())
+{
 		CLEAR(V4L2_capabilities);
 
 		if (-1 != xioctl (VIDIOC_QUERYCAP, &V4L2_capabilities))
@@ -214,7 +217,8 @@ int VideoDevice::checkDevice()
 				{
 					VideoInput tempinput;
 					tempinput.name = QString::fromLocal8Bit((const char*)videoinput.name);
-					tempinput.hastuner=videoinput.type & V4L2_INPUT_TYPE_TUNER;
+					tempinput.hastuner = videoinput.type & V4L2_INPUT_TYPE_TUNER;
+					tempinput.m_standards = videoinput.std;
 					m_input.push_back(tempinput);
 					kdDebug() <<  k_funcinfo << "Input " << loop << ": " << tempinput.name << " (tuner: " << ((videoinput.type & V4L2_INPUT_TYPE_TUNER) != 0) << ")" << endl;
 					if((videoinput.type & V4L2_INPUT_TYPE_TUNER) != 0)
@@ -237,6 +241,8 @@ int VideoDevice::checkDevice()
 // it will try the V4L api even if the error code is different than expected.
 			kdDebug() <<  k_funcinfo << "checkDevice(): " << full_filename << " is not a V4L2 device." << endl;
 		}
+
+}
 #endif
 
 		CLEAR(V4L_capabilities);
@@ -285,6 +291,7 @@ int VideoDevice::checkDevice()
 						VideoInput tempinput;
 						tempinput.name = QString::fromLocal8Bit((const char*)videoinput.name);
 						tempinput.hastuner=videoinput.flags & VIDEO_VC_TUNER;
+// TODO: The routine to detect the appropriate video standards for V4L must be placed here
 						m_input.push_back(tempinput);
 //						kdDebug() << "libkopete (avdevice): Input " << loop << ": " << tempinput.name << " (tuner: " << ((videoinput.flags & VIDEO_VC_TUNER) != 0) << ")" << endl;
 /*						if((input.type & V4L2_INPUT_TYPE_TUNER) != 0)
@@ -303,6 +310,8 @@ int VideoDevice::checkDevice()
 		}
 #endif
 		m_name=m_model; // Take care about changing the name to be different from the model itself...
+// TODO: THis thing can be used to detec what pixel formats are supported in a API-independent way, but V4L2 has VIDIOC_ENUM_PIXFMT.
+// The correct thing to do is to isolate these calls and do a proper implementation for V4L and another for V4L2 when this thing will be migrated to a plugin architecture.
 		kdDebug() <<  k_funcinfo << "checkDevice(): " << "Supported pixel formats:" << endl;
 		if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_GREY))
 			kdDebug() <<  k_funcinfo << "checkDevice(): " << pixelFormatName(PIXELFORMAT_GREY) << endl;
@@ -333,7 +342,7 @@ int VideoDevice::checkDevice()
 		if(PIXELFORMAT_NONE != setPixelFormat(PIXELFORMAT_YUV420P))
 			kdDebug() <<  k_funcinfo << "checkDevice(): " << pixelFormatName(PIXELFORMAT_YUV420P) << endl;
 
-		// Now we must execute the proper initialization according to the type of the driver.
+// TODO: Now we must execute the proper initialization according to the type of the driver.
 		kdDebug() <<  k_funcinfo << "checkDevice() exited successfuly." << endl;
 		return EXIT_SUCCESS;
 	}
@@ -743,7 +752,6 @@ int VideoDevice::selectInput(int newinpu
 	if(m_current_input >= inputs())
 		return EXIT_FAILURE;
 
-	m_current_input = newinput;
 	if(isOpen())
 	{
 		switch (m_driver)
@@ -761,7 +769,7 @@ int VideoDevice::selectInput(int newinpu
 			case VIDEODEV_DRIVER_V4L:
 				struct video_channel V4L_input;
 				V4L_input.channel=newinput;
-				V4L_input.norm=1;
+				V4L_input.norm=4; // Hey, it's plain wrong! It should be input's signal standard!
 				if (-1 == ioctl (descriptor, VIDIOCSCHAN, &V4L_input))
 				{
 					perror ("ioctl (VIDIOCSCHAN)");
@@ -774,6 +782,7 @@ int VideoDevice::selectInput(int newinpu
 				break;
 		}
 		kdDebug() <<  k_funcinfo << "Selected input " << newinput << " (" << m_input[newinput].name << ")" << endl;
+		m_current_input = newinput;
 		setInputParameters();
 		return EXIT_SUCCESS;
 	}
@@ -1282,7 +1291,10 @@ int VideoDevice::close()
 
 float VideoDevice::getBrightness()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getBrightness();
+  else
+	return 0;
 }
 
 float VideoDevice::setBrightness(float brightness)
@@ -1317,7 +1329,10 @@ float VideoDevice::setBrightness(float b
 
 float VideoDevice::getContrast()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getContrast();
+  else
+	return 0;
 }
 
 float VideoDevice::setContrast(float contrast)
@@ -1352,7 +1367,10 @@ float VideoDevice::setContrast(float con
 
 float VideoDevice::getSaturation()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getSaturation();
+  else
+	return 0;
 }
 
 float VideoDevice::setSaturation(float saturation)
@@ -1387,7 +1405,10 @@ float VideoDevice::setSaturation(float s
 
 float VideoDevice::getWhiteness()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getWhiteness();
+  else
+	return 0;
 }
 
 float VideoDevice::setWhiteness(float whiteness)
@@ -1422,7 +1443,10 @@ float VideoDevice::setWhiteness(float wh
 
 float VideoDevice::getHue()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getHue();
+  else
+	return 0;
 }
 
 float VideoDevice::setHue(float hue)
@@ -1458,41 +1482,77 @@ float VideoDevice::setHue(float hue)
 
 bool VideoDevice::getAutoBrightnessContrast()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getAutoBrightnessContrast();
+  else
+	return false;
 }
 
 bool VideoDevice::setAutoBrightnessContrast(bool brightnesscontrast)
 {
 	kdDebug() <<  k_funcinfo << "VideoDevice::setAutoBrightnessContrast(" << brightnesscontrast << ") called." << endl;
-	m_input[m_current_input].setAutoBrightnessContrast(brightnesscontrast);
-	return m_input[m_current_input].getAutoBrightnessContrast();
-
+	if (m_current_input < m_input.size() ) 
+	  {
+		m_input[m_current_input].setAutoBrightnessContrast(brightnesscontrast);
+		return m_input[m_current_input].getAutoBrightnessContrast();
+	  }
+	else
+	  return false;
+   
 }
 
 bool VideoDevice::getAutoColorCorrection()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getAutoColorCorrection();
+  else
+	return false;
 }
 
 bool VideoDevice::setAutoColorCorrection(bool colorcorrection)
 {
 	kdDebug() <<  k_funcinfo << "VideoDevice::setAutoColorCorrection(" << colorcorrection << ") called." << endl;
-	m_input[m_current_input].setAutoColorCorrection(colorcorrection);
-	return m_input[m_current_input].getAutoColorCorrection();
+	if (m_current_input < m_input.size() )
+	  {
+		m_input[m_current_input].setAutoColorCorrection(colorcorrection);
+		return m_input[m_current_input].getAutoColorCorrection();
+	  }
+	else
+	  return false;
 }
 
 bool VideoDevice::getImageAsMirror()
 {
+  if (m_current_input < m_input.size() )
 	return m_input[m_current_input].getImageAsMirror();
+  else
+	return false;
 }
 
 bool VideoDevice::setImageAsMirror(bool imageasmirror)
 {
 	kdDebug() <<  k_funcinfo << "VideoDevice::setImageAsMirror(" << imageasmirror << ") called." << endl;
-	m_input[m_current_input].setImageAsMirror(imageasmirror);
-	return m_input[m_current_input].getImageAsMirror();
+	if (m_current_input < m_input.size() ) 
+	  {
+		m_input[m_current_input].setImageAsMirror(imageasmirror);
+		return m_input[m_current_input].getImageAsMirror();
+	  }
+	else
+	  return false;
 }
 
+bool VideoDevice::getDisableMMap()
+{
+	return m_disablemmap;
+}
+
+bool VideoDevice::setDisableMMap(bool disablemmap)
+{
+	kdDebug() <<  k_funcinfo << "VideoDevice::setDisableMMap(" << disablemmap << ") called." << endl;
+	m_disablemmap = disablemmap;
+	return m_disablemmap;
+}
+
 bool VideoDevice::getWorkaroundBrokenDriver()
 {
 	return m_workaroundbrokendriver;
@@ -1637,6 +1697,7 @@ int VideoDevice::pixelFormatDepth(pixel_
 QString VideoDevice::pixelFormatName(pixel_format pixelformat)
 {
 	QString returnvalue;
+	returnvalue = "None";
 	switch(pixelformat)
 	{
 		case PIXELFORMAT_NONE	: returnvalue = "None";			break;
@@ -1669,36 +1730,36 @@ QString VideoDevice::pixelFormatName(int
 		case VIDEODEV_DRIVER_V4L2:
 			switch(pixelformat)
 			{
-				case V4L2_PIX_FMT_GREY		: returnvalue = "8-bit Grayscale";	break;
-				case V4L2_PIX_FMT_RGB332	: returnvalue = "8-bit RGB332";		break;
-				case V4L2_PIX_FMT_RGB555	: returnvalue = "16-bit RGB555";	break;
-				case V4L2_PIX_FMT_RGB555X	: returnvalue = "16-bit RGB555X";	break;
-				case V4L2_PIX_FMT_RGB565	: returnvalue = "16-bit RGB565";	break;
-				case V4L2_PIX_FMT_RGB565X	: returnvalue = "16-bit RGB565X";	break;
-				case V4L2_PIX_FMT_RGB24		: returnvalue = "24-bit RGB24";		break;
-				case V4L2_PIX_FMT_BGR24		: returnvalue = "24-bit BGR24";		break;
-				case V4L2_PIX_FMT_RGB32		: returnvalue = "32-bit RGB32";		break;
-				case V4L2_PIX_FMT_BGR32		: returnvalue = "32-bit BGR32";		break;
-				case V4L2_PIX_FMT_YUYV		: returnvalue = "Packed YUV 4:2:2";	break;
-				case V4L2_PIX_FMT_UYVY		: returnvalue = "Packed YVU 4:2:2";	break;
-				case V4L2_PIX_FMT_YUV420	: returnvalue = "Planar YUV 4:2:0";	break;
-				case V4L2_PIX_FMT_YUV422P	: returnvalue = "Planar YUV 4:2:2";	break;
+				case V4L2_PIX_FMT_GREY		: returnvalue = pixelFormatName(PIXELFORMAT_GREY);	break;
+				case V4L2_PIX_FMT_RGB332	: returnvalue = pixelFormatName(PIXELFORMAT_RGB332);	break;
+				case V4L2_PIX_FMT_RGB555	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555);	break;
+				case V4L2_PIX_FMT_RGB555X	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555X);	break;
+				case V4L2_PIX_FMT_RGB565	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565);	break;
+				case V4L2_PIX_FMT_RGB565X	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565X);	break;
+				case V4L2_PIX_FMT_RGB24		: returnvalue = pixelFormatName(PIXELFORMAT_RGB24);	break;
+				case V4L2_PIX_FMT_BGR24		: returnvalue = pixelFormatName(PIXELFORMAT_BGR24);	break;
+				case V4L2_PIX_FMT_RGB32		: returnvalue = pixelFormatName(PIXELFORMAT_RGB32);	break;
+				case V4L2_PIX_FMT_BGR32		: returnvalue = pixelFormatName(PIXELFORMAT_BGR32);	break;
+				case V4L2_PIX_FMT_YUYV		: returnvalue = pixelFormatName(PIXELFORMAT_YUYV);	break;
+				case V4L2_PIX_FMT_UYVY		: returnvalue = pixelFormatName(PIXELFORMAT_UYVY);	break;
+				case V4L2_PIX_FMT_YUV420	: returnvalue = pixelFormatName(PIXELFORMAT_YUV420P);	break;
+				case V4L2_PIX_FMT_YUV422P	: returnvalue = pixelFormatName(PIXELFORMAT_YUV422P);	break;
 			}
 			break;
 #endif
 		case VIDEODEV_DRIVER_V4L:
 			switch(pixelformat)
 			{
-				case VIDEO_PALETTE_GREY		: returnvalue = "8-bit Grayscale";	break;
-				case VIDEO_PALETTE_HI240	: returnvalue = "8-bit RGB332";		break;
-				case VIDEO_PALETTE_RGB555	: returnvalue = "16-bit RGB555";	break;
-				case VIDEO_PALETTE_RGB565	: returnvalue = "16-bit RGB565";	break;
-				case VIDEO_PALETTE_RGB24	: returnvalue = "24-bit RGB24";		break;
-				case VIDEO_PALETTE_RGB32	: returnvalue = "32-bit RGB32";		break;
-				case VIDEO_PALETTE_YUYV		: returnvalue = "Packed YUV 4:2:2";	break;
-				case VIDEO_PALETTE_UYVY		: returnvalue = "Packed YVU 4:2:2";	break;
-				case VIDEO_PALETTE_YUV420	: returnvalue = "Planar YUV 4:2:0";	break;
-				case VIDEO_PALETTE_YUV422P	: returnvalue = "Planar YUV 4:2:2";	break;
+				case VIDEO_PALETTE_GREY		: returnvalue = pixelFormatName(PIXELFORMAT_GREY);	break;
+				case VIDEO_PALETTE_HI240	: returnvalue = pixelFormatName(PIXELFORMAT_RGB332);	break;
+				case VIDEO_PALETTE_RGB555	: returnvalue = pixelFormatName(PIXELFORMAT_RGB555);	break;
+				case VIDEO_PALETTE_RGB565	: returnvalue = pixelFormatName(PIXELFORMAT_RGB565);	break;
+				case VIDEO_PALETTE_RGB24	: returnvalue = pixelFormatName(PIXELFORMAT_RGB24);	break;
+				case VIDEO_PALETTE_RGB32	: returnvalue = pixelFormatName(PIXELFORMAT_RGB32);	break;
+				case VIDEO_PALETTE_YUYV		: returnvalue = pixelFormatName(PIXELFORMAT_YUYV);	break;
+				case VIDEO_PALETTE_UYVY		: returnvalue = pixelFormatName(PIXELFORMAT_UYVY);	break;
+				case VIDEO_PALETTE_YUV420	: returnvalue = pixelFormatName(PIXELFORMAT_YUV420P);	break;
+				case VIDEO_PALETTE_YUV422P	: returnvalue = pixelFormatName(PIXELFORMAT_YUV422P);	break;
 			}
 			break;
 #endif
@@ -1707,6 +1768,238 @@ QString VideoDevice::pixelFormatName(int
 			break;
 	}
 	return returnvalue;
+}
+
+__u64 VideoDevice::signalStandardCode(signal_standard standard)
+{
+	switch(m_driver)
+	{
+#if defined(__linux__) && defined(ENABLE_AV)
+#ifdef HAVE_V4L2
+		case VIDEODEV_DRIVER_V4L2:
+			switch(standard)
+			{
+				case STANDARD_NONE	: return V4L2_STD_UNKNOWN;	break;
+				case STANDARD_PAL_B	: return V4L2_STD_PAL_B;	break;
+				case STANDARD_PAL_B1	: return V4L2_STD_PAL_B1;	break;
+				case STANDARD_PAL_G	: return V4L2_STD_PAL_G;	break;
+				case STANDARD_PAL_H	: return V4L2_STD_PAL_H;	break;
+				case STANDARD_PAL_I	: return V4L2_STD_PAL_I;	break;
+				case STANDARD_PAL_D	: return V4L2_STD_PAL_D;	break;
+				case STANDARD_PAL_D1	: return V4L2_STD_PAL_D1;	break;
+				case STANDARD_PAL_K	: return V4L2_STD_PAL_K;	break;
+				case STANDARD_PAL_M	: return V4L2_STD_PAL_M;	break;
+				case STANDARD_PAL_N	: return V4L2_STD_PAL_N;	break;
+				case STANDARD_PAL_Nc	: return V4L2_STD_PAL_Nc;	break;
+				case STANDARD_PAL_60	: return V4L2_STD_PAL_60;	break;
+				case STANDARD_NTSC_M	: return V4L2_STD_NTSC_M;	break;
+				case STANDARD_NTSC_M_JP	: return V4L2_STD_NTSC_M_JP;	break;
+				case STANDARD_NTSC_443	: return V4L2_STD_NTSC;		break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_SECAM_B	: return V4L2_STD_SECAM_B;	break;
+				case STANDARD_SECAM_D	: return V4L2_STD_SECAM_D;	break;
+				case STANDARD_SECAM_G	: return V4L2_STD_SECAM_G;	break;
+				case STANDARD_SECAM_H	: return V4L2_STD_SECAM_H;	break;
+				case STANDARD_SECAM_K	: return V4L2_STD_SECAM_K;	break;
+				case STANDARD_SECAM_K1	: return V4L2_STD_SECAM_K1;	break;
+				case STANDARD_SECAM_L	: return V4L2_STD_SECAM_L;	break;
+				case STANDARD_SECAM_LC	: return V4L2_STD_SECAM;	break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_ATSC_8_VSB	: return V4L2_STD_ATSC_8_VSB;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_ATSC_16_VSB	: return V4L2_STD_ATSC_16_VSB;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_PAL_BG	: return V4L2_STD_PAL_BG;	break;
+				case STANDARD_PAL_DK	: return V4L2_STD_PAL_DK;	break;
+				case STANDARD_PAL	: return V4L2_STD_PAL;		break;
+				case STANDARD_NTSC	: return V4L2_STD_NTSC;		break;
+				case STANDARD_SECAM_DK	: return V4L2_STD_SECAM_DK;	break;
+				case STANDARD_SECAM	: return V4L2_STD_SECAM;	break;
+				case STANDARD_525_60	: return V4L2_STD_525_60;	break;
+				case STANDARD_625_50	: return V4L2_STD_625_50;	break;
+				case STANDARD_ALL	: return V4L2_STD_ALL;		break;
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_V4L:
+			switch(standard)
+			{
+				case STANDARD_NONE	: return VIDEO_MODE_AUTO;	break;
+				case STANDARD_PAL_B	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_B1	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_G	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_H	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_I	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_D	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_D1	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_K	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_M	: return 5;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_PAL_N	: return 6;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_PAL_Nc	: return 4;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_PAL_60	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_NTSC_M	: return VIDEO_MODE_NTSC;	break;
+				case STANDARD_NTSC_M_JP	: return 7;	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case STANDARD_NTSC_443	: return VIDEO_MODE_NTSC;	break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_SECAM_B	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_D	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_G	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_H	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_K	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_K1	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_L	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM_LC	: return VIDEO_MODE_SECAM;	break; // Using workaround value because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case STANDARD_ATSC_8_VSB	: return VIDEO_MODE_AUTO;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_ATSC_16_VSB	: return VIDEO_MODE_AUTO;	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case STANDARD_PAL_BG	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL_DK	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_PAL	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_NTSC	: return VIDEO_MODE_NTSC;	break;
+				case STANDARD_SECAM_DK	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_SECAM	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_525_60	: return VIDEO_MODE_PAL;	break;
+				case STANDARD_625_50	: return VIDEO_MODE_SECAM;	break;
+				case STANDARD_ALL	: return VIDEO_MODE_AUTO;	break;
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_NONE:
+		default:
+			return STANDARD_NONE;	break;
+	}
+	return STANDARD_NONE;
+}
+
+QString VideoDevice::signalStandardName(signal_standard standard)
+{
+	QString returnvalue;
+	returnvalue = "None";
+	switch(standard)
+	{
+		case STANDARD_NONE	: returnvalue = "None";		break;
+		case STANDARD_PAL_B	: returnvalue = "PAL-B";	break;
+		case STANDARD_PAL_B1	: returnvalue = "PAL-B1"; 	break;
+		case STANDARD_PAL_G	: returnvalue = "PAL-G";	break;
+		case STANDARD_PAL_H	: returnvalue = "PAL-H";	break;
+		case STANDARD_PAL_I	: returnvalue = "PAL-I";	break;
+		case STANDARD_PAL_D	: returnvalue = "PAL-D";	break;
+		case STANDARD_PAL_D1	: returnvalue = "PAL-D1";	break;
+		case STANDARD_PAL_K	: returnvalue = "PAL-K";	break;
+		case STANDARD_PAL_M	: returnvalue = "PAL-M";	break;
+		case STANDARD_PAL_N	: returnvalue = "PAL-N";	break;
+		case STANDARD_PAL_Nc	: returnvalue = "PAL-Nc";	break;
+		case STANDARD_PAL_60	: returnvalue = "PAL-60";	break;
+		case STANDARD_NTSC_M	: returnvalue = "NTSC-M";	break;
+		case STANDARD_NTSC_M_JP	: returnvalue = "NTSC-M(JP)";	break;
+		case STANDARD_NTSC_443	: returnvalue = "NTSC-443";	break;
+		case STANDARD_SECAM_B	: returnvalue = "SECAM-B";	break;
+		case STANDARD_SECAM_D	: returnvalue = "SECAM-D";	break;
+		case STANDARD_SECAM_G	: returnvalue = "SECAM-G";	break;
+		case STANDARD_SECAM_H	: returnvalue = "SECAM-H";	break;
+		case STANDARD_SECAM_K	: returnvalue = "SECAM-K";	break;
+		case STANDARD_SECAM_K1	: returnvalue = "SECAM-K1";	break;
+		case STANDARD_SECAM_L	: returnvalue = "SECAM-L";	break;
+		case STANDARD_SECAM_LC	: returnvalue = "SECAM-LC";	break;
+		case STANDARD_ATSC_8_VSB	: returnvalue = "ATSC-8-VSB";	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+		case STANDARD_ATSC_16_VSB	: returnvalue = "ATSC-16-VSB";	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+		case STANDARD_PAL_BG	: returnvalue = "PAL-BG";	break;
+		case STANDARD_PAL_DK	: returnvalue = "PAL-DK";	break;
+		case STANDARD_PAL	: returnvalue = "PAL";		break;
+		case STANDARD_NTSC	: returnvalue = "NTSC";		break;
+		case STANDARD_SECAM_DK  : returnvalue = "SECAM-DK";	break;
+		case STANDARD_SECAM	: returnvalue = "SECAM";	break;
+		case STANDARD_525_60	: returnvalue = "525 lines 60Hz";	break;
+		case STANDARD_625_50	: returnvalue = "625 lines 50Hz"; 	break;
+		case STANDARD_ALL	: returnvalue = "All";		break;
+	}
+	return returnvalue;
+}
+
+QString VideoDevice::signalStandardName(int standard)
+{
+	QString returnvalue;
+	returnvalue = "None";
+	switch(m_driver)
+	{
+#if defined(__linux__) && defined(ENABLE_AV)
+#ifdef HAVE_V4L2
+		case VIDEODEV_DRIVER_V4L2:
+			switch(standard)
+			{
+				case V4L2_STD_PAL_B	: returnvalue = signalStandardName(STANDARD_PAL_B);	break;
+				case V4L2_STD_PAL_B1	: returnvalue = signalStandardName(STANDARD_PAL_B1);	break;
+				case V4L2_STD_PAL_G	: returnvalue = signalStandardName(STANDARD_PAL_G);	break;
+				case V4L2_STD_PAL_H	: returnvalue = signalStandardName(STANDARD_PAL_H);	break;
+				case V4L2_STD_PAL_I	: returnvalue = signalStandardName(STANDARD_PAL_I);	break;
+				case V4L2_STD_PAL_D	: returnvalue = signalStandardName(STANDARD_PAL_D);	break;
+				case V4L2_STD_PAL_D1	: returnvalue = signalStandardName(STANDARD_PAL_D1);	break;
+				case V4L2_STD_PAL_K	: returnvalue = signalStandardName(STANDARD_PAL_K);	break;
+				case V4L2_STD_PAL_M	: returnvalue = signalStandardName(STANDARD_PAL_M);	break;
+				case V4L2_STD_PAL_N	: returnvalue = signalStandardName(STANDARD_PAL_N);	break;
+				case V4L2_STD_PAL_Nc	: returnvalue = signalStandardName(STANDARD_PAL_Nc);	break;
+				case V4L2_STD_PAL_60	: returnvalue = signalStandardName(STANDARD_PAL_60);	break;
+				case V4L2_STD_NTSC_M	: returnvalue = signalStandardName(STANDARD_NTSC_M);	break;
+				case V4L2_STD_NTSC_M_JP	: returnvalue = signalStandardName(STANDARD_NTSC_M_JP);	break;
+//				case V4L2_STD_NTSC_443	: returnvalue = signalStandardName(STANDARD_NTSC_443);	break; // Commented out because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case V4L2_STD_SECAM_B	: returnvalue = signalStandardName(STANDARD_SECAM_B);	break;
+				case V4L2_STD_SECAM_D	: returnvalue = signalStandardName(STANDARD_SECAM_D);	break;
+				case V4L2_STD_SECAM_G	: returnvalue = signalStandardName(STANDARD_SECAM_G);	break;
+				case V4L2_STD_SECAM_H	: returnvalue = signalStandardName(STANDARD_SECAM_H);	break;
+				case V4L2_STD_SECAM_K	: returnvalue = signalStandardName(STANDARD_SECAM_K);	break;
+				case V4L2_STD_SECAM_K1	: returnvalue = signalStandardName(STANDARD_SECAM_K1);	break;
+				case V4L2_STD_SECAM_L	: returnvalue = signalStandardName(STANDARD_SECAM_L);	break;
+//				case V4L2_STD_SECAM_LC	: returnvalue = signalStandardName(STANDARD_SECAM_LC);	break; // Commented out because my videodev2.h header seems to not include this standard in struct __u64 v4l2_std_id
+				case V4L2_STD_ATSC_8_VSB	: returnvalue = signalStandardName(STANDARD_ATSC_8_VSB);	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case V4L2_STD_ATSC_16_VSB	: returnvalue = signalStandardName(STANDARD_ATSC_16_VSB);	break; // ATSC/HDTV Standard officially not supported by V4L2 but exists in videodev2.h
+				case V4L2_STD_PAL_BG	: returnvalue = signalStandardName(STANDARD_PAL_BG);	break;
+				case V4L2_STD_PAL_DK	: returnvalue = signalStandardName(STANDARD_PAL_DK);	break;
+				case V4L2_STD_PAL	: returnvalue = signalStandardName(STANDARD_PAL);	break;
+				case V4L2_STD_NTSC	: returnvalue = signalStandardName(STANDARD_NTSC);	break;
+				case V4L2_STD_SECAM_DK	: returnvalue = signalStandardName(STANDARD_SECAM_DK);	break;
+				case V4L2_STD_SECAM	: returnvalue = signalStandardName(STANDARD_SECAM);	break;
+				case V4L2_STD_525_60	: returnvalue = signalStandardName(STANDARD_525_60);	break;
+				case V4L2_STD_625_50	: returnvalue = signalStandardName(STANDARD_625_50);	break;
+				case V4L2_STD_ALL	: returnvalue = signalStandardName(STANDARD_ALL);	break;
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_V4L:
+			switch(standard)
+			{
+				case VIDEO_MODE_PAL	: returnvalue = signalStandardName(STANDARD_PAL);	break;
+				case VIDEO_MODE_NTSC	: returnvalue = signalStandardName(STANDARD_NTSC);	break;
+				case VIDEO_MODE_SECAM	: returnvalue = signalStandardName(STANDARD_SECAM);	break;
+				case VIDEO_MODE_AUTO	: returnvalue = signalStandardName(STANDARD_ALL);	break;	// It must be disabled until I find a correct way to handle those non-standard bttv modes
+//				case VIDEO_MODE_PAL_Nc	: returnvalue = signalStandardName(STANDARD_PAL_Nc);	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case VIDEO_MODE_PAL_M	: returnvalue = signalStandardName(STANDARD_PAL_M);	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case VIDEO_MODE_PAL_N	: returnvalue = signalStandardName(STANDARD_PAL_N);	break;	// Undocumented value found to be compatible with V4L bttv driver
+				case VIDEO_MODE_NTSC_JP	: returnvalue = signalStandardName(STANDARD_NTSC_M_JP);	break;	// Undocumented value found to be compatible with V4L bttv driver
+			}
+			break;
+#endif
+		case VIDEODEV_DRIVER_NONE:
+		default:
+			break;
+	}
+	return returnvalue;
+}
+
+/*!
+    \fn VideoDevice::detectSignalStandards()
+ */
+int VideoDevice::detectSignalStandards()
+{
+	switch(m_driver)
+	{
+#if defined(__linux__) && defined(ENABLE_AV)
+#ifdef HAVE_V4L2
+		case VIDEODEV_DRIVER_V4L2:
+			break;
+#endif
+		case VIDEODEV_DRIVER_V4L:
+			break;
+#endif
+		case VIDEODEV_DRIVER_NONE:
+		default:
+			break;
+	}
+	//FIXME: return a real value
+	return 0;
 }
 
 /*!
