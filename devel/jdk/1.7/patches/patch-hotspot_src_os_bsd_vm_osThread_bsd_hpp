$OpenBSD: patch-hotspot_src_os_bsd_vm_osThread_bsd_hpp,v 1.4 2009/06/10 19:01:09 kurt Exp $
--- hotspot/src/os/bsd/vm/osThread_bsd.hpp.orig	Sat May 30 10:11:57 2009
+++ hotspot/src/os/bsd/vm/osThread_bsd.hpp	Sat May 30 10:14:49 2009
@@ -36,6 +36,12 @@
 
  private:
 
+#ifdef _ALLBSD_SOURCE
+  // _thread_id and _pthread_id are the same on BSD
+  // keep both to minimize code divergence in os_bsd.cpp
+  pthread_t _thread_id;
+  pthread_t _pthread_id;
+#else
   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
   // to access /proc.
@@ -44,6 +50,7 @@
   // _pthread_id is the pthread id, which is used by library calls
   // (e.g. pthread_kill).
   pthread_t _pthread_id;
+#endif
 
   sigset_t _caller_sigmask; // Caller's signal mask
 
@@ -53,12 +60,18 @@
   sigset_t  caller_sigmask() const       { return _caller_sigmask; }
   void    set_caller_sigmask(sigset_t sigmask)  { _caller_sigmask = sigmask; }
 
+#ifdef _ALLBSD_SOURCE
+  pthread_t thread_id() const {
+    return _thread_id;
+  }
+#else
   pid_t thread_id() const {
     return _thread_id;
   }
+#endif
 #ifndef PRODUCT
   // Used for debugging, return a unique integer for each thread.
-  int thread_identifier() const   { return _thread_id; }
+  intptr_t thread_identifier() const   { return (intptr_t)_pthread_id; }
 #endif
 #ifdef ASSERT
   // We expect no reposition failures so kill vm if we get one.
@@ -67,9 +80,15 @@
     return false;
   }
 #endif // ASSERT
+#ifdef _ALLBSD_SOURCE
+  void set_thread_id(pthread_t id) {
+    _thread_id = id;
+  }
+#else
   void set_thread_id(pid_t id) {
     _thread_id = id;
   }
+#endif
   pthread_t pthread_id() const {
     return _pthread_id;
   }
