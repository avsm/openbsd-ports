$OpenBSD: patch-src_os_unix_c,v 1.7 2009/04/05 00:02:54 martynas Exp $
--- src/os_unix.c.orig	Sun Feb 15 15:07:09 2009
+++ src/os_unix.c	Mon Mar 23 12:53:43 2009
@@ -111,6 +111,14 @@
 # define _LARGEFILE_SOURCE 1
 #endif
 
+/* PRNG device to use */
+#ifdef __OpenBSD__
+#define RAND_DEV "/dev/arandom"
+#else
+#define RAND_DEV "/dev/urandom"
+#endif
+
+
 /*
 ** standard include files.
 */
@@ -141,6 +149,9 @@
 #if SQLITE_THREADSAFE
 # include <pthread.h>
 # define SQLITE_UNIX_THREADS 1
+# if SQLITE_THREAD_OVERRIDE_LOCK != 1 || defined(SQLITE_TEST)
+#  define SQLITE_NEED_TID_CHECKS 1
+# endif
 #endif
 
 /*
@@ -186,7 +197,7 @@ struct unixFile {
 #if SQLITE_ENABLE_LOCKING_STYLE
   int openFlags;                   /* The flags specified at open() */
 #endif
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;                   /* The thread that "owns" this unixFile */
 #endif
 #if OS_VXWORKS
@@ -254,7 +265,7 @@ struct unixFile {
 ** The threadid macro resolves to the thread-id or to 0.  Used for
 ** testing and debugging only.
 */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 #define threadid pthread_self()
 #else
 #define threadid 0
@@ -664,7 +675,7 @@ static void vxworksReleaseFileId(struct vxworksFileId 
 ** recomputed because its key includes the thread-id.  See the 
 ** transferOwnership() function below for additional information
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 # define SET_THREADID(X)   (X)->tid = pthread_self()
 # define CHECK_THREADID(X) (threadsOverrideEachOthersLocks==0 && \
                             !pthread_equal((X)->tid, pthread_self()))
@@ -699,7 +710,7 @@ struct unixFileId {
 */
 struct unixLockKey {
   struct unixFileId fid;  /* Unique identifier for the file */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;  /* Thread ID of lock owner. Zero if not using LinuxThreads */
 #endif
 };
@@ -774,7 +785,7 @@ static struct unixOpenCnt *openList = 0;
 ** it a global so that the test code can change its value in order to verify
 ** that the right stuff happens in either case.
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 #  ifndef SQLITE_THREAD_OVERRIDE_LOCK
 #    define SQLITE_THREAD_OVERRIDE_LOCK -1
 #  endif
@@ -795,7 +806,7 @@ struct threadTestData {
   int result;            /* Result of the locking operation */
 };
 
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This function is used as the main routine for a thread launched by
 ** testThreadLockingBehavior(). It tests whether the shared-lock obtained
@@ -813,7 +824,7 @@ static void *threadLockingTest(void *pArg){
 #endif /* SQLITE_THREADSAFE && defined(__linux__) */
 
 
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This procedure attempts to determine whether or not threads
 ** can override each others locks then sets the 
@@ -958,7 +969,7 @@ static int findLockInfo(
 #else
   lockKey.fid.ino = statbuf.st_ino;
 #endif
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   if( threadsOverrideEachOthersLocks<0 ){
     testThreadLockingBehavior(fd);
   }
@@ -1035,7 +1046,7 @@ exit_findlockinfo:
 ** If the unixFile is locked and an ownership is wrong, then return
 ** SQLITE_MISUSE.  SQLITE_OK is returned if everything works.
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 static int transferOwnership(unixFile *pFile){
   int rc;
   pthread_t hSelf;
@@ -3950,7 +3961,7 @@ static int unixRandomness(sqlite3_vfs *NotUsed, int nB
 #if !defined(SQLITE_TEST)
   {
     int pid, fd;
-    fd = open("/dev/urandom", O_RDONLY);
+    fd = open(RAND_DEV, O_RDONLY);
     if( fd<0 ){
       time_t t;
       time(&t);
@@ -4253,7 +4264,7 @@ static int proxyGenerateHostID(char *pHostID){
   
   memset(key, 0, HOSTIDLEN);
   len = 0;
-  fd = open("/dev/urandom", O_RDONLY);
+  fd = open(RAND_DEV, O_RDONLY);
   if( fd>=0 ){
     len = read(fd, key, HOSTIDLEN);
     close(fd); /* silently leak the fd if it fails */
