*** ./jpeg/jpeg.cc.orig	Fri Mar  1 02:03:20 1996
--- ./jpeg/jpeg.cc	Thu Jul 15 09:35:25 1999
***************
*** 139,145 ****
  	dct_unbias_ = 1;
  
  	short *sp = (short *)frm_;
! 	for (register i = 0; i < n / (BMB * 64) ; i++) {
  		*sp = DCT_GRAY;
  		sp += 64;
  		*sp = DCT_GRAY;
--- 139,145 ----
  	dct_unbias_ = 1;
  
  	short *sp = (short *)frm_;
! 	for (register long i = 0; i < n / (BMB * 64) ; i++) {
  		*sp = DCT_GRAY;
  		sp += 64;
  		*sp = DCT_GRAY;
***************
*** 173,179 ****
  	dct_unbias_ = 1;
  
  	short *sp = (short*)frm_;
! 	for (register i = 0; i < n / (BMB * 64) ; i++) {
  		*sp = DCT_GRAY;
  		sp += 64;
  		*sp = DCT_GRAY;
--- 173,179 ----
  	dct_unbias_ = 1;
  
  	short *sp = (short*)frm_;
! 	for (register long i = 0; i < n / (BMB * 64) ; i++) {
  		*sp = DCT_GRAY;
  		sp += 64;
  		*sp = DCT_GRAY;
*** ./configure.in.orig	Fri Jun 21 01:36:47 1996
--- ./configure.in	Thu Jul 15 09:35:25 1999
***************
*** 34,40 ****
  
  V_LIB_GRABBER=""
  V_INCLUDE_GRABBER=""
! V_OBJ_GRABBER=""
  V_LIB_XIL=""
  V_OBJ_XIL=""
  
--- 34,40 ----
  
  V_LIB_GRABBER=""
  V_INCLUDE_GRABBER=""
! V_OBJ_GRABBER="grabber-x11.cc"
  V_LIB_XIL=""
  V_OBJ_XIL=""
  
***************
*** 69,75 ****
  if test -r /usr/include/machine/ioctl_meteor.h ; then
  	V_OBJ_GRABBER="$V_OBJ_GRABBER grabber-meteor.o"
  fi
! if test -r /usr/local/lib/libspigot.a ; then
  	V_OBJ_GRABBER="$V_OBJ_GRABBER grabber-spigot.o"
  	V_LIB_GRABBER="$V_LIB_GRABBER -lspigot"
  	V_INCLUDE_GRABBER="$V_INCLUDE_GRABBER -I/usr/local/include"
--- 69,75 ----
  if test -r /usr/include/machine/ioctl_meteor.h ; then
  	V_OBJ_GRABBER="$V_OBJ_GRABBER grabber-meteor.o"
  fi
! if test -r /usr/local/lib/libspigot.a -a ${PORTOBJFORMAT} != elf; then
  	V_OBJ_GRABBER="$V_OBJ_GRABBER grabber-spigot.o"
  	V_LIB_GRABBER="$V_LIB_GRABBER -lspigot"
  	V_INCLUDE_GRABBER="$V_INCLUDE_GRABBER -I/usr/local/include"
***************
*** 87,95 ****
  	V_OBJ_GRABBER="$V_OBJ_GRABBER grabber-qcam.o"
  	V_DEFINE="$V_DEFINE -DQCAMDEV"
  fi
- if test -r /usr/include/linux/scc.h -o -r /usr/include/machine/scc.h ; then
- 	V_OBJ_GRABBER="$V_OBJ_GRABBER grabber-scc.o"
- fi
  vpix_dir=/usr/src/local/vfc-1.0
  vpix_lib=$vpix_dir/vfc_lib
  if test -d /import/VideoPix ; then
--- 87,92 ----
***************
*** 227,232 ****
--- 224,232 ----
  *-*-netbsd*)
  	V_TARCMD="tar -h -c -f"
  	V_LIB="$V_LIB -L/usr/local/lib"
+ 	;;
+ *-*-openbsd*)
+ 	V_STATIC=""
  	;;
  *-*-hpux*)
  	V_CCOPT="-O"
*** ./configure.in.tk.orig	Thu May 16 03:06:05 1996
--- ./configure.in.tk	Thu Jul 15 09:35:25 1999
***************
*** 12,19 ****
  		echo "can't find tcl.h in $d/include"
  		exit 1
  	fi
! 	places="$d/lib/libtcl7.5.so \
! 		$d/lib/libtcl7.5.a \
  		$d/lib/libtcl.so \
  		$d/lib/libtcl.a"
  	V_LIB_TCL=FAIL
--- 12,19 ----
  		echo "can't find tcl.h in $d/include"
  		exit 1
  	fi
! 	places="$d/lib/libtcl8.0.so \
! 		$d/lib/libtcl8.0.a \
  		$d/lib/libtcl.so \
  		$d/lib/libtcl.a"
  	V_LIB_TCL=FAIL
***************
*** 27,33 ****
  		echo "can't find libtcl.a in $d/lib"
  		exit 1
  	fi
! 	places="$d/lib/tcl7.5 \
  		$d/lib/tcl"
  	V_LIBRARY_TCL=FAIL
  	for dir in $places; do
--- 27,33 ----
  		echo "can't find libtcl.a in $d/lib"
  		exit 1
  	fi
! 	places="$d/lib/tcl8.0 \
  		$d/lib/tcl"
  	V_LIBRARY_TCL=FAIL
  	for dir in $places; do
***************
*** 44,56 ****
  	AC_TEST_CPP([#include <tcl.h>], V_INCLUDE_TCL="", V_INCLUDE_TCL=FAIL)
  	if test "$V_INCLUDE_TCL" = FAIL; then
  		echo "checking for tcl.h"
! 		places="$PWD/../tcl7.5 \
! 			/usr/src/local/tcl7.5 \
! 			/import/tcl/include/tcl7.5 \
  			$prefix/include \
  			$x_includes/tk \
  			$x_includes \
  			/usr/local/include \
  			/usr/contrib/include \
  			/usr/include"
  		for dir in $places; do
--- 44,57 ----
  	AC_TEST_CPP([#include <tcl.h>], V_INCLUDE_TCL="", V_INCLUDE_TCL=FAIL)
  	if test "$V_INCLUDE_TCL" = FAIL; then
  		echo "checking for tcl.h"
! 		places="$PWD/../tcl8.0 \
! 			/usr/src/local/tcl8.0 \
! 			/import/tcl/include/tcl8.0 \
  			$prefix/include \
  			$x_includes/tk \
  			$x_includes \
  			/usr/local/include \
+ 			/usr/local/include/tcl8.0 \
  			/usr/contrib/include \
  			/usr/include"
  		for dir in $places; do
***************
*** 64,70 ****
  			exit 1
  		fi
  	fi
! 	AC_CHECK_LIB(tcl7.5, main, V_LIB_TCL="-ltcl7.5", V_LIB_TCL="FAIL")
  	if test "$V_LIB_TCL" = FAIL; then
  		echo "checking for libtcl.a"
  		places="\
--- 65,71 ----
  			exit 1
  		fi
  	fi
! 	AC_CHECK_LIB(tcl8.0, main, V_LIB_TCL="-ltcl8.0", V_LIB_TCL="FAIL")
  	if test "$V_LIB_TCL" = FAIL; then
  		echo "checking for libtcl.a"
  		places="\
***************
*** 73,85 ****
  			/usr/contrib/lib \
  			/usr/local/lib \
  			/usr/lib \
! 			$PWD/../tcl7.5 \
! 			/usr/src/local/tcl7.5 \
! 			/import/tcl/lib/tcl7.5 \
  			"
  		for dir in $places; do
! 			if test -r $dir/libtcl7.5.so -o -r $dir/libtcl7.5.a; then
! 				V_LIB_TCL="-L$dir -ltcl7.5"
  				break
  			fi
  			if test -r $dir/libtcl.so -o -r $dir/libtcl.a; then
--- 74,86 ----
  			/usr/contrib/lib \
  			/usr/local/lib \
  			/usr/lib \
! 			$PWD/../tcl8.0 \
! 			/usr/src/local/tcl8.0 \
! 			/import/tcl/lib/tcl8.0 \
  			"
  		for dir in $places; do
! 			if test -r $dir/libtcl80.so -o -r $dir/libtcl80.a; then
! 				V_LIB_TCL="-L$dir -ltcl80"
  				break
  			fi
  			if test -r $dir/libtcl.so -o -r $dir/libtcl.a; then
***************
*** 98,110 ****
  	fi
  	echo "checking for tcl/init.tcl"
  	V_LIBRARY_TCL=FAIL
! 	places="/usr/local/lib/tcl7.5 \
! 		/usr/contrib/lib/tcl7.5 \
! 		/usr/lib/tcl7.5 \
! 		/usr/lib/tk/tcl7.5 \
! 		/import/tcl/lib/tcl7.5 \
! 		$prefix/lib/tcl7.5 \
! 		$x_libraries/tcl7.5 \
  		/usr/local/lib/tcl \
  		/usr/lib/tcl \
  		/usr/lib/tk/tcl \
--- 99,111 ----
  	fi
  	echo "checking for tcl/init.tcl"
  	V_LIBRARY_TCL=FAIL
! 	places="/usr/local/lib/tcl8.0 \
! 		/usr/contrib/lib/tcl8.0 \
! 		/usr/lib/tcl8.0 \
! 		/usr/lib/tk/tcl8.0 \
! 		/import/tcl/lib/tcl8.0 \
! 		$prefix/lib/tcl8.0 \
! 		$x_libraries/tcl8.0 \
  		/usr/local/lib/tcl \
  		/usr/lib/tcl \
  		/usr/lib/tk/tcl \
***************
*** 138,145 ****
  		echo "can't find tk.h in $d/include"
  		exit 1
  	fi
! 	places="$d/lib/libtk4.1.so \
! 		$d/lib/libtk4.1.a \
  		$d/lib/libtk.so \
  		$d/lib/libtk.a"
  	V_LIB_TK=FAIL
--- 139,146 ----
  		echo "can't find tk.h in $d/include"
  		exit 1
  	fi
! 	places="$d/lib/libtk8.0.so \
! 		$d/lib/libtk8.0.a \
  		$d/lib/libtk.so \
  		$d/lib/libtk.a"
  	V_LIB_TK=FAIL
***************
*** 153,159 ****
  		echo "can't find libtk.a in $d/lib"
  		exit 1
  	fi
! 	places="$d/lib/tk4.1 \
  		$d/lib/tk"
  	V_LIBRARY_TK=FAIL
  	for dir in $places; do
--- 154,160 ----
  		echo "can't find libtk.a in $d/lib"
  		exit 1
  	fi
! 	places="$d/lib/tk8.0 \
  		$d/lib/tk"
  	V_LIBRARY_TK=FAIL
  	for dir in $places; do
***************
*** 170,187 ****
  	AC_TEST_CPP([#include <tk.h>], V_INCLUDE_TK="", V_INCLUDE_TK=FAIL)
  	if test "$V_INCLUDE_TK" = FAIL; then
  		echo "checking for tk.h"
! 		V_INCLUDE_TK=""
  		places="\
  			$prefix/include \
  			/usr/local/include \
  			/usr/contrib/include \
  			/usr/include/tcl \
  			/usr/include\
  			$x_includes/tk \
  			$x_includes \
! 			$PWD/../tk4.1 \
! 			/usr/src/local/tk4.1 \
! 			/import/tcl/include/tk4.1 \
  			"
  		for dir in $places; do
  			if test -r $dir/tk.h ; then
--- 171,189 ----
  	AC_TEST_CPP([#include <tk.h>], V_INCLUDE_TK="", V_INCLUDE_TK=FAIL)
  	if test "$V_INCLUDE_TK" = FAIL; then
  		echo "checking for tk.h"
! 		V_INCLUDE_TK="FAIL"
  		places="\
  			$prefix/include \
  			/usr/local/include \
+ 			/usr/local/include/tk8.0 \
  			/usr/contrib/include \
  			/usr/include/tcl \
  			/usr/include\
  			$x_includes/tk \
  			$x_includes \
! 			$PWD/../tk8.0 \
! 			/usr/src/local/tk8.0 \
! 			/import/tcl/include/tk8.0 \
  			"
  		for dir in $places; do
  			if test -r $dir/tk.h ; then
***************
*** 194,200 ****
  			exit 1
  		fi
  	fi
! 	AC_CHECK_LIB(tk4.1, main, V_LIB_TK="-ltk4.1", V_LIB_TK="FAIL")
  	if test "$V_LIB_TK" = FAIL; then
  		echo "checking for libtk.a"
  		places="/usr/local/lib \
--- 196,202 ----
  			exit 1
  		fi
  	fi
! 	AC_CHECK_LIB(tk8.0, main, V_LIB_TK="-ltk8.0", V_LIB_TK="FAIL")
  	if test "$V_LIB_TK" = FAIL; then
  		echo "checking for libtk.a"
  		places="/usr/local/lib \
***************
*** 202,214 ****
  			/usr/lib \
  			/usr/lib/tk \
  			/import/tcl/lib \
! 			$PWD/../tk4.1 \
! 			/usr/src/local/tk4.1 \
  			$prefix/lib \
  			$x_libraries"
  		for dir in $places; do
! 			if test -r $dir/libtk4.1.so -o -r $dir/libtk4.1.a; then
! 				V_LIB_TK="-L$dir -ltk4.1"
  				break
  			fi
  			if test -r $dir/libtk.so -o -r $dir/libtk.a; then
--- 204,216 ----
  			/usr/lib \
  			/usr/lib/tk \
  			/import/tcl/lib \
! 			$PWD/../tk8.0 \
! 			/usr/src/local/tk8.0 \
  			$prefix/lib \
  			$x_libraries"
  		for dir in $places; do
! 			if test -r $dir/libtk80.so -o -r $dir/libtk80.a; then
! 				V_LIB_TK="-L$dir -ltk80"
  				break
  			fi
  			if test -r $dir/libtk.so -o -r $dir/libtk.a; then
***************
*** 227,241 ****
  	fi
  	echo "checking for tk/tk.tcl"
  	V_LIBRARY_TK=FAIL
! 	places="/usr/local/lib/tk4.1 \
! 		/usr/contrib/lib/tk4.1 \
! 		/usr/lib/tk4.1 \
! 		/usr/lib/tk/tk4.1 \
! 		/import/tcl/lib/tk4.1 \
! 		$prefix/lib/tk4.1 \
! 		$x_libraries/tk4.1 \
! 		$PWD/../tk4.1/library \
! 		/usr/src/local/tk4.1/library \
  		/usr/local/lib/tk \
  		/usr/lib/tk \
  		/usr/lib/tk/tk \
--- 229,243 ----
  	fi
  	echo "checking for tk/tk.tcl"
  	V_LIBRARY_TK=FAIL
! 	places="/usr/local/lib/tk8.0 \
! 		/usr/contrib/lib/tk8.0 \
! 		/usr/lib/tk8.0 \
! 		/usr/lib/tk/tk8.0 \
! 		/import/tcl/lib/tk8.0 \
! 		$prefix/lib/tk8.0 \
! 		$x_libraries/tk8.0 \
! 		$PWD/../tk8.0/library \
! 		/usr/src/local/tk8.0/library \
  		/usr/local/lib/tk \
  		/usr/lib/tk \
  		/usr/lib/tk/tk \
*** ./Makefile.in.orig	Mon Jul 22 11:32:53 1996
--- ./Makefile.in	Thu Jul 15 09:35:25 1999
***************
*** 303,309 ****
  	 chown bin @prefix@/bin/vic
  	 chgrp bin @prefix@/bin/vic
  	 chmod 555 @prefix@/bin/vic
! 	 cp vic.1 @prefix@/man/vic.1
  	 cp histtolut @prefix@/bin/histtolut
  	 chown bin @prefix@/bin/histtolut
  	 chgrp bin @prefix@/bin/histtolut
--- 303,309 ----
  	 chown bin @prefix@/bin/vic
  	 chgrp bin @prefix@/bin/vic
  	 chmod 555 @prefix@/bin/vic
! 	 cp vic.1 @prefix@/man/man1/vic.1
  	 cp histtolut @prefix@/bin/histtolut
  	 chown bin @prefix@/bin/histtolut
  	 chgrp bin @prefix@/bin/histtolut
*** ./grabber-spigot.cc.orig	Sat Jan 13 16:35:28 1996
--- ./grabber-spigot.cc	Thu Jul 15 09:35:25 1999
***************
*** 202,212 ****
  		hstart_ = 1;
  		hstop_ = blkw_ - 1;
  
  		int	voff = (outh_ - inh_) / 2;
- 		hwrap_ = outw_ - inw_ ;
  		int	hoff = hwrap_ / 2;
  		loff_ = outw_ * voff + hoff;
  		coff_ = (outw_ >> 1) * (voff >> 1) + (hoff >> 1);
  		hskip_ = 0;
  		break;
  	case f_411:
--- 202,215 ----
  		hstart_ = 1;
  		hstop_ = blkw_ - 1;
  
+ 		{
  		int	voff = (outh_ - inh_) / 2;
  		int	hoff = hwrap_ / 2;
+ 
+ 		hwrap_ = outw_ - inw_ ;
  		loff_ = outw_ * voff + hoff;
  		coff_ = (outw_ >> 1) * (voff >> 1) + (hoff >> 1);
+ 		}
  		hskip_ = 0;
  		break;
  	case f_411:
*** ./grabber-qcam.cc.orig	Thu Jun 20 23:39:36 1996
--- ./grabber-qcam.cc	Thu Jul 15 09:35:25 1999
***************
*** 84,89 ****
--- 84,94 ----
  #define CIF_HEIGHT 288
  
  /*XXX*/
+ #ifndef QC_MAX_CONTRAST
+ #define	QC_MAX_CONTRAST	255
+ #endif
+ 
+ /*XXX*/
  #define VOLATILE volatile
  
  class QcamGrabber : public Grabber {
*** ./main.cc.orig	Mon Jul 22 15:12:22 1996
--- ./main.cc	Thu Jul 15 09:35:25 1999
***************
*** 177,183 ****
  		else {
  			Tk_Window tk = t.tkmain();
  			Tk_Uid uid = Tk_GetUid((char*)argv[1]);
! 			XFontStruct* p = Tk_GetFontStruct(t.interp(), tk, uid);
  			t.result(p != 0 ? "1" : "0");
  		}
  		return (TCL_OK);
--- 177,183 ----
  		else {
  			Tk_Window tk = t.tkmain();
  			Tk_Uid uid = Tk_GetUid((char*)argv[1]);
! 			Tk_Font p = Tk_GetFont(t.interp(), tk, uid);
  			t.result(p != 0 ? "1" : "0");
  		}
  		return (TCL_OK);
***************
*** 425,430 ****
--- 425,433 ----
  #endif
  	signal(SIGINT, ciao);
  	signal(SIGTERM, ciao);
+ #if defined(__FreeBSD__) || defined(__OpenBSD__)
+ 	signal(SIGSYS, (sig_t)noXShm);
+ #endif
  
  #ifdef WIN32
  	TkSetPlatformInit(TkPlatformInit);
*** ./tkStripchart.c.orig	Sat Mar 16 16:14:00 1996
--- ./tkStripchart.c	Thu Jul 15 09:35:25 1999
***************
*** 148,154 ****
  	int scrollrequired;
  	int guarantee_draw;
  	int grow_up;
! 	XFontStruct *fontPtr;	/* Information about text font, or NULL. */
  	XColor *textColorPtr;	/* Color for drawing text. */
  	GC textGC;		/* GC for drawing text. */
  	XColor *tickColorPtr;	/* Color for drawing ticks. */
--- 148,154 ----
  	int scrollrequired;
  	int guarantee_draw;
  	int grow_up;
! 	Tk_Font tkfont;		/* Information about text font, or NULL. */
  	XColor *textColorPtr;	/* Color for drawing text. */
  	GC textGC;		/* GC for drawing text. */
  	XColor *tickColorPtr;	/* Color for drawing ticks. */
***************
*** 257,263 ****
  	{TK_CONFIG_SYNONYM, "-fg", "stripcolor", 0,
  	 0, 0, 0},
  	{TK_CONFIG_FONT, "-font", "font", "Font",
! 	 DEF_STRIPCHART_FONT, Tk_Offset(Stripchart, fontPtr),
  	 0},
  	{TK_CONFIG_BOOLEAN, "-guaranteedrawing", "guaranteedrawing",
  	 "Guaranteedrawing", DEF_GUARANTEE_DRAW,
--- 257,263 ----
  	{TK_CONFIG_SYNONYM, "-fg", "stripcolor", 0,
  	 0, 0, 0},
  	{TK_CONFIG_FONT, "-font", "font", "Font",
! 	 DEF_STRIPCHART_FONT, Tk_Offset(Stripchart, tkfont),
  	 0},
  	{TK_CONFIG_BOOLEAN, "-guaranteedrawing", "guaranteedrawing",
  	 "Guaranteedrawing", DEF_GUARANTEE_DRAW,
***************
*** 570,577 ****
  	if (StripchartPtr->value != NULL)
  		free(StripchartPtr->value);
  
! 	if (StripchartPtr->fontPtr != NULL)
! 		Tk_FreeFontStruct(StripchartPtr->fontPtr);
  
  	if (StripchartPtr->textColorPtr != NULL)
  		Tk_FreeColor(StripchartPtr->textColorPtr);
--- 570,577 ----
  	if (StripchartPtr->value != NULL)
  		free(StripchartPtr->value);
  
! 	if (StripchartPtr->tkfont != NULL)
! 		Tk_FreeFont(StripchartPtr->tkfont);
  
  	if (StripchartPtr->textColorPtr != NULL)
  		Tk_FreeColor(StripchartPtr->textColorPtr);
***************
*** 631,637 ****
  
  	Tk_SetBackgroundFromBorder(StripchartPtr->tkwin, StripchartPtr->border);
  
! 	gcValues.font = StripchartPtr->fontPtr->fid;
  	gcValues.foreground = StripchartPtr->textColorPtr->pixel;
  	newGC = Tk_GetGC(StripchartPtr->tkwin, GCForeground|GCFont, &gcValues);
  	if (StripchartPtr->textGC != None && StripchartPtr->tkwin) {
--- 631,637 ----
  
  	Tk_SetBackgroundFromBorder(StripchartPtr->tkwin, StripchartPtr->border);
  
! 	gcValues.font = Tk_FontId(StripchartPtr->tkfont);
  	gcValues.foreground = StripchartPtr->textColorPtr->pixel;
  	newGC = Tk_GetGC(StripchartPtr->tkwin, GCForeground|GCFont, &gcValues);
  	if (StripchartPtr->textGC != None && StripchartPtr->tkwin) {
***************
*** 692,699 ****
   {
  	int tt = hasatitle(StripchartPtr);
  	int bd = StripchartPtr->borderWidth;
! 	int lineHeight = StripchartPtr->fontPtr->ascent +
! 	StripchartPtr->fontPtr->descent;
  
  	Tk_GeometryRequest(StripchartPtr->tkwin,
  			   2 * (bd + PADDING) + StripchartPtr->num_strips *
--- 692,702 ----
   {
  	int tt = hasatitle(StripchartPtr);
  	int bd = StripchartPtr->borderWidth;
! 	Tk_FontMetrics fm;
! 	int lineHeight;
! 
! 	Tk_GetFontMetrics(StripchartPtr->tkfont, &fm);
! 	lineHeight = fm.ascent + fm.descent;
  
  	Tk_GeometryRequest(StripchartPtr->tkwin,
  			   2 * (bd + PADDING) + StripchartPtr->num_strips *
***************
*** 726,736 ****
  	/*
  	 * Variable declarations used in the title drawing routines
  	 */
! 	XFontStruct *fp = StripchartPtr->fontPtr;
! 	XCharStruct bbox;
! 	int x, dummy;
! 	int lineHeight = StripchartPtr->fontPtr->ascent +
! 	StripchartPtr->fontPtr->descent;
  
  	StripchartPtr->displaybits &= ~REDRAW_PENDING;
  	if ((StripchartPtr->tkwin == NULL) || !Tk_IsMapped(tkwin))
--- 729,741 ----
  	/*
  	 * Variable declarations used in the title drawing routines
  	 */
! 	Tk_Font tkf = StripchartPtr->tkfont;
! 	int x;
! 	Tk_FontMetrics fm;
! 	int lineHeight;
! 
! 	Tk_GetFontMetrics(tkf, &fm);
! 	lineHeight = fm.ascent + fm.descent;
  
  	StripchartPtr->displaybits &= ~REDRAW_PENDING;
  	if ((StripchartPtr->tkwin == NULL) || !Tk_IsMapped(tkwin))
***************
*** 747,764 ****
  	 * space. Otherwise left justified and clipped on the right.
  	 */
  	if (tt && StripchartPtr->displaybits & DISPLAY_TITLE) {
! 		XTextExtents(fp, StripchartPtr->title,
! 			     strlen(StripchartPtr->title),
! 			     &dummy, &dummy, &dummy, &bbox);
! 		if (bbox.lbearing + bbox.rbearing < Tk_Width(tkwin) - 2 * bd)
! 			x = (Tk_Width(tkwin) - bbox.lbearing - bbox.rbearing)/2;
  		else
  			x = bd + PADDING;
  
  		XClearArea(Tk_Display(tkwin), Tk_WindowId(tkwin), bd, bd,
  		     Tk_Width(tkwin) - 2 * bd, lineHeight + PADDING, False);
  		XDrawString(Tk_Display(tkwin), Tk_WindowId(tkwin),
! 		       StripchartPtr->textGC, x, fp->max_bounds.ascent + bd,
  			StripchartPtr->title, strlen(StripchartPtr->title));
  	}
  	/*
--- 752,768 ----
  	 * space. Otherwise left justified and clipped on the right.
  	 */
  	if (tt && StripchartPtr->displaybits & DISPLAY_TITLE) {
! 		int width = Tk_TextWidth(tkf, StripchartPtr->title,
! 			     strlen(StripchartPtr->title));
! 		if (width < Tk_Width(tkwin) - 2 * bd)
! 			x = (Tk_Width(tkwin) - width)/2;
  		else
  			x = bd + PADDING;
  
  		XClearArea(Tk_Display(tkwin), Tk_WindowId(tkwin), bd, bd,
  		     Tk_Width(tkwin) - 2 * bd, lineHeight + PADDING, False);
  		XDrawString(Tk_Display(tkwin), Tk_WindowId(tkwin),
! 		       StripchartPtr->textGC, x, fm.ascent + bd,	/*XXX no max_bounds */
  			StripchartPtr->title, strlen(StripchartPtr->title));
  	}
  	/*
***************
*** 1057,1063 ****
  DrawStripi(Stripchart* SPtr, int i)
  {
  	Tk_Window tkwin = SPtr->tkwin;
! 	int lineHeight = SPtr->fontPtr->ascent + SPtr->fontPtr->descent;
  	int x = SPtr->borderWidth + PADDING + (i - 1) * SPtr->strip_width;
  	int y = SPtr->borderWidth + PADDING +
  		hasatitle(SPtr) * (lineHeight + PADDING);
--- 1061,1068 ----
  DrawStripi(Stripchart* SPtr, int i)
  {
  	Tk_Window tkwin = SPtr->tkwin;
! 	Tk_FontMetrics fm;
! 	int lineHeight;
  	int x = SPtr->borderWidth + PADDING + (i - 1) * SPtr->strip_width;
  	int y = SPtr->borderWidth + PADDING +
  		hasatitle(SPtr) * (lineHeight + PADDING);
***************
*** 1066,1071 ****
--- 1071,1079 ----
  	double maxv = SPtr->max_value;
  	double minv = SPtr->min_value;
  
+ 	Tk_GetFontMetrics(SPtr->tkfont, &fm);
+ 	lineHeight = fm.ascent + fm.descent;
+ 
  	if (i < 1 || i > SPtr->num_strips)
  		return;
  
***************
*** 1136,1142 ****
  ScrollStrips(Stripchart* SPtr)
  {
  	Tk_Window tkwin = SPtr->tkwin;
! 	int lineHeight = SPtr->fontPtr->ascent + SPtr->fontPtr->descent;
  	int src_x = SPtr->borderWidth + PADDING + SPtr->strip_width;
  	int src_y = SPtr->borderWidth + PADDING +
  		    hasatitle(SPtr) * (lineHeight + PADDING);
--- 1144,1151 ----
  ScrollStrips(Stripchart* SPtr)
  {
  	Tk_Window tkwin = SPtr->tkwin;
! 	Tk_FontMetrics fm;
! 	int lineHeight;
  	int src_x = SPtr->borderWidth + PADDING + SPtr->strip_width;
  	int src_y = SPtr->borderWidth + PADDING +
  		    hasatitle(SPtr) * (lineHeight + PADDING);
***************
*** 1144,1149 ****
--- 1153,1160 ----
  	int dest_y = src_y;
  	int w = (SPtr->num_strips - 1) * SPtr->strip_width;
  	int h = SPtr->max_height;
+ 
+ 	Tk_GetFontMetrics(SPtr->tkfont, &fm);
  
  	XCopyArea(Tk_Display(tkwin), Tk_WindowId(tkwin), Tk_WindowId(tkwin),
  	          Tk_GetGC(tkwin, 0, NULL), src_x, src_y, w, h, dest_x, dest_y);
*** ./grabber-meteor.cc.orig	Sat May 18 13:44:54 1996
--- ./grabber-meteor.cc	Thu Jul 15 09:35:25 1999
***************
*** 43,49 ****
   *	
   */
  
- /*#define FRAME_CNTS /* print frame counts and fps when device stops -- debug */
  #include <stdio.h>
  #include <stdlib.h>
  #include <unistd.h>
--- 43,48 ----
***************
*** 51,66 ****
  #include <sys/types.h>
  #include <sys/ioctl.h>
  #include <sys/mman.h>
- #ifdef FRAME_CNTS
- #include <sys/time.h>
- #endif
  
  #include "grabber.h"
  #include "Tcl.h"
  #include "device-input.h"
  #include "module.h"
  
  #include <machine/ioctl_meteor.h>
  
  /*XXX*/
  #define NTSC_WIDTH 320
--- 50,65 ----
  #include <sys/types.h>
  #include <sys/ioctl.h>
  #include <sys/mman.h>
  
  #include "grabber.h"
+ #include "crdef.h"
  #include "Tcl.h"
  #include "device-input.h"
  #include "module.h"
+ #include "bsd-endian.h"
  
  #include <machine/ioctl_meteor.h>
+ #include <machine/ioctl_bt848.h>
  
  /*XXX*/
  #define NTSC_WIDTH 320
***************
*** 72,133 ****
  
  
  class MeteorGrabber : public Grabber {
!  public:
! 	MeteorGrabber(const char* name, const char* format);
  	virtual ~MeteorGrabber();
  	virtual void start();
  	virtual void stop();
- 	virtual void fps(int);
-  protected:
- 	virtual int command(int argc, const char*const* argv);
- 	virtual int capture();
  	virtual int grab();
  	void format();
! 	void setsize();
  
  	int video_format_;	/* video input format: NTSC or PAL */
  	int dev_;		/* device fd */
  	int port_;		/* video input port */
- 	int coder_format_;	/* 411, 422, or cif */
  	u_int basewidth_;	/* Height of frame to be captured */
  	u_int baseheight_;	/* Width of frame to be captured */
  	u_int decimate_;	/* division of base sizes */
  	volatile u_int* pyuv_;	/* pointer to yuv data */
! #ifdef FRAME_CNTS
! 	struct meteor_counts cnts_;	/* pointer to counters */
! 	double	start_time_;
! #endif
  };
  
! static const int	f_411 = 0;	/* coder_format_s */
! static const int	f_422 = 1;
! static const int	f_cif = 2;
  
  class MeteorDevice : public InputDevice {
!  public:
  	MeteorDevice(const char* nickname, const char* devname, int free);
  	virtual int command(int argc, const char*const* argv);
!  protected:
  	const char* name_;
  };
  
  class MeteorScanner {
!  public:
  	MeteorScanner(const int n);
  };
  static MeteorScanner find_meteor_devices(4);
  
  MeteorScanner::MeteorScanner(const int n)
  {
! 	char*	devname_template  = "/dev/meteor%d";
! 	char*	nickname_template = "Matrox Meteor %d";
  
  	for(int i = 0; i < n; i++) {
! 		char	*devname  = new char[strlen(devname_template)  + 3];
  		char	*nickname = new char[strlen(nickname_template) + 3];
  
  		sprintf(nickname, nickname_template, i + 1);
- 		sprintf(devname, devname_template, i);
  		if(access(devname, R_OK) == 0) {
  			int fd = open(devname, O_RDONLY);
  			if(fd < 0) {
--- 71,148 ----
  
  
  class MeteorGrabber : public Grabber {
!     public:
! 	MeteorGrabber(const char* name);
  	virtual ~MeteorGrabber();
+ 	virtual int command(int argc, const char*const* argv);
+ 	virtual void fps(int);
  	virtual void start();
  	virtual void stop();
  	virtual int grab();
+     protected:
  	void format();
! 	virtual void setsize() = 0;
! 	void suppress(const u_char* in, int istride);
! 	virtual void saveblks(const u_char* in, int istride) = 0;
! 	void set_size_meteor(int w, int h);
  
  	int video_format_;	/* video input format: NTSC or PAL */
  	int dev_;		/* device fd */
  	int port_;		/* video input port */
  	u_int basewidth_;	/* Height of frame to be captured */
  	u_int baseheight_;	/* Width of frame to be captured */
  	u_int decimate_;	/* division of base sizes */
  	volatile u_int* pyuv_;	/* pointer to yuv data */
! 	int tuner_ ;		/* tuner device... */
  };
  
! class Meteor422Grabber : public MeteorGrabber {
!     public:
! 	Meteor422Grabber(const char* name);
!     protected:
! 	void setsize();
! 	void saveblk(const u_char* in, u_char* yp, u_char* up, u_char* vp,
! 		     int stride, int istride);
! 	void saveblks(const u_char* in, int istride);
! };
! 
! class MeteorCIFGrabber : public MeteorGrabber {
!     public:
! 	MeteorCIFGrabber(const char* name);
!     protected:
! 	void setsize();
! 	void saveblk(const u_char* in, u_char* yp, u_char* up, u_char* vp,
! 		     int stride, int istride);
! 	void saveblks(const u_char* in, int istride);
! };
  
  class MeteorDevice : public InputDevice {
!     public:
  	MeteorDevice(const char* nickname, const char* devname, int free);
  	virtual int command(int argc, const char*const* argv);
!     protected:
  	const char* name_;
  };
  
  class MeteorScanner {
!     public:
  	MeteorScanner(const int n);
  };
+ 
  static MeteorScanner find_meteor_devices(4);
  
  MeteorScanner::MeteorScanner(const int n)
  {
!     static char *d[] = { "/dev/bktr%d", "/dev/meteor%d", NULL };
!     char *nickname_template = "meteor-%d";
  
  	for(int i = 0; i < n; i++) {
! 	for (int j = 0 ; d[j] != NULL ; j++) {
! 	    char *devname  = new char[strlen(d[j]) + 3];
  		char	*nickname = new char[strlen(nickname_template) + 3];
  
+ 	    sprintf(devname, d[j], i);
  		sprintf(nickname, nickname_template, i + 1);
  		if(access(devname, R_OK) == 0) {
  			int fd = open(devname, O_RDONLY);
  			if(fd < 0) {
***************
*** 140,147 ****
  			delete nickname;
  			delete devname;
  		}
  	}
- }
  
  MeteorDevice::MeteorDevice(const char* nickname, const char *devname, int free):
  					InputDevice(nickname), name_(devname)
--- 155,163 ----
  			delete nickname;
  			delete devname;
  		}
+ 			}
+ 		}
  	}
  
  MeteorDevice::MeteorDevice(const char* nickname, const char *devname, int free):
  					InputDevice(nickname), name_(devname)
***************
*** 149,154 ****
--- 165,171 ----
  	if(free)
  		attributes_ = "\
  format {422 411} \
+ type {pal ntsc secam auto} \
  size {large normal small cif} \
  port {RCA Port-1 Port-2 Port-3 S-Video RGB}";
  	else
***************
*** 160,166 ****
  	Tcl& tcl = Tcl::instance();
  	if ((argc == 3) && (strcmp(argv[1], "open") == 0)) {
  		TclObject* o = 0;
! 		o = new MeteorGrabber(name_, argv[2]);
  		if (o != 0)
  			tcl.result(o->name());
  		return (TCL_OK);
--- 177,186 ----
  	Tcl& tcl = Tcl::instance();
  	if ((argc == 3) && (strcmp(argv[1], "open") == 0)) {
  		TclObject* o = 0;
! 		if (strcmp(argv[2], "422") == 0)
! 			o = new Meteor422Grabber(name_);
! 		else if (strcmp(argv[2], "cif") == 0)
! 			o = new MeteorCIFGrabber(name_);
  		if (o != 0)
  			tcl.result(o->name());
  		return (TCL_OK);
***************
*** 168,186 ****
  	return (InputDevice::command(argc, argv));
  }
  
! MeteorGrabber::MeteorGrabber(const char* name, const char* format)
  {
! 	coder_format_ = -1;
! 	if(!strcmp(format, "411")) coder_format_ = f_411;
! 	if(!strcmp(format, "422")) coder_format_ = f_422;
! 	if(!strcmp(format, "cif")) coder_format_ = f_cif;
! 	if(coder_format_ == -1) {
! 		fprintf(stderr,
! 			"vic: MeteorGrabber: unsupported format: %s\n",
! 			format);
! 		abort();
! 	}
! 
  	dev_ = open(name, O_RDONLY);
  	if (dev_ == -1) {
  		status_ = -1;
--- 188,202 ----
  	return (InputDevice::command(argc, argv));
  }
  
! MeteorGrabber::MeteorGrabber(const char* name)
  {
! 	int devnum;
! 	if (sscanf(name, "/dev/bktr%d", &devnum) == 1) {
! 		char *tunerdev  = new char[strlen(name) + 3];
! 		sprintf(tunerdev, "/dev/tuner%d", devnum);
! 		tuner_ = open(tunerdev, O_RDONLY);
! 	} else
! 		tuner_ = -1;
  	dev_ = open(name, O_RDONLY);
  	if (dev_ == -1) {
  		status_ = -1;
***************
*** 203,254 ****
  	if (dev_ != -1) {
  		close(dev_);
  	}
  }
  
! void MeteorGrabber::setsize()
  {
  	struct meteor_geomet geom;
  
! 	geom.rows = (baseheight_ / decimate_) &~0xf;	/* 0xf, ugh! */
! 	geom.columns = (basewidth_ / decimate_)  &~0xf;
  	geom.frames = 1;
! 	geom.oformat = METEOR_GEO_UNSIGNED;
! 	geom.oformat |= METEOR_GEO_YUV_422;
  	/*
  	 * If we can get by with only reading even fields, then by all
  	 * means do so.
  	 */
  	unsigned short status;
! 	ioctl(dev_, METEORSTATUS, &status);
! 	if(status & METEOR_STATUS_HCLK) {	/* do we have a source? */
! 						/* No source, assume ntsc*/
  		if(geom.rows <= NTSC_HEIGHT && geom.columns <= NTSC_WIDTH)
  			geom.oformat |= METEOR_GEO_EVEN_ONLY;
  	} else {
- 		if(status & METEOR_STATUS_FIDT) { /* is it pal or ntsc? */
- 						/* 60 hz */
- 			if(geom.rows<=NTSC_HEIGHT && geom.columns<=NTSC_WIDTH)
- 				geom.oformat |= METEOR_GEO_EVEN_ONLY;
- 		} else {			/* 50 hz */
  			if(geom.rows<=PAL_HEIGHT && geom.columns<=PAL_WIDTH)
  				geom.oformat |= METEOR_GEO_EVEN_ONLY;
  		}
- 	}
- 
  	if(ioctl(dev_, METEORSETGEO, &geom) < 0) 
  		perror("vic: METERSETGEO: ");
- 
- 	switch(coder_format_) {
- 	case f_422:
- 		set_size_422(geom.columns, geom.rows);
- 		break;
- 	case f_cif:
- 	case f_411:
- 		set_size_411(geom.columns, geom.rows);
- 		break;
- 	}
- 
- 	allocref();	/* allocate reference frame */
  }
  
  void MeteorGrabber::format()
--- 219,251 ----
  	if (dev_ != -1) {
  		close(dev_);
  	}
+ 	if (tuner_ != -1)
+ 		close(tuner_);
  }
  
! void MeteorGrabber::set_size_meteor(int w, int h)
  {
  	struct meteor_geomet geom;
  
! 	geom.rows = h &~0xf;	/* 0xf, ugh! */
! 	geom.columns = w  &~0xf;
  	geom.frames = 1;
! 	geom.oformat = METEOR_GEO_UNSIGNED | METEOR_GEO_YUV_PACKED;
  	/*
  	 * If we can get by with only reading even fields, then by all
  	 * means do so.
  	 */
  	unsigned short status;
! 	// ioctl(dev_, METEORSTATUS, &status);
! 	if ( video_format_ == METEOR_FMT_NTSC ) {
  		if(geom.rows <= NTSC_HEIGHT && geom.columns <= NTSC_WIDTH)
  			geom.oformat |= METEOR_GEO_EVEN_ONLY;
  	} else {
  			if(geom.rows<=PAL_HEIGHT && geom.columns<=PAL_WIDTH)
  				geom.oformat |= METEOR_GEO_EVEN_ONLY;
  		}
  	if(ioctl(dev_, METEORSETGEO, &geom) < 0) 
  		perror("vic: METERSETGEO: ");
  }
  
  void MeteorGrabber::format()
***************
*** 285,295 ****
  		baseheight_ = PAL_HEIGHT * 2;
  		basewidth_ = PAL_WIDTH * 2;
  	}
- 		
- 	if(coder_format_ == f_cif) {
- 		baseheight_ = CIF_HEIGHT * 2;
- 		basewidth_ = CIF_WIDTH * 2;
- 	}
  	setsize();
  }
  
--- 282,287 ----
***************
*** 299,313 ****
  	format();
  	int cmd = METEOR_CAP_SINGLE;
  	ioctl(dev_, METEORCAPTUR, (char*)&cmd);
- #ifdef FRAME_CNTS
- 	cnts_.fifo_errors = 0;
- 	cnts_.dma_errors = 0;
- 	cnts_.frames_captured = 0;
- 	cnts_.even_fields_captured = 0;
- 	cnts_.odd_fields_captured = 0;
- 	ioctl(dev_, METEORSCOUNT, &cnts_);
- 	start_time_ = gettimeofday();
- #endif
  
  	cmd = METEOR_CAP_CONTINOUS;
  	ioctl(dev_, METEORCAPTUR, (char*)&cmd);
--- 291,296 ----
***************
*** 319,337 ****
  
  	int cmd = METEOR_CAP_STOP_CONT;
  	ioctl(dev_, METEORCAPTUR, (char*)&cmd);
- #ifdef FRAME_CNTS
- 	double endtime = gettimeofday() ;
- 	ioctl(dev_, METEORGCOUNT, &cnts_);
- 	int diff = (int)((endtime-start_time_) * 1e-6 + 0.5);
- 	printf("frames = %d, even fields = %d, odd fields = %d,\n\
- fifo errors = %d, dma errors = %d, seconds = %d",
- 		cnts_.frames_captured, cnts_.even_fields_captured,
- 		cnts_.odd_fields_captured, cnts_.fifo_errors, cnts_.dma_errors,
- 		diff);
- 	if(diff)
- 		printf(",fps = %d", cnts_.frames_captured/diff);
- 	printf("\n");
- #endif
  	Grabber::stop();
  }
  
--- 302,307 ----
***************
*** 345,359 ****
  
  int MeteorGrabber::command(int argc, const char*const* argv)
  {
  	if (argc == 3) {
  		if (strcmp(argv[1], "decimate") == 0) {
  			int dec = atoi(argv[2]);
- 			Tcl& tcl = Tcl::instance();
  			if (dec <= 0) {
  				tcl.resultf("%s: divide by zero", argv[0]);
  				return (TCL_ERROR);
  			}
! 			if (dec != decimate_) {
  				decimate_ = dec;
  				if(running_) {
  					stop();
--- 315,329 ----
  
  int MeteorGrabber::command(int argc, const char*const* argv)
  {
+ 	Tcl& tcl = Tcl::instance();
  	if (argc == 3) {
  		if (strcmp(argv[1], "decimate") == 0) {
  			int dec = atoi(argv[2]);
  			if (dec <= 0) {
  				tcl.resultf("%s: divide by zero", argv[0]);
  				return (TCL_ERROR);
  			}
! 			if ((u_int)dec != decimate_) {
  				decimate_ = dec;
  				if(running_) {
  					stop();
***************
*** 362,368 ****
  				}
  			}
  			return (TCL_OK);	
! 		} else if (strcmp(argv[1], "port") == 0) {
  			int p = port_;
                          if(!strcmp(argv[2], "RCA")) p = METEOR_INPUT_DEV0;
                          if(!strcmp(argv[2], "Port-1")) p = METEOR_INPUT_DEV1;
--- 332,339 ----
  				}
  			}
  			return (TCL_OK);	
! 		}
! 		if (strcmp(argv[1], "port") == 0) {
  			int p = port_;
                          if(!strcmp(argv[2], "RCA")) p = METEOR_INPUT_DEV0;
                          if(!strcmp(argv[2], "Port-1")) p = METEOR_INPUT_DEV1;
***************
*** 377,383 ****
  				ioctl(dev_, METEORSINPUT, &port_);
  			}
  			return (TCL_OK);	
! 		} else if (strcmp(argv[1], "format") == 0 ||
  			   strcmp(argv[1], "type") == 0) {
  			if (strcmp(argv[2], "auto") == 0)
  				video_format_ = METEOR_FMT_AUTOMODE;
--- 348,377 ----
  				ioctl(dev_, METEORSINPUT, &port_);
  			}
  			return (TCL_OK);	
! 		}
! 		if (strcmp(argv[1], "freeze") == 0) {
! 			int cmd = METEOR_CAP_CONTINOUS ;
! 			if ( atoi(argv[2]) != 0 )
! 			    cmd = METEOR_CAP_STOP_CONT;
! 			ioctl(dev_, METEORCAPTUR, (char*)&cmd);
! 			return (TCL_OK);
! 		}
! 		if (strcmp(argv[1], "chan") == 0) {
! 			int p = port_;
! 			int c = atoi(argv[2]);
! 			if (c > 0 && c < 199)
! 			    p = METEOR_INPUT_DEV1 ;
! 			else
! 			    p = METEOR_INPUT_DEV0 ;
! 			if (p != port_) {
! 				port_ = p;
! 				ioctl(dev_, METEORSINPUT, &port_);
! 			}
! 			if (p == METEOR_INPUT_DEV1)
! 			    ioctl(tuner_, TVTUNER_SETCHNL, &c);
! 			return (TCL_OK);	
! 		}
! 		if (strcmp(argv[1], "format") == 0 ||
  			   strcmp(argv[1], "type") == 0) {
  			if (strcmp(argv[2], "auto") == 0)
  				video_format_ = METEOR_FMT_AUTOMODE;
***************
*** 390,403 ****
  			if (running_)
  				format();
  			return (TCL_OK);	
! 		} else if (strcmp(argv[1], "contrast") == 0) {
! 			contrast(atof(argv[2]));
! 			return (TCL_OK);	
  		}
  	} else if (argc == 2) {
  		if (strcmp(argv[1], "format") == 0 ||
  			   strcmp(argv[1], "type") == 0) {
- 			Tcl& tcl = Tcl::instance();
  			switch (video_format_) {
  
  			case METEOR_FMT_AUTOMODE:
--- 384,418 ----
  			if (running_)
  				format();
  			return (TCL_OK);	
! 		}
! 		if (strcmp(argv[1], "brightness") == 0) {
! 			u_char val = atoi(argv[2]);
! 			ioctl(dev_, METEORSBRIG, &val);
! 			return (TCL_OK);
! 		}
! 		if (strcmp(argv[1], "contrast") == 0) {
! 			u_char val = atoi(argv[2]);
! 			ioctl(dev_, METEORSCONT, &val);
! 			return (TCL_OK);
! 		}
! 		if (strcmp(argv[1], "hue") == 0) {
! 			char val = atoi(argv[2]);
! 			ioctl(dev_, METEORSHUE, &val);
! 			return (TCL_OK);
! 		}
! 		if (strcmp(argv[1], "saturation") == 0) {
! 			u_char val = atoi(argv[2]);
! 			ioctl(dev_, METEORSCSAT, &val);
! 			return (TCL_OK);
! 		}
! 		if (strcmp(argv[1], "uvgain") == 0) {
! 			u_char val = atoi(argv[2]);
! 			ioctl(dev_, METEORSCHCV, &val);
! 			return (TCL_OK);
  		}
  	} else if (argc == 2) {
  		if (strcmp(argv[1], "format") == 0 ||
  			   strcmp(argv[1], "type") == 0) {
  			switch (video_format_) {
  
  			case METEOR_FMT_AUTOMODE:
***************
*** 423,476 ****
  			return (TCL_OK);
  			
  		}
  	}
  	return (Grabber::command(argc, argv));
  }
  
! int MeteorGrabber::capture()
! {
! 	if(pyuv_ == 0) return 0;
! 
! 	volatile u_int* py   = pyuv_;
! 	volatile u_int* pu   = (u_int *)((u_int)py + (u_int)framesize_);
! 	volatile u_int* pv   = (u_int *)((u_int)pu + (framesize_ >> 1));
! 	u_int* 		lum  = (u_int *)frame_;
! 	u_int*		uoff = (u_int *)((u_int)lum + (u_int)framesize_);
! 	int		f422 = coder_format_ == f_422;
! 	u_int*	 	voff = (u_int *)((u_int)uoff + 
! 					 (u_int)(framesize_>>(f422?1:2)));
! 	int 		numc = ((basewidth_/decimate_) &~0xf) >> 3;
! 
! 	for (int row = 0; row < (((baseheight_/decimate_)&~0xf) >> 1); row++) {
! 		for(int col = 0; col < numc; col++) {
! 			*lum++ = *py++;
! 			*lum++ = *py++;
! 			*uoff++ = *pu++;
! 			*voff++ = *pv++;
! 		}
! 		for(col = 0; col < numc; col++) {   
!                         *lum++ = *py++;
!                         *lum++ = *py++;
!                         if(f422) {	/* only copy odd in 4:2:2 format */
!                                 *uoff++ = *pu++; 
!                                	*voff++ = *pv++;
! 			
!                         }
!                 }
!                 if(!f422) {	/* skip odd if 4:1:1 or cif format */
! 			pu += numc;
! 			pv += numc;
! 		}
! 	}
! 	return 1;
  }
  
  int MeteorGrabber::grab()
  {
! 	if (capture() == 0)
! 		return (0);
! 	suppress(frame_);
! 	saveblks(frame_);
! 	YuvFrame f(media_ts(), frame_, crvec_, outw_, outh_);
  	return (target_->consume(&f));
  }
--- 438,753 ----
  			return (TCL_OK);
  			
  		}
+ 		if (strcmp(argv[1], "brightness") == 0) {
+ 			u_char val;
+ 			ioctl(dev_, METEORGBRIG, &val);
+ 			tcl.resultf("%d", (unsigned int)val);
+ 			return (TCL_OK);
+ 		}
+ 		if (strcmp(argv[1], "contrast") == 0) {
+ 			u_char val;
+ 			ioctl(dev_, METEORGCONT, &val);
+ 			tcl.resultf("%d", (int)val);
+ 			return (TCL_OK);
+ 		}
+ 		if (strcmp(argv[1], "hue") == 0) {
+ 			char val;
+ 			ioctl(dev_, METEORGHUE, &val);
+ 			tcl.resultf("%d", (int)val);
+ 			return (TCL_OK);
+ 		}
+ 		if (strcmp(argv[1], "saturation") == 0) {
+ 			u_char val;
+ 			ioctl(dev_, METEORGCSAT, &val);
+ 			tcl.resultf("%d", (int)val);
+ 			return (TCL_OK);
+ 		}
+ 		if (strcmp(argv[1], "uvgain") == 0) {
+ 			u_char val;
+ 			ioctl(dev_, METEORGCHCV, &val);
+ 			tcl.resultf("%d", (int)val);
+ 			return (TCL_OK);
+ 		}
  	}
  	return (Grabber::command(argc, argv));
  }
  
! #define U 0
! #define Y0 1
! #define V 2
! #define Y1 3
! 
! /*
!  * define these for REPLENISH macro used below
!  */
! #define DIFF4(in, frm, v) \
! 	v += (in)[Y0] - (frm)[0]; \
! 	v += (in)[Y1] - (frm)[1]; \
! 	v += (in)[Y0+4] - (frm)[2]; \
! 	v += (in)[Y1+4] - (frm)[3];
! 
! #define DIFFLINE(in, frm, left, center, right) \
! 	DIFF4(in + 0*8, frm + 0*4, left); \
! 	DIFF4(in + 1*8, frm + 1*4, center); \
! 	DIFF4(in + 2*8, frm + 2*4, center); \
! 	DIFF4(in + 3*8, frm + 3*4, right); \
! 	if (right < 0) \
! 		right = -right; \
! 	if (left < 0) \
! 		left = -left; \
! 	if (center < 0) \
! 		center = -center;
! 
! void MeteorGrabber::suppress(const u_char* devbuf, int is)
! {
! 	const u_char* start = frame_ + 16 * vstart_ * outw_ + 16 * hstart_;
! 	REPLENISH(devbuf, start, is, 2,
! 		  hstart_, hstop_, vstart_, vstop_);
  }
  
  int MeteorGrabber::grab()
  {
! 	if (pyuv_ == 0)
! 		return 0;
! 
! 	int istride = inw_ * 2;
! 	suppress((u_char*)pyuv_, istride);
! 	saveblks((u_char*)pyuv_, istride);
! 	u_int32_t ts = media_ts();
! 	YuvFrame f(ts, frame_, crvec_, outw_, outh_);
  	return (target_->consume(&f));
+ }
+ 
+ Meteor422Grabber::Meteor422Grabber(const char* name)
+ 	: MeteorGrabber(name)
+ {
+ }
+ 
+ MeteorCIFGrabber::MeteorCIFGrabber(const char* name)
+ 	: MeteorGrabber(name)
+ {
+ }
+ 
+ void Meteor422Grabber::setsize()
+ {
+ 	int w = basewidth_ / decimate_;
+ 	int h = baseheight_ / decimate_;
+ 	set_size_meteor(w, h);
+ 	set_size_422(w, h);
+ }
+ 
+ inline void 
+ Meteor422Grabber::saveblk(const u_char* in,
+ 	u_char* yp, u_char* up, u_char* vp, int stride, int istride)
+ {
+ 	for (int i = 16; --i >= 0; ) {
+ 		/*
+ 		 * Each iteration of this loop grabs 16 Ys & 8 U/Vs.
+ 		 */
+ 		register u_int y0, y1, u, v;
+ 
+ 		u  = in[U + 0*4] << SHIFT(24) |
+ 		     in[U + 1*4] << SHIFT(16) |
+ 		     in[U + 2*4] << SHIFT(8) |
+ 		     in[U + 3*4] << SHIFT(0);
+ 		v  = in[V + 0*4] << SHIFT(24) |
+ 		     in[V + 1*4] << SHIFT(16) |
+ 		     in[V + 2*4] << SHIFT(8) |
+ 		     in[V + 3*4] << SHIFT(0);
+ 		y0 = in[Y0 + 0*4] << SHIFT(24) |
+ 		     in[Y1 + 0*4] << SHIFT(16) |
+ 		     in[Y0 + 1*4] << SHIFT(8) |
+ 		     in[Y1 + 1*4] << SHIFT(0);
+ 		y1 = in[Y0 + 2*4] << SHIFT(24) |
+ 		     in[Y1 + 2*4] << SHIFT(16) |
+ 		     in[Y0 + 3*4] << SHIFT(8) |
+ 		     in[Y1 + 3*4] << SHIFT(0);
+ 
+ 		((u_int*)yp)[0] = y0;
+ 		((u_int*)yp)[1] = y1;
+ 		((u_int*)up)[0] = u;
+ 		((u_int*)vp)[0] = v;
+ 
+ 		u  = in[U + 4*4] << SHIFT(24) |
+ 		     in[U + 5*4] << SHIFT(16) |
+ 		     in[U + 6*4] << SHIFT(8) |
+ 		     in[U + 7*4] << SHIFT(0);
+ 		v  = in[V + 4*4] << SHIFT(24) |
+ 		     in[V + 5*4] << SHIFT(16) |
+ 		     in[V + 6*4] << SHIFT(8) |
+ 		     in[V + 7*4] << SHIFT(0);
+ 		y0 = in[Y0 + 4*4] << SHIFT(24) |
+ 		     in[Y1 + 4*4] << SHIFT(16) |
+ 		     in[Y0 + 5*4] << SHIFT(8) |
+ 		     in[Y1 + 5*4] << SHIFT(0);
+ 		y1 = in[Y0 + 6*4] << SHIFT(24) |
+ 		     in[Y1 + 6*4] << SHIFT(16) |
+ 		     in[Y0 + 7*4] << SHIFT(8) |
+ 		     in[Y1 + 7*4] << SHIFT(0);
+ 
+ 		((u_int*)yp)[2] = y0;
+ 		((u_int*)yp)[3] = y1;
+ 		((u_int*)up)[1] = u;
+ 		((u_int*)vp)[1] = v;
+ 
+ 		in += istride;
+ 		yp += stride;
+ 		up += stride >> 1;
+ 		vp += stride >> 1;
+ 	}
+ }
+ 
+ void Meteor422Grabber::saveblks(const u_char* devbuf, int is)
+ {
+ 	u_char* crv = crvec_;
+ 	int off = framesize_;
+ 	u_char* lum = frame_;
+ 	u_char* chm = lum + off;
+ 	off >>= 1;
+ 	int stride = 15 * outw_;
+ 	int istride = is * 15;
+ 	for (int y = 0; y < blkh_; ++y) {
+ 		for (int x = 0; x < blkw_; ++x) {
+ 			int s = *crv++;
+ 			if ((s & CR_SEND) != 0)
+ 				saveblk(devbuf, lum, chm, chm + off, outw_, is);
+ 
+ 			devbuf += 32;
+ 			lum += 16;
+ 			chm += 8;
+ 		}
+ 		lum += stride;
+ 		chm += stride >> 1;
+ 		devbuf += istride;
+ 	}
+ }
+ 
+ void MeteorCIFGrabber::setsize()
+ {
+ 	int w = basewidth_ / decimate_;
+ 	int h = baseheight_ / decimate_;
+ 	set_size_meteor(w, h);
+ 	set_size_cif(w, h);
+ }
+ 
+ inline void 
+ MeteorCIFGrabber::saveblk(const u_char* in,
+ 	u_char* yp, u_char* up, u_char* vp, int stride, int istride)
+ {
+ 	for (int i = 8; --i >= 0; ) {
+ 		/*
+ 		 * Each iteration of this loop grabs 32 Ys & 16 U/Vs.
+ 		 */
+ 		register u_int y0, y1, u, v;
+ 
+ 		u  = in[U + 0*4] << SHIFT(24) |
+ 		     in[U + 1*4] << SHIFT(16) |
+ 		     in[U + 2*4] << SHIFT(8) |
+ 		     in[U + 3*4] << SHIFT(0);
+ 		v  = in[V + 0*4] << SHIFT(24) |
+ 		     in[V + 1*4] << SHIFT(16) |
+ 		     in[V + 2*4] << SHIFT(8) |
+ 		     in[V + 3*4] << SHIFT(0);
+ 		y0 = in[Y0 + 0*4] << SHIFT(24) |
+ 		     in[Y1 + 0*4] << SHIFT(16) |
+ 		     in[Y0 + 1*4] << SHIFT(8) |
+ 		     in[Y1 + 1*4] << SHIFT(0);
+ 		y1 = in[Y0 + 2*4] << SHIFT(24) |
+ 		     in[Y1 + 2*4] << SHIFT(16) |
+ 		     in[Y0 + 3*4] << SHIFT(8) |
+ 		     in[Y1 + 3*4] << SHIFT(0);
+ 
+ 		((u_int*)yp)[0] = y0;
+ 		((u_int*)yp)[1] = y1;
+ 		((u_int*)up)[0] = u;
+ 		((u_int*)vp)[0] = v;
+ 
+ 		u  = in[U + 4*4] << SHIFT(24) |
+ 		     in[U + 5*4] << SHIFT(16) |
+ 		     in[U + 6*4] << SHIFT(8) |
+ 		     in[U + 7*4] << SHIFT(0);
+ 		v  = in[V + 4*4] << SHIFT(24) |
+ 		     in[V + 5*4] << SHIFT(16) |
+ 		     in[V + 6*4] << SHIFT(8) |
+ 		     in[V + 7*4] << SHIFT(0);
+ 		y0 = in[Y0 + 4*4] << SHIFT(24) |
+ 		     in[Y1 + 4*4] << SHIFT(16) |
+ 		     in[Y0 + 5*4] << SHIFT(8) |
+ 		     in[Y1 + 5*4] << SHIFT(0);
+ 		y1 = in[Y0 + 6*4] << SHIFT(24) |
+ 		     in[Y1 + 6*4] << SHIFT(16) |
+ 		     in[Y0 + 7*4] << SHIFT(8) |
+ 		     in[Y1 + 7*4] << SHIFT(0);
+ 
+ 		((u_int*)yp)[2] = y0;
+ 		((u_int*)yp)[3] = y1;
+ 		((u_int*)up)[1] = u;
+ 		((u_int*)vp)[1] = v;
+ 
+ 		in += istride;
+ 		yp += stride;
+ 		up += stride >> 1;
+ 		vp += stride >> 1;
+ 
+ 		/* do the 2nd (y only instead of yuv) line */
+ 
+ 		y0 = in[Y0 + 0*4] << SHIFT(24) |
+ 		     in[Y1 + 0*4] << SHIFT(16) |
+ 		     in[Y0 + 1*4] << SHIFT(8) |
+ 		     in[Y1 + 1*4] << SHIFT(0);
+ 		y1 = in[Y0 + 2*4] << SHIFT(24) |
+ 		     in[Y1 + 2*4] << SHIFT(16) |
+ 		     in[Y0 + 3*4] << SHIFT(8) |
+ 		     in[Y1 + 3*4] << SHIFT(0);
+ 
+ 		((u_int*)yp)[0] = y0;
+ 		((u_int*)yp)[1] = y1;
+ 
+ 		y0 = in[Y0 + 4*4] << SHIFT(24) |
+ 		     in[Y1 + 4*4] << SHIFT(16) |
+ 		     in[Y0 + 5*4] << SHIFT(8) |
+ 		     in[Y1 + 5*4] << SHIFT(0);
+ 		y1 = in[Y0 + 6*4] << SHIFT(24) |
+ 		     in[Y1 + 6*4] << SHIFT(16) |
+ 		     in[Y0 + 7*4] << SHIFT(8) |
+ 		     in[Y1 + 7*4] << SHIFT(0);
+ 
+ 		((u_int*)yp)[2] = y0;
+ 		((u_int*)yp)[3] = y1;
+ 
+ 		in += istride;
+ 		yp += stride;
+ 	}
+ }
+ 
+ void MeteorCIFGrabber::saveblks(const u_char* in, int is)
+ {
+ 	u_char* crv = crvec_;
+ 	int off = framesize_;
+ 	u_char* lum = frame_;
+ 	u_char* chm = lum + off;
+ 	off >>= 2;
+ 
+ 	crv += vstart_ * blkw_ + hstart_;
+ 	lum += vstart_ * outw_ * 16 + hstart_ * 16;
+ 	chm += vstart_ * (outw_ >> 1) * 8 + hstart_ * 8;
+ 
+ 	int skip = hstart_ + (blkw_ - hstop_);
+ 
+ 	for (int y = vstart_; y < vstop_; ++y) {
+ 		const u_char* nin = in;
+ 		for (int x = hstart_; x < hstop_; ++x) {
+ 			int s = *crv++;
+ 			if ((s & CR_SEND) != 0)
+ 				saveblk(in, lum, chm, chm + off, outw_, is);
+ 
+ 			in += 32;
+ 			lum += 16;
+ 			chm += 8;
+ 		}
+ 		crv += skip;
+ 		lum += 15 * outw_ + skip * 16;
+ 		chm += 7 * (outw_ >> 1) + skip * 8;
+ 		in = nin + 16 * is;
+ 	}
  }
*** ./vw.cc.orig	Mon Jul 22 15:12:31 1996
--- ./vw.cc	Thu Jul 15 09:35:25 1999
***************
*** 248,255 ****
  	/*
  	 * Wrap segment in an ximage
  	 */
- 	image_ = XCreateImage(dpy_, Tk_Visual(tk), Tk_Depth(tk), ZPixmap,
- 			      0, (char*)0, width_, height_, 8, 0);
  	image_->obdata = (char*)&shminfo_;
  	image_->data = shminfo_.shmaddr;
  }
--- 248,253 ----
*** ./Tcl.h.orig	Sat Mar 16 16:14:34 1996
--- ./Tcl.h	Thu Jul 15 09:35:25 1999
***************
*** 53,59 ****
  	inline int dark() const { return (tcl_ == 0); }
  	inline Tcl_Interp* interp() const { return (tcl_); }
  	inline char* result() const { return (tcl_->result); }
! 	inline void result(const char* p) { tcl_->result = (char*)p; }
  	void resultf(const char* fmt, ...);
  	inline void CreateCommand(const char* cmd, Tcl_CmdProc* cproc,
  				  ClientData cd = 0,
--- 53,60 ----
  	inline int dark() const { return (tcl_ == 0); }
  	inline Tcl_Interp* interp() const { return (tcl_); }
  	inline char* result() const { return (tcl_->result); }
! 	inline void result(const char* p, Tcl_FreeProc* freeProc = TCL_STATIC)
! 	    { Tcl_SetResult(tcl_, (char *)p, freeProc); }
  	void resultf(const char* fmt, ...);
  	inline void CreateCommand(const char* cmd, Tcl_CmdProc* cproc,
  				  ClientData cd = 0,
*** ./source.cc.orig	Thu Apr  4 10:05:45 1996
--- ./source.cc	Thu Jul 15 09:35:25 1999
***************
*** 251,258 ****
  			return (TCL_OK);
  		}
  		if (strcmp(argv[1], "addr") == 0) {
! 			strcpy(wrk, InetNtoa(addr_));
! 			tcl.result(wrk);
  			return (TCL_OK);
  		}
  		if (strcmp(argv[1], "srcid") == 0) {
--- 251,257 ----
  			return (TCL_OK);
  		}
  		if (strcmp(argv[1], "addr") == 0) {
! 			tcl.result(InetNtoa(addr_), TCL_DYNAMIC);
  			return (TCL_OK);
  		}
  		if (strcmp(argv[1], "srcid") == 0) {
*** ./Tcl.cc.orig	Tue Apr  2 23:53:27 1996
--- ./Tcl.cc	Thu Jul 15 09:35:25 1999
***************
*** 65,70 ****
--- 65,71 ----
  {
  	instance_.tcl_ = tcl;
  	instance_.application_ = application;
+ 	Tcl_Init(tcl);
  }
  
  void Tcl::evalc(const char* s)
***************
*** 162,167 ****
--- 163,170 ----
  	Tcl& tcl = Tcl::instance();
  	if (!tcl.dark())
  		tcl.DeleteCommand(name_);
+ 	if (name_ != 0)
+ 		delete name_;
  	TclObject** p;
  	for (p = &all_; *p != this; p = &(*p)->next_)
  		;
***************
*** 197,204 ****
  void TclObject::setproc(const char* s)
  {
  	Tcl& tcl = Tcl::instance();
! 	if (name_ != 0 && !tcl.dark()) {
! 		tcl.DeleteCommand(name_);
  		delete name_;
  	}
  	int n = strlen(s);
--- 200,208 ----
  void TclObject::setproc(const char* s)
  {
  	Tcl& tcl = Tcl::instance();
! 	if (name_ != 0) {
! 		if (!tcl.dark())
! 			tcl.DeleteCommand(name_);
  		delete name_;
  	}
  	int n = strlen(s);
*** ./decoder.cc.orig	Wed Jun 26 19:28:40 1996
--- ./decoder.cc	Thu Jul 15 09:35:25 1999
***************
*** 74,79 ****
--- 74,81 ----
  
  Decoder::~Decoder()
  {
+ 	if (rvts_)
+ 		delete rvts_;
  }
  
  int Decoder::command(int argc, const char*const* argv)
*** ./encoder-h261.cc.orig	Mon Jul 22 15:12:53 1996
--- ./encoder-h261.cc	Thu Jul 15 09:35:25 1999
***************
*** 118,123 ****
--- 118,124 ----
  	void setq(int q);
      protected:
  	H261Encoder(int ft);
+ 	~H261Encoder();
  	int encode(const VideoFrame*, const u_int8_t *crvec);
  	int command(int argc, const char*const* argv);
  	void encode_blk(const short* blk, const char* lm);
***************
*** 211,216 ****
--- 212,227 ----
  	}
  }
  
+ H261Encoder::~H261Encoder()
+ {
+ 	for (int q = 0; q < 32; ++q) {
+ 		if (llm_[q] != 0)
+ 			delete llm_[q];
+ 		if (clm_[q] != 0)
+ 			delete clm_[q];
+ 	}
+ }
+ 
  H261PixelEncoder::H261PixelEncoder() : H261Encoder(FT_YUV_CIF)
  {
  	quant_required_ = 0;
***************
*** 631,637 ****
  	if (q < 8) {
  		register int cmin = 0, cmax = 0;
  		register short* bp = lblk;
! 		register i, j;
  
  		// Y U and V blocks
  		for (i = 6; --i >= 0; ) {
--- 642,648 ----
  	if (q < 8) {
  		register int cmin = 0, cmax = 0;
  		register short* bp = lblk;
! 		register long i, j;
  
  		// Y U and V blocks
  		for (i = 6; --i >= 0; ) {
*** ./net.cc.orig	Fri Jun  7 15:37:16 1996
--- ./net.cc	Thu Jul 15 09:35:25 1999
***************
*** 163,208 ****
  {
  	int cc = ::send(fd, (char*)buf, len, 0);
  	if (cc < 0) {
! 		switch (errno) {
  		case ECONNREFUSED:
  			/* no one listening at some site - ignore */
- #if defined(__osf__) || defined(_AIX)
- 			/*
- 			 * Due to a bug in kern/uipc_socket.c, on several
- 			 * systems, datagram sockets incorrectly persist
- 			 * in an error state on receipt of an ICMP
- 			 * port-unreachable.  This causes unicast connection
- 			 * rendezvous problems, and worse, multicast
- 			 * transmission problems because several systems
- 			 * incorrectly send port unreachables for 
- 			 * multicast destinations.  Our work around
- 			 * is to simply close and reopen the socket
- 			 * (by calling reset() below).
- 			 *
- 			 * This bug originated at CSRG in Berkeley
- 			 * and was present in the BSD Reno networking
- 			 * code release.  It has since been fixed
- 			 * in 4.4BSD and OSF-3.x.  It is know to remain
- 			 * in AIX-4.1.3.
- 			 *
- 			 * A fix is to change the following lines from
- 			 * kern/uipc_socket.c:
- 			 *
- 			 *	if (so_serror)
- 			 *		snderr(so->so_error);
- 			 *
- 			 * to:
- 			 *
- 			 *	if (so->so_error) {
- 			 * 		error = so->so_error;
- 			 *		so->so_error = 0;
- 			 *		splx(s);
- 			 *		goto release;
- 			 *	}
- 			 *
- 			 */
- 			reset();
- #endif
  			break;
  
  		case ENETUNREACH:
--- 163,210 ----
  {
  	int cc = ::send(fd, (char*)buf, len, 0);
  	if (cc < 0) {
! 		/*
! 		 * Due to a bug in kern/uipc_socket.c, on several
! 		 * systems, datagram sockets incorrectly persist
! 		 * in an error state on receipt of any ICMP
! 		 * error.  This causes unicast connection
! 		 * rendezvous problems, and worse, multicast
! 		 * transmission problems because several systems
! 		 * incorrectly send port unreachables for 
! 		 * multicast destinations.  Our work around
! 		 * is to call getsockopt(..., SO_ERROR, ...)
! 		 * which resets so->so_error.
! 		 *
! 		 * This bug originated at CSRG in Berkeley
! 		 * and was present in the BSD Reno networking
! 		 * code release.  It has since been fixed
! 		 * in OSF-3.x.  It is know to remain
! 		 * in 4.4BSD and AIX-4.1.3.
! 		 *
! 		 * A fix is to change the following lines from
! 		 * kern/uipc_socket.c:
! 		 *
! 		 *	if (so_serror)
! 		 *		snderr(so->so_error);
! 		 *
! 		 * to:
! 		 *
! 		 *	if (so->so_error) {
! 		 * 		error = so->so_error;
! 		 *		so->so_error = 0;
! 		 *		splx(s);
! 		 *		goto release;
! 		 *	}
! 		 *
! 		 */
! 		int err, errlen = sizeof(err), savederrno;
! 
! 		savederrno = errno;
! 		getsockopt(fd, SOL_SOCKET, SO_ERROR, &err,
! 			(socklen_t *) &errlen);
! 		switch (savederrno) {
  		case ECONNREFUSED:
  			/* no one listening at some site - ignore */
  			break;
  
  		case ENETUNREACH:
***************
*** 217,223 ****
  			 * icmp unreachable, so we should be able to
  			 * send now.
  			 */
! 			(void)::send(ssock_, (char*)buf, len, 0);
  			break;
  
  		default:
--- 219,225 ----
  			 * icmp unreachable, so we should be able to
  			 * send now.
  			 */
! 			(void)::send(fd, (char*)buf, len, 0);
  			break;
  
  		default:
***************
*** 264,275 ****
  	}
  	int cc = ::sendmsg(ssock_, (msghdr*)&mh, 0);
  	if (cc < 0) {
! 		switch (errno) {
  		case ECONNREFUSED:
  			/* no one listening at some site - ignore */
- #if defined(__osf__) || defined(_AIX)
- 			reset();
- #endif
  			break;
  
  		case ENETUNREACH:
--- 266,279 ----
  	}
  	int cc = ::sendmsg(ssock_, (msghdr*)&mh, 0);
  	if (cc < 0) {
! 		int err, errlen = sizeof(err), savederrno;
! 
! 		savederrno = errno;
! 		getsockopt(ssock_, SOL_SOCKET, SO_ERROR, &err,
! 			(socklen_t *) &errlen);
! 		switch (savederrno) {
  		case ECONNREFUSED:
  			/* no one listening at some site - ignore */
  			break;
  
  		case ENETUNREACH:
***************
*** 299,305 ****
  	sockaddr_in sfrom;
  	int fromlen = sizeof(sfrom);
  	int cc = ::recvfrom(fd, (char*)buf, len, 0,
! 			    (sockaddr*)&sfrom, &fromlen);
  	if (cc < 0) {
  		if (errno != EWOULDBLOCK)
  			perror("recvfrom");
--- 303,309 ----
  	sockaddr_in sfrom;
  	int fromlen = sizeof(sfrom);
  	int cc = ::recvfrom(fd, (char*)buf, len, 0,
! 			    (sockaddr*)&sfrom, (socklen_t *) &fromlen);
  	if (cc < 0) {
  		if (errno != EWOULDBLOCK)
  			perror("recvfrom");
*** ./grabber.cc.orig	Mon Feb  5 19:02:00 1996
--- ./grabber.cc	Thu Jul 15 09:35:25 1999
***************
*** 69,74 ****
--- 69,75 ----
  	  hstart_(0), hstop_(0),
  	  framebase_(0), frame_(0),
  	  inw_(0), inh_(0), outw_(0), outh_(0),
+ 	  threshold_(48),
  	  target_(0), tx_(0)
  {
  	bps(128);
***************
*** 120,125 ****
--- 121,130 ----
  					running_ = 0;
  				}
  			}
+ 			return (TCL_OK);
+ 		}
+ 		if (strcmp(argv[1], "threshold") == 0) {
+ 			threshold_ = 8*atoi(argv[2]);
  			return (TCL_OK);
  		}
  		if (strcmp(argv[1], "fps") == 0) {
*** ./grabber.h.orig	Mon Feb  5 19:02:00 1996
--- ./grabber.h	Thu Jul 15 09:35:26 1999
***************
*** 87,92 ****
--- 87,93 ----
  	int vstop_;
  	int hstart_;
  	int hstop_;
+ 	int threshold_ ; // when a block is changed ? (was constant 48)
  
  	u_int framesize_;
  	u_char* framebase_;
***************
*** 160,178 ****
  			rb -= _rs << 3; \
   \
  			int center = 0; \
! 			if (left >= 48 && x > 0) { \
  				crv[-1] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
! 			if (right >= 48 && x < w - 1) { \
  				crv[1] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
! 			if (bottom >= 48 && y < blkh_ - 1) { \
  				crv[w] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
! 			if (top >= 48 && y > 0) { \
  				crv[-w] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
--- 161,179 ----
  			rb -= _rs << 3; \
   \
  			int center = 0; \
! 			if (left >= threshold_ && x > 0) { \
  				crv[-1] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
! 			if (right >= threshold_ && x < w - 1) { \
  				crv[1] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
! 			if (bottom >= threshold_ && y < blkh_ - 1) { \
  				crv[w] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
! 			if (top >= threshold_ && y > 0) { \
  				crv[-w] = CR_MOTION|CR_SEND; \
  				center = 1; \
  			} \
*** ./ui-ctrlmenu.tcl.orig	Wed Jun 26 20:27:48 1996
--- ./ui-ctrlmenu.tcl	Thu Jul 15 09:35:26 1999
***************
*** 390,400 ****
  		-relief raised -command transmit \
  		-anchor w -variable transmitButtonState -font $f \
  		-state disabled -highlightthickness 0
  	button $w.release -text "Release" \
  		-relief raised -command release_device \
  		-font $f -highlightthickness 0
  
! 	pack $w.send $w.release -fill both
  }
  
  proc doNothing { args } {
--- 390,404 ----
  		-relief raised -command transmit \
  		-anchor w -variable transmitButtonState -font $f \
  		-state disabled -highlightthickness 0
+ 	checkbutton $w.freeze -text "Freeze" \
+ 		-relief raised -command "grabber freeze \$freeze" \
+ 		-anchor w -variable freeze -font $f \
+ 		-highlightthickness 0
  	button $w.release -text "Release" \
  		-relief raised -command release_device \
  		-font $f -highlightthickness 0
  
! 	pack $w.send $w.release $w.freeze -fill both
  }
  
  proc doNothing { args } {
***************
*** 434,441 ****
  	
  	frame $w.bps
  	scale $w.bps.scale -orient horizontal -font $f \
! 		-showvalue 0 -from 10 -to [option get . maxbw Vic] \
  		-command "set_bps $w.bps.value" -width 12 \
  		-relief groove
  	label $w.bps.value -font $f -width 8 -anchor w
  
--- 438,446 ----
  	
  	frame $w.bps
  	scale $w.bps.scale -orient horizontal -font $f \
! 		-showvalue 0 -from 1 -to [option get . maxbw Vic] \
  		-command "set_bps $w.bps.value" -width 12 \
+ 		-sliderlength 20 \
  		-relief groove
  	label $w.bps.value -font $f -width 8 -anchor w
  
***************
*** 443,448 ****
--- 448,454 ----
  	scale $w.fps.scale -font $f -orient horizontal \
  		-showvalue 0 -from 1 -to 30 \
  		-command "set_fps $w.fps.value" -width 12 \
+ 		-sliderlength 20 \
  		-relief groove
  	label $w.fps.value -font $f -width 8 -anchor w
  
***************
*** 564,570 ****
  proc select_device device {
  	global transmitButton sizeButtons portButton formatButtons \
  		videoFormat defaultFormat lastDevice defaultPort inputPort \
! 		transmitButtonState
  
  	#
  	# Remember settings of various controls for previous device
--- 570,576 ----
  proc select_device device {
  	global transmitButton sizeButtons portButton formatButtons \
  		videoFormat defaultFormat lastDevice defaultPort inputPort \
! 		transmitButtonState typeButton
  
  	#
  	# Remember settings of various controls for previous device
***************
*** 607,612 ****
--- 613,623 ----
  	} else {
  		$portButton configure -state disabled
  	}
+ 	if [device_supports $device type *] {
+ 		$typeButton configure -state normal
+ 	} else {
+ 		$typeButton configure -state disabled
+ 	}
  
  	insert_grabber_panel [$device nickname]
  
***************
*** 774,780 ****
  	build.encoder_options $w.options
  	build.device $w.device
  	build.port $w.port
! 	pack $w.device $w.port $w.options -fill x
  }
  
  proc build.encoder_options w {
--- 785,792 ----
  	build.encoder_options $w.options
  	build.device $w.device
  	build.port $w.port
! 	build.type $w.type
! 	pack $w.device $w.port $w.type $w.options -fill x
  }
  
  proc build.encoder_options w {
***************
*** 1172,1177 ****
--- 1184,1192 ----
  	global inputPort inputType portButton typeButton
  	if { [$portButton cget -state] == "normal" } {
  		$grabber port $inputPort
+ 	}
+ 	if { [$typeButton cget -state] == "normal" } {
+ 		$grabber type $inputType
  	}
  	setFillRate
  	update
*** ./ui-grabber.tcl.orig	Thu Jun 20 23:39:35 1996
--- ./ui-grabber.tcl	Thu Jul 15 09:35:26 1999
***************
*** 39,103 ****
  # called foo-1, foo-2, etc. and you'll only need build.foo
  #
  
  proc build.slicvideo w {
  	set f [smallfont]
  	label $w.title -text "Grabber"
  	frame $w.f -relief sunken -borderwidth 2
  
  	frame $w.f.h -relief flat
         
! 	label $w.f.h.label  -font $f -anchor e -text "Hue"
!        
! 	scale $w.f.h.scale -orient horizontal -width 12 -length 20 \
! 		           -relief groove -showvalue 0 -from -128 -to 127 \
!                           -command "grabber set HUE"
! 	pack  $w.f.h.label $w.f.h.scale -side left -fill x -expand 1
! 
! 	frame $w.f.ll -relief flat 
!        
! 	label $w.f.ll.label  -font $f -text "Luma" -anchor s
!        
! 	label $w.f.ll.clabel -font $f -text "Contrast" -anchor s
!       
! 	label $w.f.ll.blabel -font $f -text "Brightness" -anchor s
! 	pack  $w.f.ll.clabel $w.f.ll.label $w.f.ll.blabel \
  			     -side left -fill x -expand 1
  
  	frame $w.f.l  -relief flat
         
! 	scale $w.f.l.cscale   -orient horizontal -width 12 -relief groove \
                                -showvalue 0 -from 0 -to 127 \
!                               -command "grabber set LUMA_CONTRAST"
         
! 	scale $w.f.l.bscale -orient horizontal -width 12 -relief groove \
                              -showvalue 0 -from 0 -to 255 \
!                             -command "grabber set LUMA_BRIGHTNESS"
  	pack  $w.f.l.cscale $w.f.l.bscale  -side left -fill x -expand 1
  
! 	frame $w.f.cl  -relief flat
! 
! 	label $w.f.cl.label  -font $f -text "Chroma" -anchor n
!        
! 	label $w.f.cl.glabel -font $f -text "Gain" -anchor n
!        
! 	label $w.f.cl.slabel -font $f -text "Saturation" -anchor n
! 	pack  $w.f.cl.glabel $w.f.cl.label $w.f.cl.slabel \
! 			     -side left -fill x -expand 1
  
  	frame $w.f.c -relief flat
         
! 	scale $w.f.c.gscale -orient horizontal -width 12 -relief groove \
                               -showvalue 0 -from 0 -to 255 \
!                              -command "grabber set CHROMA_GAIN"
         
! 	scale $w.f.c.sscale -orient horizontal -width 12 -relief groove \
                              -showvalue 0 -from 0 -to 127 \
!                             -command "grabber set CHROMA_SATURATION"
  	pack  $w.f.c.gscale $w.f.c.sscale -side left -fill x -expand 1
  
       
! 	pack  $w.f.h $w.f.ll $w.f.l $w.f.c $w.f.cl \
! 	      -fill x -expand 1 -padx 1m 
  
  
  	pack $w.title $w.f -fill x -expand 1
--- 39,131 ----
  # called foo-1, foo-2, etc. and you'll only need build.foo
  #
  
+ proc build.meteor w {
+ #
+ # The meteor has the same controls as the slicvideo, so just call that
+ # routine to build the controls.
+ 
+ 	build.slicvideo $w
+ }
+ 
+ proc build.bktr w {
+ 	build.slicvideo $w
+ }
+ 
  proc build.slicvideo w {
  	set f [smallfont]
+ #	set f  "-*-helvetica-medium-r-normal--*-100-75-75-*-*-*-*"
  	label $w.title -text "Grabber"
  	frame $w.f -relief sunken -borderwidth 2
  
  	frame $w.f.h -relief flat
         
! 	frame $w.f.h.c
! 	label $w.f.h.c.l1  -font $f -anchor e -text "Chan:"
! 	mk.entry $w.f.h.c  do_chan "20"
! 	$w.f.h.c.entry configure -relief sunken -width 5
! 	bind $w.f.h.c.entry <Return> "grabber chan \[$w.f.h.c.entry get\]"
! 	pack $w.f.h.c.l1 $w.f.h.c.entry -side top
! 
! 	global ths
! 	scale $w.f.h.ths \
! -orient horizontal -width 12 -length 60 -relief groove -sliderlength 6 \
! 	    -showvalue 0 -from 1 -to 10 \
! 	    -command "grabber threshold" -label Thre
! 	$w.f.h.ths set 6
! 	# the actual scale is multiplied by 8
! 	scale $w.f.h.scale \
! -orient horizontal -width 12 -length 100 -relief groove \
! 	    -showvalue 0 -from -128 -to 127 \
! 	    -command "grabber hue" -label Hue
! 	pack  $w.f.h.c \
! 		$w.f.h.ths \
! 		$w.f.h.scale \
  			     -side left -fill x -expand 1
  
+ #	frame $w.f.ll -relief flat 
+ #	label $w.f.ll.label  -font $f -text "Luma" -anchor s
+ #	label $w.f.ll.clabel -font $f -text "Contrast" -anchor s
+ #	label $w.f.ll.blabel -font $f -text "Brightness" -anchor s
+ #	pack  $w.f.ll.clabel $w.f.ll.label $w.f.ll.blabel \
+ #			     -side left -fill x -expand 1
+ 
  	frame $w.f.l  -relief flat
         
! 	scale $w.f.l.cscale \
! -orient horizontal -width 12 -length 100 -relief groove \
                                -showvalue 0 -from 0 -to 127 \
! 	  -label "Contrast" \
! 	  -command "grabber contrast"
         
! 	scale $w.f.l.bscale \
! -orient horizontal -width 12 -length 100 -relief groove \
                              -showvalue 0 -from 0 -to 255 \
! 	    -command "grabber brightness" -label "Brightness"
  	pack  $w.f.l.cscale $w.f.l.bscale  -side left -fill x -expand 1
  
! #	frame $w.f.cl  -relief flat
! #	label $w.f.cl.label  -font $f -text "Chroma" -anchor n
! #	label $w.f.cl.glabel -font $f -text "Gain" -anchor n
! #	label $w.f.cl.slabel -font $f -text "Saturation" -anchor n
! #	pack  $w.f.cl.glabel $w.f.cl.label $w.f.cl.slabel \
! #			     -side left -fill x -expand 1
  
  	frame $w.f.c -relief flat
         
! 	scale $w.f.c.gscale \
! -orient horizontal -width 12 -length 100 -relief groove \
                               -showvalue 0 -from 0 -to 255 \
! 	     -command "grabber uvgain" -label "Chr.  Gain"
         
! 	scale $w.f.c.sscale \
! -orient horizontal -width 12 -length 100 -relief groove \
                              -showvalue 0 -from 0 -to 127 \
! 	    -command "grabber saturation" -label "Saturation"
  	pack  $w.f.c.gscale $w.f.c.sscale -side left -fill x -expand 1
  
       
! 	# pack  $w.f.h $w.f.ll $w.f.l $w.f.c $w.f.cl
! 	pack  $w.f.h $w.f.l $w.f.c -fill x -expand 1 -padx 1m 
  
  
  	pack $w.title $w.f -fill x -expand 1
***************
*** 109,114 ****
--- 137,146 ----
  	$w.f.c.sscale set 64
  }
  
+ #
+ # STILL image-grabber (?)
+ #
+ 
  proc build.still w {
  
      set f [smallfont]
***************
*** 131,136 ****
--- 163,172 ----
      $lastDevice file $s
  }
  
+ #
+ # quickcam grabber
+ #
+ 
  proc build.qcam {w} {
      global qcamwindow
  
***************
*** 190,192 ****
--- 226,343 ----
      set qcamwindow(setwbal) "$w.f.s.s.wbal.scale set"
      set qcamwindow(setbpp) "set qcambpp"
  }
+ 
+ #
+ # X11 Grabber controls
+ #
+ proc x11grabUpdatePos {x y w h} {
+ 
+     global x11grabcontrols
+     set w $x11grabcontrols
+ 
+     if {[string compare $x [$w.x11grab.row1.pos.x.e get]] != 0} {
+ 	$w.x11grab.row1.pos.x.e delete 0 end
+ 	$w.x11grab.row1.pos.x.e insert 0 $x
+     }
+     if {[string compare $y [$w.x11grab.row1.pos.y.e get]] != 0} {
+ 	$w.x11grab.row1.pos.y.e delete 0 end
+ 	$w.x11grab.row1.pos.y.e insert 0 $y
+     }
+     if {[string compare $w [$w.x11grab.row1.pos.w.e get]] != 0} {
+ 	$w.x11grab.row1.pos.w.e delete 0 end
+ 	$w.x11grab.row1.pos.w.e insert 0 $w
+     }
+     if {[string compare $h [$w.x11grab.row1.pos.h.e get]] != 0} {
+ 	$w.x11grab.row1.pos.h.e delete 0 end
+ 	$w.x11grab.row1.pos.h.e insert 0 $h
+     }
+ }
+ 
+ proc x11cmd.update.geo w {
+     grabber fixed [$w.row.x get]  [$w.row.y get]
+ }
+ 
+ proc x11cmd.fixed {} {
+     global x11Source x11grabcontrols
+     set w $x11grabcontrols
+     $w.label configure -text "$x11Source"
+     if [winfo exists $w.row] {
+ 	destroy $w.row
+     }
+     frame $w.row
+     pack append $w.row \
+ 	[label $w.row.xl -text "X:" -width 2 -anchor e] {left filly} \
+ 	[entry $w.row.x -relief flat -width 4] {left filly} \
+ 	[label $w.row.yl -text "Y:" -width 2 -anchor e] {left filly} \
+ 	[entry $w.row.y -relief flat -width 4] {left filly}
+     bind $w.row.x <Return> "x11cmd.update.geo $w"
+     bind $w.row.y <Return> "x11cmd.update.geo $w"
+ 
+     pack $w.row -after $w.label
+ }
+ 
+ proc x11cmd.pointer {} {
+     global x11Source x11grabcontrols
+     set w $x11grabcontrols
+     $w.label configure -text "$x11Source"
+     if [winfo exists $w.row] {
+ 	destroy $w.row
+     }
+     frame $w.row
+     pack append $w.row \
+ 	[button $w.row.s -text "Follow pointer" ] { left filly }
+     pack $w.row -after $w.label
+ }
+ 
+ proc x11cmd.window {} {
+ 	global x11Source x11grabcontrols
+ 	puts "x11cmd -- x11Source $x11Source"
+ 	set w $x11grabcontrols
+ 	$w.label configure -text "$x11Source"
+ 	if [winfo exists $w.row] {
+ 	    destroy $w.row
+ 	}
+ 	frame $w.row
+ 	pack append $w.row \
+ 	    [button $w.row.s -text "Select window" ] { left filly }
+ 	pack $w.row -after $w.label
+ }
+ 
+ proc build.x11 w {
+ 	global x11grabcontrols x11Source
+ 	set f [smallfont] 
+ 
+ 	label $w.title -text "X11 Grabber controls"
+ 	frame $w.x11grab -relief sunken -borderwidth 2
+ 	set x11grabcontrols $w.x11grab
+ 	set x11Source "Fixed"
+ 	set w1 $w.x11grab
+ 
+ 	
+ 	# luigi
+ 	set m $w1.menu
+ 	set m1 $m.m1
+ 	menubutton $w1.menu -menu $m1 -text "Source:" \
+ 		-relief raised -width 7 -font $f
+ 	label $w1.label -width 6 -font $f
+ 	frame $w1.row
+ 	menu $m1
+ 	$m1 add radiobutton -label Fixed \
+ 		-state active \
+ 		-command "x11cmd.fixed" -font $f -variable x11Source
+ #	$m1 add radiobutton -label Pointer \
+ #		-command "x11cmd.pointer" -font $f -variable x11Source
+ #	$m1 add radiobutton -label Window \
+ #		-command "x11cmd.window" -font $f -variable x11Source
+ 
+ 	pack append $w1 \
+ 		$w1.menu {left} \
+ 		$w1.label {left} \
+ 		$w1.row {left}
+ 	
+ 	pack $w $w.title $w1 -fill x -expand 1
+ 
+ 	x11cmd.fixed
+ }
+ 
+ ### end of file ###
*** ./ui-resource.tcl.orig	Tue Apr  2 21:33:56 1996
--- ./ui-resource.tcl	Thu Jul 15 09:35:26 1999
***************
*** 140,146 ****
  	option add Vic.useHardwareDecode false startupFile
  	option add Vic.infoHighlightColor LightYellow2 startupFile
  	option add Vic.useJPEGforH261 false startupFile
! 	option add Vic.stillGrabber false startupFile
  	option add Vic.siteDropTime "300" startupFile
  
  	#
--- 140,146 ----
  	option add Vic.useHardwareDecode false startupFile
  	option add Vic.infoHighlightColor LightYellow2 startupFile
  	option add Vic.useJPEGforH261 false startupFile
! 	option add Vic.stillGrabber true startupFile ; # XXX was false
  	option add Vic.siteDropTime "300" startupFile
  
  	#
*** ./grabber-x11.cc.orig	Thu Jul 15 09:35:26 1999
--- ./grabber-x11.cc	Thu Jul 15 09:52:37 1999
***************
*** 0 ****
--- 1,1342 ----
+ /*
+  * Copyright (c) 1998 Luigi Rizzo
+  * grabber-x11.cc for vic
+  *
+  * Redistribution and use in source and binary forms, with or without
+  * modification, are permitted provided that the following conditions
+  * are met:
+  * 1. Redistributions of source code must retain the above copyright
+  *    notice, this list of conditions and the following disclaimer.
+  * 2. Redistributions in binary form must reproduce the above copyright
+  *    notice, this list of conditions and the following disclaimer in the
+  *    documentation and/or other materials provided with the distribution.
+  * 3. All advertising materials mentioning features or use of this software
+  *    must display the following acknowledgement:
+  *      This product includes software developed by Jim Lowe
+  * 4. The name of the author may not be used to endorse or promote products
+  *    derived from this software without specific prior written permission.
+  *
+  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  * POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <fcntl.h>
+ #include <sys/types.h>
+ #include <sys/ioctl.h>
+ #include <sys/mman.h>
+ 
+ #include "grabber.h"
+ #include "Tcl.h"
+ #include "device-input.h"
+ #include "module.h"
+ 
+ #include <X11/Xlib.h>
+ #include <X11/Xutil.h>
+ #include <X11/Xatom.h>
+ #include <X11/cursorfont.h>
+ 
+ #ifdef USE_SHM
+ #include <X11/extensions/XShm.h>
+ #endif
+ 
+ #include <tk.h>
+ /*** #include "sized_types.h" ***/
+ 
+ /*
+ 	Netvideo version 3.3
+ 	Written by Ron Frederick <frederick@parc.xerox.com>
+ 
+ 	Machine-specific sized integer type definitions
+ 	Video utility definitions
+ */
+ 
+ /*
+  * Copyright (c) Xerox Corporation 1992. All rights reserved.
+  *  
+  * License is granted to copy, to use, and to make and to use derivative
+  * works for research and evaluation purposes, provided that Xerox is
+  * acknowledged in all documentation pertaining to any such copy or derivative
+  * work. Xerox grants no other licenses expressed or implied. The Xerox trade
+  * name should not be used in any advertising without its written permission.
+  *  
+  * XEROX CORPORATION MAKES NO REPRESENTATIONS CONCERNING EITHER THE
+  * MERCHANTABILITY OF THIS SOFTWARE OR THE SUITABILITY OF THIS SOFTWARE
+  * FOR ANY PARTICULAR PURPOSE.  The software is provided "as is" without
+  * express or implied warranty of any kind.
+  *  
+  * These notices must be retained in any copies of any part of this software.
+  */
+ 
+ typedef signed char	int8;		/*  8 bit signed int */
+ typedef short		int16;		/* 16 bit signed int */
+ typedef int		int32;		/* 32 bit signed int */
+ #if defined(__alpha)
+ typedef long		int64;		/* 64 bit signed int */
+ #endif
+ 
+ typedef unsigned char	uint8;		/*  8 bit unsigned int */
+ typedef unsigned short	uint16;		/* 16 bit unsigned int */
+ typedef unsigned int	uint32;		/* 32 bit unsigned int */
+ #if defined(__alpha)
+ typedef unsigned long	uint64;		/* 64 bit unsigned int */
+ #endif
+ 
+ /* Mildly gross but moderately portable test for littleendian machines */
+ #define LITTLEENDIAN (ntohl(0x12345678) != 0x12345678)
+ 
+ typedef struct {
+     XImage	*image;
+     void	*shminfo;
+ } ximage_t;
+ 
+ /*************************/
+ 
+ #define VID_SMALL               0x01
+ #define VID_MEDIUM              0x02
+ #define VID_LARGE               0x04
+ #define VID_SIZEMASK            0x07 
+  
+ #define VID_GREYSCALE           0x08
+ #define VID_COLOR               0x10
+ 
+ #define X11GRAB_FIXED   0 
+ #define X11GRAB_POINTER 1
+ #define X11GRAB_WINDOW  2
+  
+ 
+ /*XXX*/
+ #define NTSC_WIDTH 320
+ #define NTSC_HEIGHT 240
+ #define PAL_WIDTH 384
+ #define PAL_HEIGHT 288
+ #define CIF_WIDTH 352
+ #define CIF_HEIGHT 288
+ 
+ 
+ class X11Grabber : public Grabber {
+  public:
+ 	X11Grabber(const char* name, const char* format);
+ 	virtual ~X11Grabber();
+ 	virtual void start();
+ 	virtual void stop();
+  protected:
+ 	virtual int command(int argc, const char*const* argv);
+ 	virtual int capture();
+ 	virtual int grab();
+ 	void format();
+ 	void setsize();
+ 
+ 	void X11Grab_ComputeYUVTable(void) ;
+ 	int X11Grab_MSBWhite1(void);
+ 	int X11Grab_LSBWhite1(void);
+ 	int X11Grab_MSBBlack1(void);
+ 	int X11Grab_LSBBlack1(void);
+ 	int X11Grab_Pseudo8(void);
+ 	int X11Grab_RGB16(void);
+ 	int X11Grab_TrueXBGR24(void);
+ 
+     	int X11Grab_Initialize(Window rw, int w, int h);
+         int (X11Grabber::*c_grab)(void);
+ 
+ 	uint8 *rgb2y_ ;
+ 	int8 *rgb2u_ ;
+ 	int8 *rgb2v_ ;
+ 
+         ximage_t *ximage_ ;
+ 
+ 	Display *dpy_ ;
+ 	int mode_;		/* input mode */
+ 	Window theroot_ ;
+ 
+ //	Tcl_Interp *interp_=NULL;
+ 
+ 	int screen, xerror ;
+   	Window vRoot_ ;
+ 	Window rootwin_ ;
+ 	Colormap colormap;
+ 	Visual *root_vis;
+ 	XVisualInfo root_visinfo;
+ 	 
+ 	int ncolors_ ;
+ 	int black, white;
+ 	XColor *color ;
+ 	uint8 *col2y_ ;
+ 	uint16 *col2rgb16_ ;
+ 
+ 	u_int basewidth_;	/* Height of frame to be captured */
+ 	u_int baseheight_;	/* Width of frame to be captured */
+ 	u_int decimate_;	/* division of base sizes */
+ 
+ 	int x_origin_, y_origin_, width_, height_;
+ 	int root_depth_, root_width, root_height;
+ };
+ 
+ class X11Device : public InputDevice {
+  public:
+ 	X11Device(const char* nickname);
+ 	virtual int command(int argc, const char*const* argv);
+  protected:
+ 	const char* name_;
+ };
+ 
+ static X11Device find_x11_devices("x11");
+ 
+ X11Device::X11Device(const char* nickname):
+ 			InputDevice(nickname), name_(nickname)
+ {
+ 	if (free)
+ 		attributes_ = "\
+ size {large normal small cif} \
+ format {422}" ;
+ 	else
+ 		attributes_ = "disabled";
+ }
+ 
+ extern "C" {
+ /*** most of this taken from nv:x11-grab.c  ***/
+ extern ximage_t *VidUtil_AllocXImage(Display *dpy, Visual *vis, int depth,
+ 				     int width, int height, int readonly);
+ 
+ #if 0 /* debugging stuff */
+ static int my_Tcl_Eval(Tcl_Interp *interp, char *cmd)
+ {
+ 	fprintf(stderr,"Tcl_Eval <%s>\n", cmd);
+ 	Tcl_Eval(interp, cmd);
+ }
+ #define	Tcl_Eval my_Tcl_Eval
+ #endif
+ 
+ static Window
+ VirtualRootWindow(Display *dpy, int screen)
+ {
+     static Display *last_dpy=(Display *)NULL;
+     static int last_screen = -1;    
+     static Window vRoot=None;
+ 
+     Atom __SWM_VROOT=None;
+     Window rw, p, *child;
+     unsigned int i,  nChildren;
+ 
+     if ((dpy != last_dpy) || (screen != last_screen)) {
+         vRoot = RootWindow(dpy, screen);
+ 
+         /* go look for a virtual root */
+         __SWM_VROOT = XInternAtom(dpy, "__SWM_VROOT", False);
+         XQueryTree(dpy, vRoot, &rw, &p, &child, &nChildren);
+         for (i=0; i<nChildren; i++) {
+             Atom actual_type;
+             int actual_format;
+             unsigned long nitems, bytesafter;
+             Window *newRoot=NULL;
+     
+             if ((XGetWindowProperty(dpy, child[i], __SWM_VROOT, 0, 1, False,
+                                     XA_WINDOW, &actual_type, &actual_format,
+                                     &nitems, &bytesafter,
+                                     (unsigned char **)&newRoot) == Success)
+                 && (newRoot != NULL)) {
+                 vRoot = *newRoot;
+                 XFree((void *)newRoot);
+                 break;
+             }
+         }
+         XFree((void *)child);
+ 
+         last_dpy = dpy;
+         last_screen = screen;
+     }
+ 
+     return vRoot;
+ }
+ 
+ } /* end extern C */
+ 
+ void
+ X11Grabber::X11Grab_ComputeYUVTable(void)
+ {
+     int i;
+ 
+     switch (root_visinfo.c_class) {
+     case StaticColor:
+     case PseudoColor:
+     case StaticGray:
+     case GrayScale:
+         for (i=0; i<ncolors_; i++) color[i].pixel = i;
+         XQueryColors(dpy_, colormap, color, ncolors_);
+         for (i=0; i<ncolors_; i++) {
+             color[i].red = (color[i].red & 0xf800) ;
+             color[i].green = (color[i].green & 0xfc00) >> 5 ;
+             color[i].blue = (color[i].blue & 0xf800) >> 11 ;
+             col2rgb16_[i] = color[i].red + color[i].green + color[i].blue;
+             col2y_[i] = rgb2y_[col2rgb16_[i]];
+         }
+         break;
+     case TrueColor:
+ 	fprintf(stderr, "TrueColor...\n");
+         break;
+     case DirectColor:
+ 	fprintf(stderr, "DirectColor...\n");
+         break;
+     }
+ }
+ 
+ /*
+  * these are the grabbing functions for the various video formats
+  */
+ 
+ int
+ X11Grabber::X11Grab_MSBWhite1()
+ {
+     int x, y, row;
+     uint8 *data=(uint8 *)ximage_->image->data, *yp= frame_;
+ 
+     for (y=0; y<height_; y++) {
+         for (x=0; x<width_; x+=8) {
+             row = *data++;
+ 
+             yp[0] = 255 * ((row & 0x80)>>7);
+             yp[1] = 255 * ((row & 0x40)>>6);
+             yp[2] = 255 * ((row & 0x20)>>5);
+             yp[3] = 255 * ((row & 0x10)>>4);
+             yp[4] = 255 * ((row & 0x08)>>3);
+             yp[5] = 255 * ((row & 0x04)>>2);
+             yp[6] = 255 * ((row & 0x02)>>1);
+             yp[7] = 255 *  (row & 0x01);
+             yp += 8;
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ int
+ X11Grabber::X11Grab_MSBBlack1()
+ {
+     int x, y, row;
+     uint8 *data=(uint8 *)ximage_->image->data, *yp= frame_;
+ 
+     for (y=0; y<height_; y++) {
+         for (x=0; x<width_; x+=8) {
+             row = *data++;
+ 
+             yp[0] = 255 - 255 * ((row & 0x80)>>7);
+             yp[1] = 255 - 255 * ((row & 0x40)>>6);
+             yp[2] = 255 - 255 * ((row & 0x20)>>5);
+             yp[3] = 255 - 255 * ((row & 0x10)>>4);
+             yp[4] = 255 - 255 * ((row & 0x08)>>3);
+             yp[5] = 255 - 255 * ((row & 0x04)>>2);
+             yp[6] = 255 - 255 * ((row & 0x02)>>1);
+             yp[7] = 255 - 255 *  (row & 0x01);
+             yp += 8;
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ int
+ X11Grabber::X11Grab_LSBWhite1()
+ {
+     int x, y, row;
+     uint8 *data=(uint8 *)ximage_->image->data, *yp= frame_ ;
+ 
+     for (y=0; y<height_; y++) {
+         for (x=0; x<width_; x+=8) {
+             row = *data++;
+ 
+             yp[7] = 255 * ((row & 0x80)>>7);
+             yp[6] = 255 * ((row & 0x40)>>6);
+             yp[5] = 255 * ((row & 0x20)>>5);
+             yp[4] = 255 * ((row & 0x10)>>4);
+             yp[3] = 255 * ((row & 0x08)>>3);
+             yp[2] = 255 * ((row & 0x04)>>2);
+             yp[1] = 255 * ((row & 0x02)>>1);
+             yp[0] = 255 *  (row & 0x01);
+             yp += 8;
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ int
+ X11Grabber::X11Grab_LSBBlack1()
+ {
+     int x, y, row;
+     uint8 *data=(uint8 *)ximage_->image->data, *yp= frame_;
+ 
+     for (y=0; y<height_; y++) {
+         for (x=0; x<width_; x+=8) {
+             row = *data++;
+ 
+             yp[7] = 255 - 255 * ((row & 0x80)>>7);
+             yp[6] = 255 - 255 * ((row & 0x40)>>6);
+             yp[5] = 255 - 255 * ((row & 0x20)>>5);
+             yp[4] = 255 - 255 * ((row & 0x10)>>4);
+             yp[3] = 255 - 255 * ((row & 0x08)>>3);
+             yp[2] = 255 - 255 * ((row & 0x04)>>2);
+             yp[1] = 255 - 255 * ((row & 0x02)>>1);
+             yp[0] = 255 - 255 *  (row & 0x01);
+             yp += 8;
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ int
+ X11Grabber::X11Grab_Pseudo8()
+ {
+     int x, y, p0, p1, p2, p3 ;
+     uint8 *data=(uint8 *)ximage_->image->data, *yp=frame_ ;
+     uint8 *up= (uint8 *)yp + framesize_ ;
+     uint8 *vp= up + (framesize_ >> 2) ;
+ 
+     X11Grab_ComputeYUVTable();
+ 
+     for (y=0; y<height_; y += 2) {
+         for (x=0; x<width_ ; x += 2) {
+             yp[0] = col2y_[data[0]];
+             p0 = col2rgb16_[data[0]];
+             yp[1] = col2y_[data[1]];
+             p1 = col2rgb16_[data[1]];
+ 
+             p2 = col2rgb16_[data[width_]];
+             p3 = col2rgb16_[data[width_ + 1]];
+ #if 0 /* average */
+   	    p0 = ( (p0 >> 1) & 0x7bef ) + ( (p1 >> 1) & 0x7bef ) ;
+   	    p2 = ( (p2 >> 1) & 0x7bef ) + ( (p3 >> 1) & 0x7bef ) ;
+   	    p0 = ( (p0 >> 1) & 0x7bef ) + ( (p2 >> 1) & 0x7bef ) ;
+ #else /* take the darkest... */
+ 	    if (yp[1] < yp[0]) p0 = p1 ;
+ 	    if (rgb2y_[p2] < rgb2y_[p0]) p0 = p2 ;
+ 	    if (rgb2y_[p3] < rgb2y_[p0]) p0 = p3 ;
+ #endif
+ 	    *up++ = rgb2u_[ p0 ];
+ 	    *vp++ = rgb2v_[ p0 ];
+ 
+             data += 2;
+ 	    yp += 2 ;
+         }
+         for (x=0; x<width_; x += 8) {
+             yp[0] = col2y_[data[0]];
+             yp[1] = col2y_[data[1]];
+             yp[2] = col2y_[data[2]];
+             yp[3] = col2y_[data[3]];
+             yp[4] = col2y_[data[4]];
+             yp[5] = col2y_[data[5]];
+             yp[6] = col2y_[data[6]];
+             yp[7] = col2y_[data[7]];
+             data += 8;
+ 	    yp += 8 ;
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ int
+ X11Grabber::X11Grab_RGB16(void)
+ {
+     int x, y;
+     uint8 *yp= (uint8 *)frame_ ;
+     uint8 *up= (uint8 *)yp + framesize_ ;
+     uint8 *vp= up + (framesize_ >> 2) ;
+     uint16 *data=(uint16 *)ximage_->image->data, p0, p1, p2, p3;
+ 
+     for (y=0; y<height_; y+=2) {
+         for (x=0; x<width_; x += 2) {
+             p0 = data[0] ;
+ 	    p1 = data[1] ;
+ 	    p2 = data[ width_] ;
+ 	    p3 = data[ width_ + 1] ;
+ 	    data += 2 ;
+             yp[0] = rgb2y_[ p0 ] ; /* in 565 format */
+             yp[1] = rgb2y_[ p1 ] ; /* in 565 format */
+ #if 0
+ 	    /* average the four pixels... */
+   	    p0 = ( (p0 >> 1) & 0x7bef ) + ( (p1 >> 1) & 0x7bef ) ;
+   	    p2 = ( (p2 >> 1) & 0x7bef ) + ( (p3 >> 1) & 0x7bef ) ;
+   	    p0 = ( (p0 >> 1) & 0x7bef ) + ( (p2 >> 1) & 0x7bef ) ;
+ #else /* take the darkest... */
+ 	    if (yp[1] < yp[0]) p0 = p1 ;
+ 	    if (rgb2y_[p2] < rgb2y_[p0]) p0 = p2 ;
+ 	    if (rgb2y_[p3] < rgb2y_[p0]) p0 = p3 ;
+ #endif
+ 	    *up++ = rgb2u_[ p0 ];
+ 	    *vp++ = rgb2v_[ p0 ];
+ 	    yp += 2 ;
+ 	}
+         for (x=0; x<width_; x += 8) {
+ 	    yp[0] = rgb2y_[data[0] ];
+ 	    yp[1] = rgb2y_[data[1] ];
+ 	    yp[2] = rgb2y_[data[2] ];
+ 	    yp[3] = rgb2y_[data[3] ];
+ 	    yp[4] = rgb2y_[data[4] ];
+ 	    yp[5] = rgb2y_[data[5] ];
+ 	    yp[6] = rgb2y_[data[6] ];
+ 	    yp[7] = rgb2y_[data[7] ];
+ 	    yp += 8 ;
+ 	    data += 8 ;
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ int
+ X11Grabber::X11Grab_TrueXBGR24()
+ {
+     int x, y;
+     uint8 *yp= (uint8 *)frame_ ;
+     uint8 *up= (uint8 *)yp + framesize_ ;
+     uint8 *vp= up + (framesize_ >> 2) ;
+     uint16 p0, p1 ;
+     uint32 *data=(uint32 *)ximage_->image->data, d ;
+ 
+     for (y=0; y<height_; y += 2) {
+         for (x=0; x<width_; x+=2) {
+             d = *data++ ;
+             p0 = ((d<<8) & 0xf100) | ((p0>>5) & 0x7e0) | ((p0>>19) & 0x1f);
+ 	    *yp++ = rgb2y_[ p0 ];
+ 
+             d = *data++ ;
+             p1 = ((d<<8) & 0xf100) | ((p0>>5) & 0x7e0) | ((p0>>19) & 0x1f);
+ 	    *yp++ = rgb2y_[ p1 ];
+ 
+ 	    /* average the two pixels... */
+   	    p0 = ( (p0 >> 1) & 0x7bef ) + ( (p1 >> 1) & 0x7bef ) ;
+ 	    *up++ = rgb2u_[ p0 ];
+         }
+         for (x=0; x<width_; x+=2) {
+             d = *data++ ;
+             p0 = ((d<<8) & 0xf100) | ((p0>>5) & 0x7e0) | ((p0>>19) & 0x1f);
+ 	    *yp++ = rgb2y_[ p0 ];
+ 
+             d = *data++ ;
+             p1 = ((d<<8) & 0xf100) | ((p0>>5) & 0x7e0) | ((p0>>19) & 0x1f);
+ 	    *yp++ = rgb2y_[ p1 ];
+ 
+ 	    /* average the two pixels... */
+   	    p0 = ( (p0 >> 1) & 0x7bef ) + ( (p1 >> 1) & 0x7bef ) ;
+ 	    *vp++ = rgb2v_[ p0 ];
+         }
+     }
+ 
+     return 1;
+ }
+ 
+ extern "C" {
+ extern void VidUtl_Init(Display *dpy);
+ extern void VidUtil_DestroyXImage(Display *dpy, ximage_t *ximage);
+ }
+ 
+ /*
+  * initialization of frame grabber...
+  */
+ int
+ X11Grabber::X11Grab_Initialize(Window rw, int w, int h)
+ {   
+     int config = 0 ;
+     XWindowAttributes wattr;
+     
+     if (theroot_ != rw) {
+         theroot_ = rw;    
+         XGetWindowAttributes(dpy_, theroot_, &wattr);
+         screen = XScreenNumberOfScreen(wattr.screen);
+         colormap = DefaultColormapOfScreen(wattr.screen);
+         ncolors_ = CellsOfScreen(wattr.screen);
+         black = BlackPixelOfScreen(wattr.screen);
+         white = WhitePixelOfScreen(wattr.screen);
+         root_depth_ = wattr.depth;
+         root_width = wattr.width;
+         root_height = wattr.height;
+         root_vis = wattr.visual;
+         vRoot_ = VirtualRootWindow(dpy_, screen);
+ 
+         if (color != NULL) {
+ 	    free(color);
+ 	    free(col2y_);
+ 	    free(col2rgb16_);
+ 	}
+         color = (XColor *) malloc(ncolors_*sizeof(XColor));
+         col2y_ = (uint8 *) malloc(ncolors_*sizeof(uint8));
+         col2rgb16_ = (uint16 *) malloc(ncolors_*sizeof(uint16));
+ 
+         XMatchVisualInfo(dpy_, screen, root_depth_, root_vis->c_class,
+                          &root_visinfo);
+         switch (root_depth_) {
+         case 1:
+             if (white == 1) {
+                 c_grab = (LITTLEENDIAN) ? &X11Grabber::X11Grab_LSBWhite1 : &X11Grabber::X11Grab_MSBWhite1;
+             } else {
+                 c_grab = (LITTLEENDIAN) ? &X11Grabber::X11Grab_LSBBlack1 : &X11Grabber::X11Grab_MSBBlack1;
+             }
+             config = VID_GREYSCALE;
+             break;
+ 
+         case 8:
+             switch (root_visinfo.c_class) {
+             case PseudoColor:
+             case GrayScale:
+             case StaticColor:
+             case StaticGray:
+                 c_grab = &X11Grabber::X11Grab_Pseudo8;
+                 break;
+             default:
+                 c_grab = NULL;
+                 break;
+             }
+             config = VID_GREYSCALE|VID_COLOR;
+             break;
+ 
+         case 16:
+ 	    c_grab = &X11Grabber::X11Grab_RGB16;
+ 	    break ;
+ 
+         case 24:
+             if ((root_visinfo.c_class == TrueColor) &&
+                 (root_visinfo.green_mask = 0xff00) &&
+ #if defined(__FreeBSD__) || defined(__OpenBSD__)
+                 (root_visinfo.red_mask == 0xff0000) &&
+                 (root_visinfo.blue_mask == 0xff))
+ #else
+                 (root_visinfo.red_mask == 0xff) &&
+                 (root_visinfo.blue_mask == 0xff0000))
+ #endif
+                 {
+                 c_grab = &X11Grabber::X11Grab_TrueXBGR24;
+             } else
+                 c_grab = NULL;
+             config = VID_GREYSCALE|VID_COLOR;
+             break;
+ 
+         default:
+ 	    fprintf(stderr, "don't know how to grab %d bits\n",
+ 		root_depth_);
+             c_grab = NULL;
+             break;
+         }
+     }
+     
+     if ((ximage_ == NULL) || (width_ != w) || (height_ != h)) {
+         width_ = w;
+         height_ = h;
+         if (ximage_ != NULL)
+ 	    VidUtil_DestroyXImage(dpy_, ximage_);
+         ximage_ = VidUtil_AllocXImage(dpy_, root_vis, root_depth_, w, h, False);
+     }
+     return (c_grab == NULL) ? 0 : config|VID_SMALL|VID_MEDIUM|VID_LARGE;
+ }
+ 
+ extern "C" {
+ extern void VidUtil_Init(Display *dpy);
+ extern void VidUtil_DestroyXImage(Display *dpy, ximage_t *ximage);
+ 
+ #ifdef UNUSED /* not yet... */
+ static int
+ ErrHandler1(ClientData clientData, XErrorEvent *errevp)
+ {
+     xerror = 1;
+     return 0;
+ }
+ 
+ static int
+ X11Grab_MakeBox(unsigned int x1, unsigned int y1,
+                            unsigned int x2, unsigned int y2,
+                            int *xp, int *yp, int *wp, int *hp)
+ {
+     int w, h;
+ 
+     w = x2-x1;
+     if (w < 0) {
+         *xp = x2;
+         *wp = -w;
+     } else {
+         *xp = x1;
+         *wp = w;
+     }
+     
+     h = y2-y1;
+     if (h < 0) {
+         *yp = y2;
+         *hp = -h;
+     } else {
+         *yp = y1;
+         *hp = h;
+     }
+ }   
+ 
+ static int
+ X11Grab_UpdatePos(Window rw, int x, int y, int w, int h)
+ {
+     static char cmd[256];
+ 
+     if (w < 8) w = 8;
+     if (h < 8) h = 8;
+ 
+     if (w > root_width/8*8) w = root_width/8*8;
+     if (h > root_height/8*8) h = root_height/8*8;
+ 
+     w = (w+7)/8*8;
+     h = (h+7)/8*8;
+ 
+     if (x < 0) x = 0;
+     if (y < 0) y = 0;
+ 
+     if (x > root_width-w) x = root_width-w;
+     if (y > root_height-h) y = root_height-h;
+ 
+     sprintf(cmd, "x11grabUpdatePos %d %d %d %d", x, y, w, h);
+     (void) Tcl_Eval(interp, cmd);
+ 
+     x_origin = x;
+     y_origin = y;
+ 
+     if ((root != rw) || (width != w) || (height != h)) {
+         X11Grab_Initialize(rw, w, h);
+         return 0;
+     } else
+         return 1;
+ }
+ 
+ static int
+ X11Grab_FollowPointer(void)
+ {
+     Window rw, cw;
+     int x, y, wx, wy;
+     unsigned int mask;
+ 
+     XQueryPointer(dpy, root, &rw, &cw, &x, &y, &wx, &wy, &mask);
+ 
+     if (x < x_origin+width/4)
+         x = x-width/4;
+     else if (x >= x_origin+3*width/4)
+         x = x-3*width/4;
+     else
+         x = x_origin;
+     
+     if (y < y_origin+height/4)
+         y = y-height/4;
+     else if (y >= y_origin+3*height/4)
+         y = y-3*height/4;
+     else
+         y = y_origin;
+     
+     return X11Grab_UpdatePos(rw, x, y, width, height);
+ }
+ 
+ static int
+ X11Grab_FollowWindow(void)
+ {
+     int x, y, w, h;
+     XWindowAttributes wattr, vRoot_wattr;
+     Tk_ErrorHandler handler;
+ 
+     handler = Tk_CreateErrorHandler(dpy, -1, -1, -1, ErrHandler1, NULL);
+     xerror = 0;
+     XGetWindowAttributes(dpy, target, &wattr);
+     XSync(dpy, False);
+     Tk_DeleteErrorHandler(handler);
+     if ((target == None) || xerror) {
+         target = None;
+         (void) Tcl_Eval(interp,
+                ".grabControls.x11grab.row1.mode.window config -state disabled");
+         (void) Tcl_Eval(interp, "set x11grabMode fixed");
+         return 1;
+     } else {
+         XGetWindowAttributes(dpy, vRoot, &vRoot_wattr);
+         x = wattr.x+vRoot_wattr.x;
+         y = wattr.y+vRoot_wattr.y;
+         w = wattr.width+2*wattr.border_width;
+         h = wattr.height+2*wattr.border_width;
+ 
+         return X11Grab_UpdatePos(root, x, y, w, h);
+     }
+ }   
+ #endif /* UNUSED ... */
+ 
+ 
+ #ifdef UNUSED
+ /*ARGSUSED*/
+ static int
+ X11Grab_SetXCmd(ClientData clientData, Tcl_Interp *interp,
+                            int argc, char *argv[])
+ {
+     int x;
+ 
+     if (argc != 2) {
+         Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
+             " x\"", NULL);
+         return TCL_ERROR;
+     }
+     
+     x = atoi(argv[1]);
+     (void) X11Grab_UpdatePos(root, x, y_origin, width, height);
+ 
+     return TCL_OK;
+ }
+ 
+ /*ARGSUSED*/
+ static int
+ X11Grab_SetYCmd(ClientData clientData, Tcl_Interp *interp,
+                            int argc, char *argv[])
+ {
+     int y;
+ 
+     if (argc != 2) {
+         Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
+             " y\"", NULL);
+         return TCL_ERROR;
+     }
+     
+     y = atoi(argv[1]);
+     (void) X11Grab_UpdatePos(root, x_origin, y, width, height);
+ 
+     return TCL_OK;
+ }
+ 
+ /*ARGSUSED*/
+ static int X11Grab_SetWCmd(ClientData clientData, Tcl_Interp *interp,
+                            int argc, char *argv[])
+ {
+     int w;
+ 
+     if (argc != 2) {
+         Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
+             " width\"", NULL);
+         return TCL_ERROR;
+     }
+     
+     w = atoi(argv[1]);
+     (void) X11Grab_UpdatePos(root, x_origin, y_origin, w, height);
+ 
+     return TCL_OK;
+ }
+ 
+ /*ARGSUSED*/
+ static int
+ X11Grab_SetHCmd(ClientData clientData, Tcl_Interp *interp,
+                            int argc, char *argv[])
+ {
+     int h;
+ 
+     if (argc != 2) {
+         Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
+             " height\"", NULL);
+         return TCL_ERROR;
+     }
+     
+     h = atoi(argv[1]);
+     (void) X11Grab_UpdatePos(root, x_origin, y_origin, width, h);
+ 
+     return TCL_OK;
+ }
+ 
+ /*ARGSUSED*/
+ static int
+ X11Grab_SetRegionCmd(ClientData clientData, Tcl_Interp *interp,
+                                 int argc, char *argv[])
+ {
+     unsigned int rootx, rooty;
+     int x, y, w, h, boxDrawn=0;
+     GC xorGC;
+     Cursor cursor;
+     XEvent event;
+ 
+     cursor = XCreateFontCursor(dpy, XC_cross);
+ 
+     if (XGrabPointer(dpy, root, False, ButtonPressMask, GrabModeAsync,
+                      GrabModeAsync, root, cursor, CurrentTime)!=GrabSuccess) {
+         Tcl_AppendResult(interp, argv[0], ": can't grab mouse", NULL);
+         return TCL_ERROR;
+     }
+     
+     xorGC = XCreateGC(dpy, root, 0, NULL);
+     XSetSubwindowMode(dpy, xorGC, IncludeInferiors);
+     XSetForeground(dpy, xorGC, -1);
+     XSetFunction(dpy, xorGC, GXxor);
+ 
+     XMaskEvent(dpy, ButtonPressMask, &event);
+     rootx = event.xbutton.x_root;
+     rooty = event.xbutton.y_root;
+ 
+     XChangeActivePointerGrab(dpy, ButtonMotionMask|ButtonReleaseMask, cursor,
+                              CurrentTime);
+ 
+     while (1) {
+         XNextEvent(dpy, &event);
+         switch (event.type) {
+         case MotionNotify:
+             if (boxDrawn) {
+                 XDrawRectangle(dpy, root, xorGC, x, y, w, h);
+                 boxDrawn = 0;
+             }
+             while (XCheckTypedEvent(dpy, MotionNotify, &event)) ;
+             X11Grab_MakeBox(rootx, rooty, event.xbutton.x_root,
+                             event.xbutton.y_root, &x, &y, &w, &h);
+             XDrawRectangle(dpy, root, xorGC, x, y, w, h);
+             boxDrawn = 1;
+             break;
+         case ButtonRelease:
+             if (boxDrawn) {
+                 XDrawRectangle(dpy, root, xorGC, x, y, w, h);
+                 boxDrawn = 0;
+             }
+             XFlush(dpy);
+             X11Grab_MakeBox(rootx, rooty, event.xmotion.x_root,
+                             event.xmotion.y_root, &x, &y, &w, &h);
+             XUngrabPointer(dpy, CurrentTime);
+             XFreeGC(dpy, xorGC);
+             XFreeCursor(dpy, cursor);
+             (void) Tcl_Eval(interp, "set x11grabMode fixed");
+             (void) X11Grab_UpdatePos(root, x, y, w, h);
+             return TCL_OK;
+         }
+     }
+ }
+ 
+ /*ARGSUSED*/
+ static int X11Grab_SetWindowCmd(ClientData clientData, Tcl_Interp *interp,
+                                 int argc, char *argv[])
+ {
+     int buttons=0;
+     Cursor cursor;
+     XEvent event;
+ 
+     cursor = XCreateFontCursor(dpy, XC_crosshair);
+     target = None;
+ 
+     if (XGrabPointer(dpy, vRoot, False, ButtonPressMask|ButtonReleaseMask,
+                      GrabModeSync, GrabModeAsync, root, cursor,
+                      CurrentTime) != GrabSuccess) {
+         Tcl_AppendResult(interp, argv[0], ": can't grab mouse", NULL);
+         return TCL_ERROR;
+     }
+     
+     while ((target == None) || (buttons != 0)) {
+         XAllowEvents(dpy, SyncPointer, CurrentTime);
+         XWindowEvent(dpy, vRoot, ButtonPressMask|ButtonReleaseMask, &event);
+         switch (event.type) {
+         case ButtonPress:
+             if (target == None) target = event.xbutton.subwindow;
+             buttons++;
+             break;
+         case ButtonRelease:
+             if (buttons > 0) buttons--;
+             break;
+         }
+     }
+     
+     XUngrabPointer(dpy, CurrentTime);
+     XFreeCursor(dpy, cursor);
+ 
+     (void) Tcl_Eval(interp,
+                ".grabControls.x11grab.row1.mode.window config -state normal");
+     (void) Tcl_Eval(interp, "set x11grabMode window");
+     (void) X11Grab_FollowWindow();
+     return TCL_OK;
+ }
+ 
+ int
+ X11Grab_Probe(Tk_Window tkMainWin)
+ {
+     Window rw;
+     interp = Tcl_CreateInterp();
+ 
+     if (tkMainWin == NULL) return 0;
+ 
+     Tcl_TraceVar(interp, "x11grabMode", TCL_TRACE_WRITES, X11Grab_TraceMode,
+                  NULL);
+     Tcl_CreateCommand(interp, "x11grabSetX", X11Grab_SetXCmd, 0, NULL);
+     Tcl_CreateCommand(interp, "x11grabSetY", X11Grab_SetYCmd, 0, NULL);
+     Tcl_CreateCommand(interp, "x11grabSetW", X11Grab_SetWCmd, 0, NULL);
+     Tcl_CreateCommand(interp, "x11grabSetH", X11Grab_SetHCmd, 0, NULL);
+     Tcl_CreateCommand(interp, "x11grabSetRegion", X11Grab_SetRegionCmd, 0,
+                       NULL);
+     Tcl_CreateCommand(interp, "x11grabSetWindow", X11Grab_SetWindowCmd, 0,
+                       NULL);
+     dpy = Tk_Display(tkMainWin);
+     rootwin = rw = RootWindow(dpy, Tk_ScreenNumber(tkMainWin));
+     VidUtil_Init(dpy);
+     return X11Grab_Initialize(rw, width, height);
+ }
+ #endif /* UNUSED */
+ 
+ } /* end extern "C" block */
+ 
+ 
+ int
+ X11Device::command(int argc, const char*const* argv)
+ {
+ 	Tcl& tcl = Tcl::instance();
+ 
+ 	if ((argc == 3) && (strcmp(argv[1], "open") == 0)) {
+ 		TclObject* o = new X11Grabber(name_, argv[2]);
+ 		if (o != 0)
+ 			tcl.result(o->name());
+ 		return (TCL_OK);
+ 	}
+ 	return (InputDevice::command(argc, argv));
+ }
+ 
+ X11Grabber::X11Grabber(const char* name, const char* format)
+ {
+ 	c_grab = NULL ; /* XXX */
+ 	theroot_ = None ; /* XXX */
+ 	ximage_ = NULL ;
+ 	color = NULL ;
+ 	col2y_ = NULL ;
+ 	col2rgb16_ = NULL ;
+ 
+ 	width_ = 320 ;
+ 	height_ = 240 ;
+ 	x_origin_ = y_origin_ = 0 ; /* XXX */
+ 
+ 	if (strcmp(format, "422") && strcmp(format, "cif")) {
+ 		fprintf(stderr,
+ 			"vic: x11Grabber: unsupported format: %s\n",
+ 			format);
+ 		abort();
+ 	}
+ 
+ 	Tk_Window tkMainWin = Tcl::instance().tkmain() ;
+ 	Window rw ;
+ 
+ 	dpy_ = Tk_Display(tkMainWin);
+ 	rootwin_ = rw = RootWindow(dpy_, Tk_ScreenNumber(tkMainWin));
+ 
+ 	/* Initialize the RGB565 to YUV tables */
+ 	int i, r, g, b, y, u, v;
+ 
+ 	rgb2y_ = new uint8[65536] ;
+ 	rgb2u_ = (int8 *) new uint8[65536] ;
+ 	rgb2v_ = (int8 *) new uint8[65536] ;
+ 
+ 	i = 0;
+ 	for (r=4; r<256; r+=8) {
+ 	    for (g=3; g<256; g+=4) { /* XXX */
+ 		for (b=4; b<256; b+=8) {
+ 		    y = (38*r+75*g+15*b+64)/128;
+ 		    u = 74*(b-y)/128;
+ 		    if (u > 127) u = 127 ;
+ 		    else if (u< -128) u = -128 ;
+ 		    v = (93*(r-y)/128);
+ 		    if (v > 127) v = 127 ;
+ 		    else if (v< -128) v = -128 ;
+ 		    rgb2y_[i] = y ;
+ 		    rgb2u_[i] = u ^ 0x80 ; /* was u */
+ 		    rgb2v_[i] = v ^ 0x80 ;
+ 		    i++;
+ 		}
+ 	    }
+ 	}
+ 
+ 	X11Grab_Initialize(rw, width_, height_);
+ 
+ 	mode_ = X11GRAB_FIXED; /* XXX */
+ 	decimate_ = 1; /* XXX */
+ 	basewidth_ = PAL_WIDTH * 2;
+ 	baseheight_ = PAL_HEIGHT * 2;
+ 	
+ }
+ 
+ X11Grabber::~X11Grabber()
+ {
+         if (ximage_ != NULL)
+ 	    VidUtil_DestroyXImage(dpy_, ximage_);
+ 	free(rgb2y_);
+ 	free(rgb2u_);
+ 	free(rgb2v_);
+ }
+ 
+ void
+ X11Grabber::setsize()
+ {
+ 	int rows, columns;
+ 
+ 	rows = (baseheight_ / decimate_) &~0xf;	/* 0xf, ugh! */
+ 	columns = (basewidth_ / decimate_)  &~0xf;
+ 
+ 	/* XXX set size of captured window ? */
+ 
+ 	set_size_422(columns, rows); /* was 422... */
+ 	X11Grab_Initialize(rootwin_, columns, rows); /* XXX */
+ 
+ 	allocref();	/* allocate reference frame */
+ }
+ 
+ void
+ X11Grabber::format()
+ {
+ 
+ 	baseheight_ = CIF_HEIGHT * 2;
+ 	basewidth_ = CIF_WIDTH * 2;
+ 		
+ 	setsize();
+ }
+ 
+ 
+ void
+ X11Grabber::start()
+ {
+ 	format();
+ 	/* XXX prepare for continuous capture */
+ 	Grabber::start();
+ }
+ 
+ void
+ X11Grabber::stop()
+ {
+ 	/* XXX stop capture */
+ 	VidUtil_DestroyXImage(dpy_, ximage_);
+ 	ximage_ = NULL ;
+ 	Grabber::stop();
+ }
+ 
+ int
+ X11Grabber::command(int argc, const char*const* argv)
+ {
+     if (argc >= 3) {
+ 	if (strcmp(argv[1], "decimate") == 0) {
+ 	    int dec = atoi(argv[2]);
+ 	    Tcl& tcl = Tcl::instance();
+ 	    if (dec <= 0) {
+ 		tcl.resultf("%s: divide by zero", argv[0]);
+ 		    return (TCL_ERROR);
+ 	    }
+ 	    if (dec != decimate_) {
+ 		decimate_ = dec;
+ 		if(running_) {
+ 		    stop();
+ 		    setsize();
+ 		    start();
+ 		}
+ 	    }
+ 	    return (TCL_OK);	
+ 	} else if (strcmp(argv[1], "fixed") == 0) {
+ 	    mode_ = X11GRAB_FIXED;
+ 
+ 	    int x = atoi(argv[2]);
+ 	    int y = atoi(argv[3]);
+ 	    if (x >= 0 && *argv[2] != '-' && x + width_ <= root_width)
+ 		x_origin_ = x ;
+ 	    else if ( x <= 0 && -x + width_ <= root_width )
+ 		x_origin_ = root_width + x - width_ ;
+ 	    if (y >= 0 && *argv[3] != '-' && y + height_ <= root_height)
+ 		y_origin_ = y ;
+ 	    else if (y <= 0 && -y + height_ <= root_height )
+ 		y_origin_ = root_height + y - height_ ;
+ 	    fprintf(stderr, "x11 fixed %d %d (root %dx%d)\n",
+ 		x_origin_, y_origin_, root_width, root_height);
+ 	    return (TCL_OK);
+ 	} else if (!strcmp(argv[2], "pointer")) {
+ 	    mode_ = X11GRAB_POINTER;
+ 	    return (TCL_OK);
+ 	} else if (!strcmp(argv[2], "window")) {
+ 	    mode_ = X11GRAB_WINDOW;
+ 	    return (TCL_OK);
+ 	} else if (strcmp(argv[1], "format") == 0 ||
+ 		   strcmp(argv[1], "type") == 0) {
+ 	    if (running_)
+ 		format();
+ 	    return (TCL_OK);	
+ 	} else if (strcmp(argv[1], "contrast") == 0) {
+ 	    contrast(atof(argv[2]));
+ 	    return (TCL_OK);	
+ 	}
+     } else if (argc == 2) {
+ 	if (strcmp(argv[1], "format") == 0 ||
+ 	       strcmp(argv[1], "type") == 0) {
+ 	    return (TCL_OK);
+ 	}
+     }
+     return (Grabber::command(argc, argv));
+ }
+ 
+ /*
+  * captures in CIF or 411 -- color info is half the luma info.
+  */
+ int
+ X11Grabber::capture()
+ {
+     int dograb = 0 ;
+ 
+ #define MY_T	uint8
+ 
+ 
+     switch (mode_) {
+     case X11GRAB_FIXED:
+         dograb = 1;
+         break;
+ #if 0 /* not yet... */
+     case X11GRAB_POINTER:
+         dograb = X11Grab_FollowPointer();
+         break;
+     case X11GRAB_WINDOW:
+         dograb = X11Grab_FollowWindow();
+         break;
+ #endif
+     }
+     
+     if (1 || dograb) {
+ 	XImage *image=ximage_->image;
+ 
+ #ifdef USE_SHM
+ 	if (ximage_->shminfo != NULL)
+ 	    XShmGetImage(dpy_, theroot_, image, x_origin_, y_origin_,AllPlanes);
+ 	else
+ #endif
+ 	    XGetSubImage(dpy_, theroot_, x_origin_, y_origin_,
+ 		image->width, image->height, AllPlanes,
+ 		     ZPixmap, image, 0, 0);
+         (this->*c_grab)();
+ 	return 1 ;
+     } else
+         return 0;
+ }
+ 
+ int X11Grabber::grab()
+ {
+     if (capture() == 0)
+ 	return (0);
+     suppress(frame_);
+     saveblks(frame_);
+     YuvFrame f(media_ts(), frame_, crvec_, outw_, outh_);
+     return (target_->consume(&f));
+ }
+ 
+ extern "C" {
+ 
+ #include <sys/ipc.h>
+ #ifdef USE_SHM
+ #include <sys/shm.h>
+ #if defined(sun) && !defined(__svr4__)
+ int shmget(key_t, int, int);
+ char *shmat(int, char*, int);
+ int shmdt(char*);
+ int shmctl(int, int, struct shmid_ds*);
+ #endif
+ #ifdef __osf__
+ int XShmGetEventBase(struct _XDisplay *);
+ #else
+ int XShmGetEventBase(Display *);
+ #endif
+ #ifdef sgi
+ #define XShmAttach __XShmAttach__
+ #define XShmDetach __XShmDetach__
+ #define XShmPutImage __XShmPutImage__
+ #endif
+ #include <X11/extensions/XShm.h>
+ #ifdef sgi
+ #undef XShmAttach
+ #undef XShmDetach
+ #undef XShmPutImage
+ int XShmAttach(Display*, XShmSegmentInfo*);
+ int XShmDetach(Display*, XShmSegmentInfo*);
+ int XShmPutImage(Display*, Drawable, GC, XImage*, int, int, int, int,
+                  int, int, int);
+ #endif
+ #endif
+ 
+ 
+ /*ARGSUSED*/
+ static int
+ ErrHandler(ClientData clientData, XErrorEvent *errevp)
+ {
+     return 0;
+ }
+ 
+ ximage_t *
+ VidUtil_AllocXImage(Display *dpy, Visual *vis, int depth, int width,
+ 			      int height, int readonly)
+ {
+     ximage_t *ximage;
+     int ximage_size;
+     Tk_ErrorHandler handler;
+ 
+     ximage = (ximage_t *) malloc(sizeof(ximage_t));
+     if (ximage == NULL)
+ 	return NULL;
+ 
+ #ifdef USE_SHM
+     if (1) {
+ 	XShmSegmentInfo *shminfo;
+ 
+ 	ximage->shminfo = shminfo =
+ 	    (XShmSegmentInfo *) malloc(sizeof(XShmSegmentInfo));
+ 
+ 	ximage->image = XShmCreateImage(dpy, vis, depth, ZPixmap, 0, shminfo,
+ 					width, height);
+ 	ximage_size = ximage->image->bytes_per_line * ximage->image->height;
+ 
+ 	shminfo->shmid = shmget(IPC_PRIVATE, ximage_size, IPC_CREAT|0777);
+ 	if (shminfo->shmid != -1) {
+ 	    shminfo->shmaddr = ximage->image->data =
+ 		(char *) shmat(shminfo->shmid, 0, 0);
+ 	    shminfo->readOnly = readonly;
+ 
+ 	    handler = Tk_CreateErrorHandler(dpy, -1, -1, -1, ErrHandler, NULL);
+ 	    XShmAttach(dpy, shminfo);
+ 	    XSync(dpy, False);
+ 	    shmctl(shminfo->shmid, IPC_RMID, 0); /* so it goes away on exit */
+ 	    Tk_DeleteErrorHandler(handler);
+ 	    if (0) { /* so it goes away on exit... */
+ 		shmdt(shminfo->shmaddr);
+ 		shmctl(shminfo->shmid, IPC_RMID, 0);
+ 		XDestroyImage(ximage->image);
+ 		free(shminfo);
+ 	    }
+ 	    return ximage;
+ 	} else {
+ 	    XDestroyImage(ximage->image);
+ 	    free(shminfo);
+ 	    ximage->shminfo = NULL ;
+ 	    /* XXX hmmm... something more ? */
+ 	}
+     }
+ #endif
+     {
+ 	ximage->image = XCreateImage(dpy, vis, depth, ZPixmap, 0, NULL, width,
+ 				     height, (depth == 24) ? 32 : depth, 0);
+ 	ximage_size = ximage->image->bytes_per_line * ximage->image->height;
+ 	ximage->image->data = (char *) malloc(ximage_size);
+ 
+ 	ximage->shminfo = NULL;
+     }
+ 
+     return ximage;
+ }
+ 
+ void
+ VidUtil_DestroyXImage(Display *dpy, ximage_t *ximage)
+ {
+ #ifdef USE_SHM
+     if (ximage->shminfo != NULL) {
+ 	XShmSegmentInfo *shminfo=(XShmSegmentInfo *)ximage->shminfo;
+ 
+ 	XShmDetach(dpy, shminfo);
+ 	shmdt(shminfo->shmaddr);
+ 	shmctl(shminfo->shmid, IPC_RMID, 0);
+ 	free(shminfo);
+     }
+     ximage->shminfo = NULL ;
+ #endif
+ 
+     XDestroyImage(ximage->image);
+     free(ximage);
+ }
+ 
+ 
+ } /* end extern "C" block */
*** ./config.guess.orig	Sun May  7 17:26:33 1995
--- ./config.guess	Thu Jul 15 09:35:26 1999
***************
*** 284,289 ****
--- 284,292 ----
      i[34]86:BSD/386:*:* | *:BSD/OS:*:*)
  	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
  	exit 0 ;;
+     *:OpenBSD:*:*)
+ 	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+ 	exit 0 ;;
      *:FreeBSD:*:*)
  	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
  	exit 0 ;;
*** ./config.h.orig	Thu May 16 07:27:06 1996
--- ./config.h	Thu Jul 15 09:35:26 1999
***************
*** 36,42 ****
  #ifndef vic_config_h
  #define vic_config_h
  
! #if defined(sgi) || defined(__bsdi__) || defined(__FreeBSD__)
  #include <sys/types.h>
  #elif defined(linux)
  #include <sys/bitypes.h>
--- 36,42 ----
  #ifndef vic_config_h
  #define vic_config_h
  
! #if defined(sgi) || defined(__bsdi__) || defined(__FreeBSD__) || defined(__OpenBSD__)
  #include <sys/types.h>
  #elif defined(linux)
  #include <sys/bitypes.h>
***************
*** 83,89 ****
  #include <arpa/inet.h>
  int strcasecmp(const char *, const char *);
  clock_t clock(void);
! #if !defined(sco) && !defined(sgi) && !defined(__bsdi__) && !defined(__FreeBSD__)
  int gethostid(void);
  #endif
  time_t time(time_t *);
--- 83,89 ----
  #include <arpa/inet.h>
  int strcasecmp(const char *, const char *);
  clock_t clock(void);
! #if !defined(sco) && !defined(sgi) && !defined(__bsdi__) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
  int gethostid(void);
  #endif
  time_t time(time_t *);
*** ./net-ip.cc.orig	Wed Jun 26 19:56:39 1996
--- ./net-ip.cc	Thu Jul 15 09:35:26 1999
***************
*** 204,210 ****
  	memset((char *)p, 0, sizeof(*p));
  	p->sin_family = AF_INET;
  	int len = sizeof(*p);
! 	if (getsockname(ssock_, (struct sockaddr *)p, &len) < 0) {
  		perror("getsockname");
  		p->sin_addr.s_addr = 0;
  		p->sin_port = 0;
--- 204,210 ----
  	memset((char *)p, 0, sizeof(*p));
  	p->sin_family = AF_INET;
  	int len = sizeof(*p);
! 	if (getsockname(ssock_, (struct sockaddr *)p, (socklen_t *) &len) < 0) {
  		perror("getsockname");
  		p->sin_addr.s_addr = 0;
  		p->sin_port = 0;
*** ./iohandler.cc.orig	Sat May 18 13:27:23 1996
--- ./iohandler.cc	Thu Jul 15 09:35:26 1999
***************
*** 132,138 ****
  	    
          }
  #else
! 	Tk_CreateFileHandler((ClientData)fd, mask, callback, (ClientData)this);
  #endif
  }
  
--- 132,138 ----
  	    
          }
  #else
! 	Tk_CreateFileHandler((int)(ClientData)fd, mask, callback, (ClientData)this);
  #endif
  }
  
***************
*** 151,157 ****
  	}
  #else
  	if (fd_ >= 0) {
! 		Tk_DeleteFileHandler((ClientData)fd_);
  		fd_ = -1;
  	}
  #endif
--- 151,157 ----
  	}
  #else
  	if (fd_ >= 0) {
! 		Tk_DeleteFileHandler((int)(ClientData)fd_);
  		fd_ = -1;
  	}
  #endif
*** ./transcoder-jpeg.cc.orig	Tue Nov 14 00:46:58 1995
--- ./transcoder-jpeg.cc	Thu Jul 15 09:35:26 1999
***************
*** 138,144 ****
  	rval = target_->consume(df);
  
  	// update CR vec
! 	register blkno;
  	int s;
  	for (blkno = 0; blkno < crvlen_; blkno++) {
  		s = CR_STATE(crvec_[blkno]);
--- 138,144 ----
  	rval = target_->consume(df);
  
  	// update CR vec
! 	register long blkno;
  	int s;
  	for (blkno = 0; blkno < crvlen_; blkno++) {
  		s = CR_STATE(crvec_[blkno]);
*** ./color-true.cc.orig	Mon Mar  4 06:32:13 1996
--- ./color-true.cc	Thu Jul 15 09:35:26 1999
***************
*** 180,186 ****
  protected:
  	TrueColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = TrueMethod(WindowRenderer::dither_null); }
  	TrueMethod method_;
  	void map_422(const u_char* frm, u_int off, u_int x,
  		     u_int width, u_int height) const;
--- 180,186 ----
  protected:
  	TrueColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = TrueMethod(& WindowRenderer::dither_null); }
  	TrueMethod method_;
  	void map_422(const u_char* frm, u_int off, u_int x,
  		     u_int width, u_int height) const;
*** ./color-dither.cc.orig	Tue Nov 14 00:46:09 1995
--- ./color-dither.cc	Thu Jul 15 09:35:26 1999
***************
*** 177,183 ****
  protected:
  	DitherColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = PseudoWindowRenderer::dither_null; }
  	DitherMethod method_;
  	void dither_422(const u_char* frm, u_int off, u_int x,
  			u_int width, u_int height) const;
--- 177,183 ----
  protected:
  	DitherColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = &PseudoWindowRenderer::dither_null; }
  	DitherMethod method_;
  	void dither_422(const u_char* frm, u_int off, u_int x,
  			u_int width, u_int height) const;
*** ./color-ed.cc.orig	Tue Nov 14 00:46:10 1995
--- ./color-ed.cc	Thu Jul 15 09:35:26 1999
***************
*** 180,186 ****
  protected:
  	EDColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = PseudoWindowRenderer::dither_null; }
  	EDMethod method_;
  	void dither_422(const u_char* frm, u_int off, u_int x,
  			u_int width, u_int height) const;
--- 180,186 ----
  protected:
  	EDColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = &PseudoWindowRenderer::dither_null; }
  	EDMethod method_;
  	void dither_422(const u_char* frm, u_int off, u_int x,
  			u_int width, u_int height) const;
*** ./color-quant.cc.orig	Thu Feb 15 22:21:16 1996
--- ./color-quant.cc	Thu Jul 15 09:35:26 1999
***************
*** 92,98 ****
  protected:
  	QuantColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = PseudoWindowRenderer::dither_null; }
  	QuantMethod method_;
  	void map_422(const u_char* frm, u_int off, u_int x,
  		     u_int width, u_int height) const;
--- 92,98 ----
  protected:
  	QuantColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = &PseudoWindowRenderer::dither_null; }
  	QuantMethod method_;
  	void map_422(const u_char* frm, u_int off, u_int x,
  		     u_int width, u_int height) const;
*** ./color-hi.cc.orig	Thu May 16 07:42:44 1996
--- ./color-hi.cc	Thu Jul 15 09:35:26 1999
***************
*** 164,170 ****
      protected:
  	HiColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = HiMethod(WindowRenderer::dither_null); }
  	HiMethod method_;
  	void map_422(const u_char* frm, u_int off, u_int x,
  		     u_int width, u_int height) const;
--- 164,170 ----
      protected:
  	HiColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = HiMethod(&WindowRenderer::dither_null); }
  	HiMethod method_;
  	void map_422(const u_char* frm, u_int off, u_int x,
  		     u_int width, u_int height) const;
*** ./color-gray.cc.orig	Tue Nov 14 00:46:10 1995
--- ./color-gray.cc	Thu Jul 15 09:35:26 1999
***************
*** 82,88 ****
  	}
  protected:
  	virtual void update();
! 	virtual void disable() { method_ = PseudoWindowRenderer::dither_null; }
  	GrayMethod method_;
  };
  
--- 82,88 ----
  	}
  protected:
  	virtual void update();
! 	virtual void disable() { method_ = &PseudoWindowRenderer::dither_null; }
  	GrayMethod method_;
  };
  
*** ./color-mono.cc.orig	Mon Nov 13 21:14:31 1995
--- ./color-mono.cc	Thu Jul 15 09:35:27 1999
***************
*** 200,206 ****
  	~MonoColorModel();
  	virtual int alloc_grays();
  	virtual int command(int argc, const char*const* argv);
! 	inline white(void) { return (white_); }
  private:
  	int white_;
  };
--- 200,206 ----
  	~MonoColorModel();
  	virtual int alloc_grays();
  	virtual int command(int argc, const char*const* argv);
! 	inline int white(void) { return (white_); }
  private:
  	int white_;
  };
***************
*** 250,256 ****
  protected:
  	MonoColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = WindowDitherer::dither_null; }
  	MonoMethod method_;
  	void dither(const u_char* frm, u_int off, u_int x,
  		    u_int width, u_int height) const;
--- 250,256 ----
  protected:
  	MonoColorModel& cm_;
  	virtual void update();
! 	virtual void disable() { method_ = &WindowDitherer::dither_null; }
  	MonoMethod method_;
  	void dither(const u_char* frm, u_int off, u_int x,
  		    u_int width, u_int height) const;
