$OpenBSD: patch-hotspot_agent_src_os_bsd_ps_proc_c,v 1.1 2009/06/10 19:01:09 kurt Exp $
--- hotspot/agent/src/os/bsd/ps_proc.c.orig	Tue Jun  2 13:07:59 2009
+++ hotspot/agent/src/os/bsd/ps_proc.c	Tue Jun  2 13:20:36 2009
@@ -22,21 +22,23 @@
  *
  */
 
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 #include <sys/ptrace.h>
+#include <sys/param.h>
+#include <sys/user.h>
+#include <elf.h>
+#include <sys/elf_common.h>
+#include <sys/link_elf.h>
+#include <libutil.h>
 #include "libproc_impl.h"
+#include "elfmacros.h"
 
-#if defined(x86_64) && !defined(amd64)
-#define amd64 1
-#endif
-
-#ifndef __WALL
-#define __WALL          0x40000000  // Copied from /usr/include/bsd/wait.h
-#endif
-
 // This file has the libproc implementation specific to live process
 // For core files, refer to ps_core.c
 
@@ -50,251 +52,359 @@ static inline uintptr_t align(uintptr_t ptr, size_t si
 
 // read "size" bytes of data from "addr" within the target process.
 // unlike the standard ptrace() function, process_read_data() can handle
-// unaligned address - alignment check, if required, should be done
+// unaligned address - alignment check, if required, should be done 
 // before calling process_read_data.
 
 static bool process_read_data(struct ps_prochandle* ph, uintptr_t addr, char *buf, size_t size) {
-  long rslt;
+  int rslt;
   size_t i, words;
   uintptr_t end_addr = addr + size;
-  uintptr_t aligned_addr = align(addr, sizeof(long));
+  uintptr_t aligned_addr = align(addr, sizeof(int));
 
   if (aligned_addr != addr) {
     char *ptr = (char *)&rslt;
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
     for (; aligned_addr != addr; aligned_addr++, ptr++);
-    for (; ((intptr_t)aligned_addr % sizeof(long)) && aligned_addr < end_addr;
-        aligned_addr++)
+    for (; ((intptr_t)aligned_addr % sizeof(int)) && aligned_addr < end_addr; 
+        aligned_addr++) 
        *(buf++) = *(ptr++);
   }
 
-  words = (end_addr - aligned_addr) / sizeof(long);
+  words = (end_addr - aligned_addr) / sizeof(int);
 
-  // assert((intptr_t)aligned_addr % sizeof(long) == 0);
+  // assert((intptr_t)aligned_addr % sizeof(int) == 0);
   for (i = 0; i < words; i++) {
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
-    *(long *)buf = rslt;
-    buf += sizeof(long);
-    aligned_addr += sizeof(long);
+    *(int *)buf = rslt;
+    buf += sizeof(int);
+    aligned_addr += sizeof(int);
   }
 
   if (aligned_addr != end_addr) {
     char *ptr = (char *)&rslt;
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
-    for (; aligned_addr != end_addr; aligned_addr++)
+    for (; aligned_addr != end_addr; aligned_addr++) 
        *(buf++) = *(ptr++);
   }
   return true;
 }
 
 // null implementation for write
-static bool process_write_data(struct ps_prochandle* ph,
+static bool process_write_data(struct ps_prochandle* ph, 
                              uintptr_t addr, const char *buf , size_t size) {
   return false;
 }
 
-// "user" should be a pointer to a user_regs_struct
-static bool process_get_lwp_regs(struct ps_prochandle* ph, pid_t pid, struct user_regs_struct *user) {
+// "user" should be a pointer to a reg
+static bool process_get_lwp_regs(struct ps_prochandle* ph, pid_t pid, struct reg *user) {
   // we have already attached to all thread 'pid's, just use ptrace call
   // to get regset now. Note that we don't cache regset upfront for processes.
-// Bsd on x86 and sparc are different.  On x86 ptrace(PTRACE_GETREGS, ...)
-// uses pointer from 4th argument and ignores 3rd argument.  On sparc it uses
-// pointer from 3rd argument and ignores 4th argument
-#if defined(sparc) || defined(sparcv9)
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, addr, data)
-#else
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, data, addr)
-#endif
-
-#ifdef _LP64
-#ifdef PTRACE_GETREGS64
-#define PTRACE_GETREGS_REQ PTRACE_GETREGS64
-#endif
-#else
-#if defined(PTRACE_GETREGS) || defined(PT_GETREGS)
-#define PTRACE_GETREGS_REQ PTRACE_GETREGS
-#endif
-#endif /* _LP64 */
-
-#ifdef PTRACE_GETREGS_REQ
- if (ptrace_getregs(PTRACE_GETREGS_REQ, pid, user, NULL) < 0) {
+ if (ptrace(PT_GETREGS, pid, (caddr_t) user, 0) < 0) {
    print_debug("ptrace(PTRACE_GETREGS, ...) failed for lwp %d\n", pid);
    return false;
  }
  return true;
-#else
- print_debug("ptrace(PTRACE_GETREGS, ...) not supported\n");
- return false;
-#endif
+}
 
+// fill in ptrace_lwpinfo for lid
+static bool process_get_lwp_info(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+  errno = 0;
+  ptrace(PT_LWPINFO, lwp_id, linfo, sizeof(struct ptrace_lwpinfo));
+
+  return (errno == 0)? true: false;
 }
 
 // attach to a process/thread specified by "pid"
 static bool ptrace_attach(pid_t pid) {
-  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {
+  if (ptrace(PT_ATTACH, pid, NULL, 0) < 0) {
     print_debug("ptrace(PTRACE_ATTACH, ..) failed for %d\n", pid);
     return false;
   } else {
     int ret;
     int status;
     do {
-      // Wait for debuggee to stop.
+      // Wait for debuggee to stop. 
       ret = waitpid(pid, &status, 0);
-      if (ret == -1 && errno == ECHILD) {
-        // try cloned process.
-        ret = waitpid(pid, &status, __WALL);
-      }
       if (ret >= 0) {
-        if (WIFSTOPPED(status)) {
-          // Debuggee stopped.
-          return true;
+	if (WIFSTOPPED(status)) {
+	  // Debuggee stopped.
+	  return true;
         } else {
-          print_debug("waitpid(): Child process exited/terminated (status = 0x%x)\n", status);
-          return false;
-        }
+    	  print_debug("waitpid(): Child process exited/terminated (status = 0x%x)\n", status);
+	  return false;
+	}
       } else {
-        switch (errno) {
-          case EINTR:
+	switch (errno) {
+	  case EINTR: 
             continue;
-            break;
-          case ECHILD:
-            print_debug("waitpid() failed. Child process pid (%d) does not exist \n", pid);
-            break;
-          case EINVAL:
-            print_debug("waitpid() failed. Invalid options argument.\n");
-            break;
-          default:
-            print_debug("waitpid() failed. Unexpected error %d\n",errno);
+	    break;
+	  case ECHILD:
+    	    print_debug("waitpid() failed. Child process pid (%d) does not exist \n", pid);
+	    break;
+	  case EINVAL:
+    	    print_debug("waitpid() failed. Invalid options argument.\n");
+	    break;
+	  default:
+    	    print_debug("waitpid() failed. Unexpected error %d\n",errno);
         }
         return false;
-      }
+      } 
     } while(true);
-  }
-}
-
+  } 
+} 
+  
 // -------------------------------------------------------
 // functions for obtaining library information
 // -------------------------------------------------------
 
+// callback for read_thread_info
+static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
+  return add_thread_info(ph, pthread_id, lwp_id) != NULL;
+}
+
+#if defined(__FreeBSD__) && __FreeBSD_version < 701000
 /*
- * splits a string _str_ into substrings with delimiter _delim_ by replacing old * delimiters with _new_delim_ (ideally, '\0'). the address of each substring
- * is stored in array _ptrs_ as the return value. the maximum capacity of _ptrs_ * array is specified by parameter _n_.
- * RETURN VALUE: total number of substrings (always <= _n_)
- * NOTE: string _str_ is modified if _delim_!=_new_delim_
+ * TEXT_START_ADDR from binutils/ld/emulparams/<arch_spec>.sh
+ * Not the most robust but good enough.
  */
-static int split_n_str(char * str, int n, char ** ptrs, char delim, char new_delim)
-{
-   int i;
-   for(i = 0; i < n; i++) ptrs[i] = NULL;
-   if (str == NULL || n < 1 ) return 0;
 
-   i = 0;
+#if defined(amd64) || defined(x86_64)
+#define TEXT_START_ADDR 0x400000
+#elif defined(i386)
+#define TEXT_START_ADDR 0x8048000
+#else
+#error TEXT_START_ADDR not defined
+#endif
 
-   // skipping leading blanks
-   while(*str&&*str==delim) str++;
+#define BUF_SIZE (PATH_MAX + NAME_MAX + 1)
 
-   while(*str&&i<n){
-     ptrs[i++] = str;
-     while(*str&&*str!=delim) str++;
-     while(*str&&*str==delim) *(str++) = new_delim;
-   }
+uintptr_t linkmap_addr(struct ps_prochandle *ph) {
+  uintptr_t ehdr_addr, phdr_addr, dyn_addr, dmap_addr, lmap_addr;
+  ELF_EHDR ehdr;
+  ELF_PHDR *phdrs, *phdr;
+  ELF_DYN *dyns, *dyn;
+  struct r_debug dmap;
+  unsigned long hdrs_size;
+  unsigned int i;
 
-   return i;
-}
+  /* read ELF_EHDR at TEXT_START_ADDR and validate */
 
-/*
- * fgets without storing '\n' at the end of the string
- */
-static char * fgets_no_cr(char * buf, int n, FILE *fp)
-{
-   char * rslt = fgets(buf, n, fp);
-   if (rslt && buf && *buf){
-       char *p = strchr(buf, '\0');
-       if (*--p=='\n') *p='\0';
-   }
-   return rslt;
-}
+  ehdr_addr = (uintptr_t)TEXT_START_ADDR;
 
-// callback for read_thread_info
-static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
-  return add_thread_info(ph, pthread_id, lwp_id) != NULL;
+  if (process_read_data(ph, ehdr_addr, (char *)&ehdr, sizeof(ehdr)) != true) {
+    print_debug("process_read_data failed for ehdr_addr %p\n", ehdr_addr);
+    return (0);
+  }
+
+  if (!IS_ELF(ehdr) ||
+        ehdr.e_ident[EI_CLASS] != ELF_TARG_CLASS ||
+        ehdr.e_ident[EI_DATA] != ELF_TARG_DATA ||
+        ehdr.e_ident[EI_VERSION] != EV_CURRENT ||
+        ehdr.e_phentsize != sizeof(ELF_PHDR) ||
+        ehdr.e_version != ELF_TARG_VER ||
+        ehdr.e_machine != ELF_TARG_MACH) {
+    print_debug("not an ELF_EHDR at %p\n", ehdr_addr);
+    return (0);
+  }
+
+  /* allocate space for all ELF_PHDR's and read */
+
+  phdr_addr = ehdr_addr + ehdr.e_phoff;
+  hdrs_size = ehdr.e_phnum * sizeof(ELF_PHDR);
+
+  if ((phdrs = malloc(hdrs_size)) == NULL)
+    return (0);
+
+  if (process_read_data(ph, phdr_addr, (char *)phdrs, hdrs_size) != true) {
+    print_debug("process_read_data failed for phdr_addr %p\n", phdr_addr);
+    return (0);
+  }
+
+  /* find PT_DYNAMIC section */
+
+  for (i = 0, phdr = phdrs; i < ehdr.e_phnum; i++, phdr++) {
+    if (phdr->p_type == PT_DYNAMIC)
+      break;
+  }
+
+  if (i >= ehdr.e_phnum) {
+    print_debug("PT_DYNAMIC section not found!\n");
+    free(phdrs);
+    return (0);
+  }
+
+  /* allocate space and read in ELF_DYN headers */
+
+  dyn_addr = phdr->p_vaddr;
+  hdrs_size = phdr->p_memsz;
+  free(phdrs);
+
+  if ((dyns = malloc(hdrs_size)) == NULL)
+    return (0);
+
+  if (process_read_data(ph, dyn_addr, (char *)dyns, hdrs_size) != true) {
+    print_debug("process_read_data failed for dyn_addr %p\n", dyn_addr);
+    free(dyns);
+    return (0);
+  }
+
+  /* find DT_DEBUG */
+  
+  dyn = dyns;
+  while (dyn->d_tag != DT_DEBUG && dyn->d_tag != DT_NULL) {
+    dyn++;
+  }
+
+  if (dyn->d_tag != DT_DEBUG) {
+    print_debug("failed to find DT_DEBUG\n");
+    free(dyns);
+    return (0);
+  }
+
+  /* read struct r_debug into dmap */
+
+  dmap_addr = (uintptr_t)dyn->d_un.d_ptr;
+  free(dyns);
+
+  if (process_read_data(ph, dmap_addr, (char *)&dmap, sizeof(dmap)) != true) {
+    print_debug("process_read_data failed for dmap_addr %p\n", dmap_addr);
+    return (0);
+  }
+
+  lmap_addr = (uintptr_t)dmap.r_map;
+
+  return (lmap_addr);
 }
+#endif // __FreeBSD__ && __FreeBSD_version < 701000
 
 static bool read_lib_info(struct ps_prochandle* ph) {
-  char fname[32];
-  char buf[256];
-  FILE *fp = NULL;
+#if defined(__FreeBSD__) && __FreeBSD_version >= 701000
+  struct kinfo_vmentry *freep, *kve;
+  int i, cnt;
 
-  sprintf(fname, "/proc/%d/maps", ph->pid);
-  fp = fopen(fname, "r");
-  if (fp == NULL) {
-    print_debug("can't open /proc/%d/maps file\n", ph->pid);
-    return false;
+  freep = kinfo_getvmmap(ph->pid, &cnt);
+  if (freep == NULL) {
+      print_debug("can't get vm map for pid\n", ph->pid);
+      return false;
   }
 
-  while(fgets_no_cr(buf, 256, fp)){
-    char * word[6];
-    int nwords = split_n_str(buf, 6, word, ' ', '\0');
-    if (nwords > 5 && find_lib(ph, word[5]) == false) {
-       intptr_t base;
-       lib_info* lib;
-       sscanf(word[0], "%lx", &base);
-       if ((lib = add_lib_info(ph, word[5], (uintptr_t)base)) == NULL)
+  for (i = 0; i < cnt; i++) {
+    kve = &freep[i];
+    if ((kve->kve_flags & KVME_FLAG_COW) &&
+        kve->kve_path != NULL &&
+        strlen(kve->kve_path) > 0) {
+
+      if (find_lib(ph, kve->kve_path) == false) {
+        lib_info* lib;
+        if ((lib = add_lib_info(ph, kve->kve_path,
+                                (uintptr_t) kve->kve_start)) == NULL)
           continue; // ignore, add_lib_info prints error
 
-       // we don't need to keep the library open, symtab is already
-       // built. Only for core dump we need to keep the fd open.
-       close(lib->fd);
-       lib->fd = -1;
+        // we don't need to keep the library open, symtab is already
+        // built. Only for core dump we need to keep the fd open.
+        close(lib->fd);
+        lib->fd = -1;
+      }
     }
   }
-  fclose(fp);
+
+  free(freep);
+
   return true;
+#else
+  char *l_name;
+  struct link_map *lmap;
+  uintptr_t lmap_addr;
+
+  if ((l_name = malloc(BUF_SIZE)) == NULL)
+    return false;
+
+  if ((lmap = malloc(sizeof(*lmap))) == NULL) {
+    free(l_name);
+    return false;
+  }
+
+  lmap_addr = linkmap_addr(ph);
+
+  if (lmap_addr == 0) {
+    free(l_name);
+    free(lmap);
+    return false;
+  }
+
+  do {
+    if (process_read_data(ph, lmap_addr, (char *)lmap, sizeof(*lmap)) != true) {
+      print_debug("process_read_data failed for lmap_addr %p\n", lmap_addr);
+      free (l_name);
+      free (lmap);
+      return false;
+    }
+
+    if (process_read_data(ph, (uintptr_t)lmap->l_name, l_name,
+        BUF_SIZE) != true) {
+      print_debug("process_read_data failed for lmap->l_name %p\n",
+          lmap->l_name);
+      free (l_name);
+      free (lmap);
+      return false;
+    }
+
+    if (find_lib(ph, l_name) == false) {
+      lib_info* lib;
+      if ((lib = add_lib_info(ph, l_name,
+                              (uintptr_t) lmap->l_addr)) == NULL)
+        continue; // ignore, add_lib_info prints error
+
+      // we don't need to keep the library open, symtab is already
+      // built. Only for core dump we need to keep the fd open.
+      close(lib->fd);
+      lib->fd = -1;
+    }
+    lmap_addr = (uintptr_t)lmap->l_next;
+  } while (lmap->l_next != NULL);
+
+  free (l_name);
+  free (lmap);
+
+  return true;
+#endif
 }
 
 // detach a given pid
 static bool ptrace_detach(pid_t pid) {
-  if (pid && ptrace(PTRACE_DETACH, pid, NULL, NULL) < 0) {
+  if (pid && ptrace(PT_DETACH, pid, (caddr_t)1, 0) < 0) {
     print_debug("ptrace(PTRACE_DETACH, ..) failed for %d\n", pid);
     return false;
   } else {
     return true;
-  }
+  } 
 }
 
-// detach all pids of a ps_prochandle
-static void detach_all_pids(struct ps_prochandle* ph) {
-  thread_info* thr = ph->threads;
-  while (thr) {
-     ptrace_detach(thr->lwp_id);
-     thr = thr->next;
-  }
-}
-
 static void process_cleanup(struct ps_prochandle* ph) {
-  detach_all_pids(ph);
+  ptrace_detach(ph->pid);
 }
 
 static ps_prochandle_ops process_ops = {
   .release=  process_cleanup,
   .p_pread=  process_read_data,
   .p_pwrite= process_write_data,
-  .get_lwp_regs= process_get_lwp_regs
+  .get_lwp_regs= process_get_lwp_regs,
+  .get_lwp_info= process_get_lwp_info
 };
 
 // attach to the process. One and only one exposed stuff
@@ -321,21 +431,14 @@ struct ps_prochandle* Pgrab(pid_t pid) {
   // read library info and symbol tables, must do this before attaching threads,
   // as the symbols in the pthread library will be used to figure out
   // the list of threads within the same process.
-  read_lib_info(ph);
-
+  if (read_lib_info(ph) != true) {
+     ptrace_detach(pid);
+     free(ph);
+     return NULL;
+  }
+ 
   // read thread info
   read_thread_info(ph, add_new_thread);
 
-  // attach to the threads
-  thr = ph->threads;
-  while (thr) {
-     // don't attach to the main thread again
-     if (ph->pid != thr->lwp_id && ptrace_attach(thr->lwp_id) != true) {
-        // even if one attach fails, we get return NULL
-        Prelease(ph);
-        return NULL;
-     }
-     thr = thr->next;
-  }
   return ph;
 }
