$OpenBSD: patch-src_lib_ioloop-notify-kqueue_c,v 1.1 2006/01/22 15:35:43 brad Exp $
--- src/lib/ioloop-notify-kqueue.c.orig	Sat Jan 14 18:27:11 2006
+++ src/lib/ioloop-notify-kqueue.c	Sun Jan 22 00:54:23 2006
@@ -15,11 +15,13 @@
 #ifdef IOLOOP_NOTIFY_KQUEUE
 
 #include "ioloop-internal.h"
+#include "fd-close-on-exec.h"
 #include <unistd.h>
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/event.h>
 #include <sys/time.h>
+#include <sys/stat.h>
 
 struct ioloop_notify_handler_context {
 	int kq;
@@ -54,6 +56,7 @@ void io_loop_notify_handler_init(struct 
 	ctx->kq = kqueue();
 	if (ctx->kq < 0)
 		i_fatal("kqueue() failed: %m");
+	fd_close_on_exec(ctx->kq, TRUE);
 }
 
 void io_loop_notify_handler_deinit(struct ioloop *ioloop)
@@ -62,7 +65,7 @@ void io_loop_notify_handler_deinit(struc
 		ioloop->notify_handler_context;
 
         if (ctx->event_io)
-                io_remove(ctx->event_io);
+		io_remove(&ctx->event_io);
 	if (close(ctx->kq) < 0)
 		i_error("close(kqueue notify) failed: %m");
 	p_free(ioloop->pool, ctx);
@@ -75,6 +78,11 @@ static void unchain_io (struct ioloop *i
 	for (io_p = &ioloop->notifys; *io_p != NULL; io_p = &(*io_p)->next) {
 		if (*io_p == io) {
 			*io_p = io->next;
+                        if (io->next) {
+                                io->next->prev = io->prev;
+                        }
+                        io->prev = NULL;
+                        io->next = NULL;
 			break;
 		}
 	}
@@ -89,18 +97,26 @@ struct io *io_loop_notify_add(struct iol
 			     NOTE_DELETE | NOTE_WRITE | NOTE_EXTEND
 			     | NOTE_REVOKE, 0, NULL };
 	struct io *io;
-	int fd;
+	int fd, ret;
+        struct stat sb;
 
+        i_assert(callback);
 	fd = open(path, O_RDONLY);
 	if (fd == -1) {
 		i_error("open(%s) for notify failed: %m", path);
 		return NULL;
 	}
+        fd_close_on_exec(fd, TRUE);
 
-	ev.ident = fd;
-	ev.udata = io;
-	if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) < 0) {
-		i_error("kevent(%s) for notify failed: %m", path);
+        ret = fstat(fd, &sb);
+        if (ret == -1) {
+                close(fd);
+                i_error("fstat(%d \"%s\") for notify failed: %m", fd, path);
+                return NULL;
+        }
+        if (! (sb.st_mode & S_IFDIR)) {
+                close(fd);
+                i_warning("notification works only for dirs (%s)", path);
 		return NULL;
 	}
 
@@ -108,7 +124,16 @@ struct io *io_loop_notify_add(struct iol
 	io->fd = fd;
 	io->callback = callback;
 	io->context = context;
+	ev.ident = fd;
+	ev.udata = io;
+	if (kevent(ctx->kq, &ev, 1, NULL, 0, NULL) < 0) {
+		i_error("kevent(%s) for notify failed: %m", path);
+		return NULL;
+	}
 	io->next = ioloop->notifys;
+        io->prev = NULL;
+        if (ioloop->notifys)
+                ioloop->notifys->prev = io;
 	ioloop->notifys = io;
 
 	if (ctx->event_io == NULL) {
@@ -127,12 +152,14 @@ void io_loop_notify_remove(struct ioloop
 	struct kevent ev = { io->fd, 0, EV_DELETE, 0, 0, NULL };
 	int ret;
 
+        if (!(fcntl(io->fd, F_GETFD, 0) != -1 || errno != EBADF)) {
 	unchain_io(ioloop, io);
 	p_free(ioloop->pool, io);
-
 	ret = kevent(ctx->kq, &ev, 1, NULL, 0, 0);
 	if (ret == -1)
-		i_error("kevent() for notify failed: %m");
+                        i_error("kevent() for notify remove failed, "
+                                "but fd:%d is valid: %m", io->fd);
+        }
 }
 
 #endif
