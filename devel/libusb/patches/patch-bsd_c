$OpenBSD: patch-bsd_c,v 1.3 2002/05/30 18:38:17 naddy Exp $
--- bsd.c.orig	Wed Feb  6 23:43:25 2002
+++ bsd.c	Sat May 25 14:38:37 2002
@@ -14,7 +14,7 @@
  * man pages and source to try and find things that did the same as
  * the Linux version. -- Richard
  *
- * jjreynold@home.com - minor fixes with debug mode output. Consistent brace
+ * johnjen@reynoldsnet.org - minor fixes with debug mode output. Consistent brace
  * use as well as indenting. More error messages put in to test for failure
  * modes with /dev/ permissions (when it happens). Note: I, like Richard, have
  * no clue what I'm doing. Patches to increase/fix functionality happily
@@ -36,12 +36,91 @@
 #include <sys/ioctl.h>
 
 #include <dev/usb/usb.h>
+#ifdef USB_GET_REPORT_ID
+#define USB_NEW_HID
+#endif
 
 #include "usbi.h"
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#ifndef USB_NEW_HID
+/* It appears some of the BSD's (OpenBSD atleast) have switched over to a */
+/* new naming convention, so we setup some macro's for backward */
+/* compability with older versions --jerdfelt */
+
+/* struct usb_ctl_request */
+#define ucr_addr		addr
+#define ucr_request		request
+#define ucr_data		data
+#define ucr_flags		flags
+#define ucr_actlen		actlen
+
+/* struct usb_alt_interface */
+#define uai_config_index	config_index
+#define uai_interface_index	interface_index
+#deifne uai_alt_no		uai_alt_no
+
+/* struct usb_config_desc */
+#define ucd_config_index	config_index
+#define ucd_desc		desc
+
+/* struct usb_interface_desc */
+#define uid_config_index	config_index
+#define uid_interface_index	interface_index
+#define uid_alt_index		alt_index
+#define uid_desc		desc
+
+/* struct usb_endpoint_desc */
+#define ued_config_index	config_index
+#define ued_interface_index	interface_index
+#define ued_alt_index		alt_index
+#define ued_endpoint_index	endpoint_index
+#define ued_desc		desc
+
+/* struct usb_full_desc */
+#define ufd_config_index	config_index
+#define ufd_size		size
+#define ufd_data		data
+
+/* struct usb_string_desc */
+#define usd_string_index	string_index
+#define usd_language_id		language_id
+#define usd_desc		desc
+
+/* struct usb_ctl_report_desc */
+#define ucrd_size		size
+#define ucrd_data		data
+
+/* struct usb_device_info */
+#define udi_bus			bus
+#define udi_addr		addr
+#define udi_cookie		cookie
+#define udi_product		product
+#define udi_vendor		vendor
+#define udi_release		release
+#define udi_productNo		productNo
+#define udi_vendorNo		vendorNo
+#define udi_releaseNo		releaseNo
+#define udi_class		class
+#define udi_subclass		subclass
+#define udi_protocol		protocol
+#define udi_config		config
+#define udi_lowspeed		lowspeed
+#define udi_power		power
+#define udi_nports		nports
+#define udi_devnames		devnames
+#define udi_ports		ports
+
+/* struct usb_ctl_report */
+#define ucr_report		report
+#define ucr_data		data
+
+/* struct usb_device_stats */
+#define uds_requests		requests
+#endif
+
 static int ensure_ep_open(usb_dev_handle *dev, int ep, int mode);
 
 #define MAX_CONTROLLERS 10
@@ -151,8 +230,8 @@ int usb_set_altinterface(usb_dev_handle 
   if (dev->interface < 0)
     USB_ERROR(-EINVAL);
 
-  intf.interface_index = dev->interface;
-  intf.alt_no = alternate;
+  intf.uai_interface_index = dev->interface;
+  intf.uai_alt_no = alternate;
 
   ret = ioctl(dev->fd, USB_SET_ALTINTERFACE, &intf);
   if (ret < 0)
@@ -182,7 +261,12 @@ static int ensure_ep_open(usb_dev_handle
 #else
     snprintf(buf, sizeof(buf) - 1, "%s.%02d", dev->device->filename, ep);
 #endif
-    fd = open(buf, mode);
+    /* Try to open it O_RDWR first for those devices which have in and out
+     * endpoints with the same address (eg 0x02 and 0x82)
+     */
+    fd = open(buf, O_RDWR);
+    if (fd < 0 && errno == ENXIO)
+      fd = open(buf, mode);
     if (fd < 0)
       USB_ERROR_STR(fd, "can't open %s for bulk read: %s\n",
                     buf, strerror(errno));
@@ -284,14 +368,14 @@ int usb_control_msg (usb_dev_handle *dev
     fprintf(stderr, "usb_control_msg: %d %d %d %d %p %d %d\n",
             requesttype, request, value, index, bytes, size, timeout);
 
-  req.request.bmRequestType = requesttype;
-  req.request.bRequest = request;
-  USETW(req.request.wValue, value);
-  USETW(req.request.wIndex, index);
-  USETW(req.request.wLength, size);
+  req.ucr_request.bmRequestType = requesttype;
+  req.ucr_request.bRequest = request;
+  USETW(req.ucr_request.wValue, value);
+  USETW(req.ucr_request.wIndex, index);
+  USETW(req.ucr_request.wLength, size);
 
-  req.data = bytes;
-  req.flags = 0;
+  req.ucr_data = bytes;
+  req.ucr_flags = 0;
 
   ret = ioctl(dev->fd, USB_SET_TIMEOUT, &timeout);
   if (ret < 0)
@@ -303,7 +387,7 @@ int usb_control_msg (usb_dev_handle *dev
     USB_ERROR_STR(ret, "error sending control message: %s",
                   strerror(errno));
 
-  return UGETW(req.request.wLength);
+  return UGETW(req.ucr_request.wLength);
 }
 
 int usb_find_devices_on_bus(struct usb_bus *bus)
@@ -321,28 +405,22 @@ int usb_find_devices_on_bus(struct usb_b
     struct usb_device *dev;
     char buf[20];
 
-    di.addr = device;
+    di.udi_addr = device;
     if (ioctl(cfd, USB_DEVICEINFO, &di) < 0)
       continue;
 
     /* There's a device; is it one we should mess with? */
 
-    if (strncmp(di.devnames[0], "ugen", 4) != 0)
+    if (strncmp(di.udi_devnames[0], "ugen", 4) != 0)
       /* best not to play with things we don't understand */
       continue;
 
 #if __FreeBSD__
-    snprintf(buf, sizeof(buf) - 1, "/dev/%s", di.devnames[0]);
+    snprintf(buf, sizeof(buf) - 1, "/dev/%s", di.udi_devnames[0]);
 #else
-    snprintf(buf, sizeof(buf) - 1, "/dev/%s.00", di.devnames[0]);
+    snprintf(buf, sizeof(buf) - 1, "/dev/%s.00", di.udi_devnames[0]);
 #endif
 
-    /* Don't re-add it if we were called multiple times */
-    for (dev = bus->devices; dev; dev = dev->next) {
-      if (!strcmp(dev->filename, buf))
-        continue;
-    }
-
     /* Open its control endpoint */
     dfd = open(buf, O_RDONLY);
     if (dfd < 0) {
@@ -364,7 +442,7 @@ int usb_find_devices_on_bus(struct usb_b
      * This seemed easier than having 2 variables...
      */
 #if __NetBSD__
-    snprintf(buf, sizeof(buf) - 1, "/dev/%s", di.devnames[0]);
+    snprintf(buf, sizeof(buf) - 1, "/dev/%s", di.udi_devnames[0]);
 #endif
 
     strncpy(dev->filename, buf, sizeof(dev->filename) - 1);
