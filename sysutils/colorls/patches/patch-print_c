$OpenBSD: patch-print_c,v 1.3 2003/01/20 01:45:14 naddy Exp $
--- print.c.orig	Mon Jan 20 00:08:15 2003
+++ print.c	Mon Jan 20 02:10:19 2003
@@ -53,12 +53,18 @@ static char rcsid[] = "$OpenBSD: print.c
 #include <fts.h>
 #include <grp.h>
 #include <pwd.h>
+#include <math.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 #include <tzfile.h>
 #include <unistd.h>
+#ifdef COLORLS
+#include <ctype.h>
+#include <termcap.h>
+#include <signal.h>
+#endif
 
 #include "ls.h"
 #include "extern.h"
@@ -67,10 +73,44 @@ static int	printaname(FTSENT *, u_long, 
 static void	printlink(FTSENT *);
 static void	printtime(time_t);
 static int	printtype(u_int);
+static void	printsize(size_t, off_t);
 static int	compute_columns(DISPLAY *, int *);
+#ifdef COLORLS
+static void	endcolor(int);
+static int	colortype(mode_t);
+#endif
 
 #define	IS_NOPRINT(p)	((p)->fts_number == NO_PRINT)
 
+typedef enum { NONE = 0, KILO, MEGA, GIGA, TERA, PETA /* , EXA */ } unit_t;
+static unit_t unit_adjust(double *);
+
+#ifdef COLORLS
+/* Most of these are taken from <sys/stat.h> */
+typedef enum Colors {
+	C_DIR,		/* directory */
+	C_LNK,		/* symbolic link */
+	C_SOCK,		/* socket */
+	C_FIFO,		/* pipe */
+	C_EXEC,		/* executable */
+	C_BLK,		/* block special */
+	C_CHR,		/* character special */
+	C_SUID,		/* setuid executable */
+	C_SGID,		/* setgid executable */
+	C_WSDIR,	/* directory writable to others, with sticky bit */
+	C_WDIR,		/* directory writable to others, without sticky bit */
+	C_NUMCOLORS	/* just a place-holder */
+} Colors ;
+
+const char *defcolors = "exfxcxdxbxegedabagacad";
+
+/* colors for file types */
+static struct {
+	int num[2];
+	int bold;
+} colors[C_NUMCOLORS];
+#endif
+
 void
 printscol(dp)
 	DISPLAY *dp;
@@ -93,6 +133,9 @@ printlong(dp)
 	FTSENT *p;
 	NAMES *np;
 	char buf[20];
+#ifdef COLORLS
+	int color_printed = 0;
+#endif
 
 	if (dp->list->fts_level != FTS_ROOTLEVEL && (f_longform || f_size))
 		(void)printf("total %lu\n", howmany(dp->btotal, blocksize));
@@ -117,17 +160,25 @@ printlong(dp)
 			(void)printf("%3d, %3d ",
 			    major(sp->st_rdev), minor(sp->st_rdev));
 		else if (dp->bcfile)
-			(void)printf("%*s%*qd ",
+			(void)printf("%*s%*lld ",
 			    8 - dp->s_size, "", dp->s_size, sp->st_size);
 		else
-			(void)printf("%*qd ", dp->s_size, sp->st_size);
+			printsize(dp->s_size, sp->st_size);
 		if (f_accesstime)
 			printtime(sp->st_atime);
 		else if (f_statustime)
 			printtime(sp->st_ctime);
 		else
 			printtime(sp->st_mtime);
+#ifdef COLORLS
+		if (f_color)
+			color_printed = colortype(sp->st_mode);
+#endif
 		(void)putname(p->fts_name);
+#ifdef COLORLS
+		if (f_color && color_printed)
+			endcolor(0);
+#endif
 		if (f_type || (f_typedir && S_ISDIR(sp->st_mode)))
 			(void)printtype(sp->st_mode);
 		if (S_ISLNK(sp->st_mode))
@@ -228,6 +279,9 @@ printaname(p, inodefield, sizefield)
 {
 	struct stat *sp;
 	int chcnt;
+#ifdef COLORLS
+	int color_printed = 0;
+#endif
 
 	sp = p->fts_statp;
 	chcnt = 0;
@@ -236,7 +290,15 @@ printaname(p, inodefield, sizefield)
 	if (f_size)
 		chcnt += printf("%*qd ",
 		    (int)sizefield, howmany(sp->st_blocks, blocksize));
+#ifdef COLORLS
+	if (f_color)
+		color_printed = colortype(sp->st_mode);
+#endif
 	chcnt += putname(p->fts_name);
+#ifdef COLORLS
+	if (f_color && color_printed)
+		endcolor(0);
+#endif
 	if (f_type || (f_typedir && S_ISDIR(sp->st_mode)))
 		chcnt += printtype(sp->st_mode);
 	return (chcnt);
@@ -359,6 +421,156 @@ printtype(mode)
 	return (0);
 }
 
+#ifdef COLORLS
+static int
+putch(c)
+	int c;
+{
+	(void) putchar(c);
+	return 0;
+}
+
+static int
+writech(c)
+	int c;
+{
+	char tmp = c;
+
+	(void) write(STDOUT_FILENO, &tmp, 1);
+	return 0;
+}
+
+static void
+printcolor(c)
+	Colors c;
+{
+	char *ansiseq;
+
+	if (colors[c].bold)
+		tputs(enter_bold, 1, putch);
+
+	if (colors[c].num[0] != -1) {
+		ansiseq = tgoto(ansi_fgcol, 0, colors[c].num[0]);
+		if (ansiseq)
+			tputs(ansiseq, 1, putch);
+	}
+	if (colors[c].num[1] != -1) {
+		ansiseq = tgoto(ansi_bgcol, 0, colors[c].num[1]);
+		if (ansiseq)
+			tputs(ansiseq, 1, putch);
+	}
+}
+
+static void
+endcolor(sig)
+	int sig;
+{
+	tputs(ansi_coloff, 1, sig ? writech : putch);
+	tputs(attrs_off, 1, sig ? writech : putch);
+}
+
+static int
+colortype(mode)
+	mode_t mode;
+{
+	switch (mode & S_IFMT) {
+		case S_IFDIR:
+			if (mode & S_IWOTH)
+				if (mode & S_ISTXT)
+					printcolor(C_WSDIR);
+				else
+					printcolor(C_WDIR);
+			else
+				printcolor(C_DIR);
+			return (1);
+		case S_IFLNK:
+			printcolor(C_LNK);
+			return (1);
+		case S_IFSOCK:
+			printcolor(C_SOCK);
+			return (1);
+		case S_IFIFO:
+			printcolor(C_FIFO);
+			return (1);
+		case S_IFBLK:
+			printcolor(C_BLK);
+			return (1);
+		case S_IFCHR:
+			printcolor(C_CHR);
+			return (1);
+	}
+	if (mode & (S_IXUSR | S_IXGRP | S_IXOTH)) {
+		if (mode & S_ISUID)
+			printcolor(C_SUID);
+		else if (mode & S_ISGID)
+			printcolor(C_SGID);
+		else
+			printcolor(C_EXEC);
+		return (1);
+	}
+	return (0);
+}
+
+void
+parsecolors(cs)
+	const char *cs;
+{
+	int i;
+	int j;
+	size_t len;
+	char c[2];
+	short legacy_warn = 0;
+
+	if (cs == NULL)
+		cs = "";	/* LSCOLORS not set */
+	len = strlen(cs);
+	for (i = 0; i < C_NUMCOLORS ; i++) {
+		colors[i].bold = 0;
+
+		if (len <= 2 * i) {
+			c[0] = defcolors[2 * i];
+			c[1] = defcolors[2 * i + 1];
+		} else {
+			c[0] = cs[2 * i];
+			c[1] = cs[2 * i + 1];
+		}
+		for (j = 0; j < 2 ; j++) {
+			/* Legacy colours used 0-7 */
+			if (c[j] >= '0' && c[j] <= '7') {
+				colors[i].num[j] = c[j] - '0';
+				if (!legacy_warn) {
+					warnx("LSCOLORS should use "
+					    "characters a-h instead of 0-9 ("
+					    "see the manual page)");
+				}
+				legacy_warn = 1;
+			} else if (c[j] >= 'a' && c[j] <= 'h')
+				colors[i].num[j] = c[j] - 'a';
+			else if (c[j] >= 'A' && c[j] <= 'H') {
+				colors[i].num[j] = c[j] - 'A';
+				colors[i].bold = 1;
+			} else if (tolower((unsigned char)c[j] == 'x'))
+				colors[i].num[j] = -1;
+			else {
+				warnx("invalid character '%c' in LSCOLORS"
+				    " env var", c[j]);
+				colors[i].num[j] = -1;
+			}
+		}
+	}
+}
+
+void
+colorquit(int sig)
+{
+	endcolor(sig);
+
+	(void)signal(sig, SIG_DFL);
+	(void)kill(getpid(), sig);
+}
+
+#endif /*COLORLS*/
+
 static void
 printlink(p)
 	FTSENT *p;
@@ -378,4 +590,57 @@ printlink(p)
 	path[lnklen] = '\0';
 	(void)printf(" -> ");
 	(void)putname(path);
+}
+
+static void
+printsize(size_t width, off_t bytes)
+{
+	double dbytes;
+	unit_t unit;
+
+	if (f_humanval) {
+		dbytes = bytes;
+		unit = unit_adjust(&dbytes);
+
+		if (dbytes == 0)
+			(void)printf("%*s ", width, "0B");
+		else
+			(void)printf("%*.*f%c ", width - 1, dbytes > 10 ? 0 : 1,
+			    dbytes, "BKMGTPE"[unit]);
+	} else
+		(void)printf("%*lld ", width, bytes);
+}
+
+/*
+ * Output in "human-readable" format.  Uses 3 digits max and puts
+ * unit suffixes at the end.  Makes output compact and easy to read,
+ * especially on huge disks.
+ *
+ */
+static unit_t
+unit_adjust(double *val)
+{
+	double abval;
+	unit_t unit;
+
+	abval = fabs(*val);
+	if (abval < 1024)
+		unit = NONE;
+	else if (abval < 1048576ULL) {
+		unit = KILO;
+		*val /= 1024;
+	} else if (abval < 1073741824ULL) {
+		unit = MEGA;
+		*val /= 1048576;
+	} else if (abval < 1099511627776ULL) {
+		unit = GIGA;
+		*val /= 1073741824ULL;
+	} else if (abval < 1125899906842624ULL) {
+		unit = TERA;
+		*val /= 1099511627776ULL;
+	} else /* if (abval < 1152921504606846976ULL) */ {
+		unit = PETA;
+		*val /= 1125899906842624ULL;
+	}
+	return (unit);
 }
