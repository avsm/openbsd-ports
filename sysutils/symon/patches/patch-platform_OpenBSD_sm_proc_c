$OpenBSD: patch-platform_OpenBSD_sm_proc_c,v 1.1 2010/01/19 19:43:57 kili Exp $
--- platform/OpenBSD/sm_proc.c.orig	Wed Feb 20 09:17:25 2008
+++ platform/OpenBSD/sm_proc.c	Sun Jan 17 17:57:27 2010
@@ -52,7 +52,7 @@
 #define pagetob(size) (((u_int32_t)size) << proc_pageshift)
 
 /* Globals for this module start with proc_ */
-static struct kinfo_proc *proc_ps = NULL;
+static struct kinfo_proc2 *proc_ps = NULL;
 static int proc_max = 0;
 static int proc_cur = 0;
 static int proc_stathz = 0;
@@ -67,7 +67,7 @@ typedef long pctcpu;
 void
 gets_proc()
 {
-    int mib[3];
+    int mib[6];
     int procs;
     size_t size;
 
@@ -85,30 +85,33 @@ gets_proc()
         proc_max = (procs * 5) / 4;
 
         if (proc_max > SYMON_MAX_DOBJECTS) {
-            fatal("%s:%d: dynamic object limit (%d) exceeded for kinfo_proc structures",
+            fatal("%s:%d: dynamic object limit (%d) exceeded for kinfo_proc2 structures",
                   __FILE__, __LINE__, SYMON_MAX_DOBJECTS);
         }
 
-        proc_ps = xrealloc(proc_ps, proc_max * sizeof(struct kinfo_proc));
+        proc_ps = xrealloc(proc_ps, proc_max * sizeof(struct kinfo_proc2));
     }
 
     /* read data in anger */
     mib[0] = CTL_KERN;
-    mib[1] = KERN_PROC;
+    mib[1] = KERN_PROC2;
     mib[2] = KERN_PROC_KTHREAD;
-    size = proc_max * sizeof(struct kinfo_proc);
-    if (sysctl(mib, 3, proc_ps, &size, NULL, 0) < 0) {
+    mib[3] = 0;
+    mib[4] = sizeof(struct kinfo_proc2);
+    mib[5] = proc_max;
+    size = proc_max * sizeof(struct kinfo_proc2);
+    if (sysctl(mib, 6, proc_ps, &size, NULL, 0) < 0) {
         warning("proc probe cannot get processes");
         proc_cur = 0;
         return;
     }
 
-    if (size % sizeof(struct kinfo_proc) != 0) {
-        warning("proc size mismatch: got %d bytes, not dividable by sizeof(kinfo_proc) %d",
-                size, sizeof(struct kinfo_proc));
+    if (size % sizeof(struct kinfo_proc2) != 0) {
+        warning("proc size mismatch: got %d bytes, not dividable by sizeof(kinfo_proc2) %d",
+                size, sizeof(struct kinfo_proc2));
         proc_cur = 0;
     } else {
-        proc_cur = size / sizeof(struct kinfo_proc);
+        proc_cur = size / sizeof(struct kinfo_proc2);
     }
 }
 
@@ -147,7 +150,7 @@ int
 get_proc(char *symon_buf, int maxlen, struct stream *st)
 {
     int i;
-    struct kinfo_proc *pp;
+    struct kinfo_proc2 *pp;
     u_quad_t  cpu_ticks = 0;
     u_quad_t  cpu_uticks = 0;
     u_quad_t  cpu_iticks = 0;
@@ -160,19 +163,19 @@ get_proc(char *symon_buf, int maxlen, struct stream *s
     int n = 0;
 
     for (pp = proc_ps, i = 0; i < proc_cur; pp++, i++) {
-         if (strncmp(st->arg, pp->kp_proc.p_comm, strlen(st->arg)) == 0) {
+         if (strncmp(st->arg, pp->p_comm, strlen(st->arg)) == 0) {
              /* cpu time - accumulated */
-             cpu_uticks += pp->kp_proc.p_uticks;  /* user */
-             cpu_sticks += pp->kp_proc.p_sticks;  /* sys  */
-             cpu_iticks += pp->kp_proc.p_iticks;  /* int  */
+             cpu_uticks += pp->p_uticks;  /* user */
+             cpu_sticks += pp->p_sticks;  /* sys  */
+             cpu_iticks += pp->p_iticks;  /* int  */
              /* cpu time - percentage since last measurement */
-             cpu_pct = pctdouble(pp->kp_proc.p_pctcpu) * 100.0;
+             cpu_pct = pctdouble(pp->p_pctcpu) * 100.0;
              cpu_pcti += cpu_pct;
              /* memory size - shared pages are counted multiple times */
-             mem_procsize += pagetob(pp->kp_eproc.e_vm.vm_tsize + /* text pages */
-                                     pp->kp_eproc.e_vm.vm_dsize + /* data */
-                                     pp->kp_eproc.e_vm.vm_ssize); /* stack */
-             mem_rss += pagetob(pp->kp_eproc.e_vm.vm_rssize);     /* rss  */
+             mem_procsize += pagetob(pp->p_vm_tsize + /* text pages */
+                                     pp->p_vm_dsize + /* data */
+                                     pp->p_vm_ssize); /* stack */
+             mem_rss += pagetob(pp->p_vm_rssize);     /* rss  */
              n++;
          }
     }
