$OpenBSD: patch-iodev_vga_cc,v 1.1 2001/02/02 16:59:12 todd Exp $
--- iodev/vga.cc.orig	Sat Mar 25 21:28:49 2000
+++ iodev/vga.cc	Tue Oct 31 12:25:06 2000
@@ -188,14 +188,17 @@ bx_vga_c::init(bx_devices_c *d, bx_cmos_
   bx_gui.init(1, &argv[0], BX_VGA_THIS s.x_tilesize, BX_VGA_THIS s.y_tilesize);
   }
 
-  bx_printf("vga: interval=%lu\n", bx_options.vga_update_interval);
-  bx_pc_system.register_timer(this, timer_handler,
-     bx_options.vga_update_interval, 1, 1);
+  	//if(bio->getdbg().video)
+  		bio->printf("[VGA] interval=%lu\n",
+			bx_options.vga_update_interval);
+	bx_pc_system.register_timer(this, timer_handler,
+	bx_options.vga_update_interval, 1, 1);
 
-  cmos->s.reg[0x14] = (cmos->s.reg[0x14] & 0xcf) | 0x00; /* video card with BIOS ROM */
+	cmos->s.reg[0x14] = (cmos->s.reg[0x14] & 0xcf) | 0x00;
+	/* video card with BIOS ROM */
 
-  BX_VGA_THIS s.horiz_tick = 0;
-  BX_VGA_THIS s.vert_tick = 0;
+	BX_VGA_THIS s.horiz_tick = 0;
+	BX_VGA_THIS s.vert_tick = 0;
 }
 
 
@@ -314,7 +317,7 @@ bx_vga_c::read(Bit32u address, unsigned 
 #endif
 
   if (io_len > 1)
-    bx_panic("vga: io read from address %08x, len=%u\n",
+    bio->panic("[VGA] io read from address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
 
 #ifdef __OS2__
@@ -325,8 +328,8 @@ bx_vga_c::read(Bit32u address, unsigned 
 #endif
 
 #if !defined(VGA_TRACE_FEATURE)
-  if (bx_dbg.video)
-    bx_printf("vga_io_read(%04x)!\n", (unsigned) address);
+  if (bio->getdbg().video)
+    bio->printf("[VGA] vga_io_read(%04x)!\n", (unsigned) address);
 #endif
 
   if ( (address >= 0x03b0) && (address <= 0x03bf) &&
@@ -350,7 +353,7 @@ bx_vga_c::read(Bit32u address, unsigned 
       //       1 = display is not in the display mode; either the
       //           horizontal or vertical retrace period is active
 
-      //      printf("horiz = %d, vert = %d\n", BX_VGA_THIS s.horiz_tick, BX_VGA_THIS s.vert_tick);
+      //      printf("[VGA] horiz = %d, vert = %d\n", BX_VGA_THIS s.horiz_tick, BX_VGA_THIS s.vert_tick);
 
       if (BX_VGA_THIS s.horiz_tick >= 100) { // ??? bogus # 100
         BX_VGA_THIS s.horiz_tick = 0;
@@ -383,14 +386,15 @@ bx_vga_c::read(Bit32u address, unsigned 
 
     case 0x03c0: /* */
       if (BX_VGA_THIS s.attribute_ctrl.flip_flop == 0) {
-        //bx_printf("vga_io_read: 3c0: flip_flop = 0\n");
+	if(bio->getdbg().video)
+        	bio->printf("[VGA] vga_io_read: 3c0: flip_flop = 0\n");
         retval =
           (BX_VGA_THIS s.attribute_ctrl.video_enabled << 5) |
           BX_VGA_THIS s.attribute_ctrl.address;
         RETURN(retval);
         }
       else {
-        bx_panic("vga_io_read: 3c0: flip_flop = 0\n");
+        bio->panic("vga_io_read: 3c0: flip_flop = 0\n");
         return(0);
         }
       break;
@@ -428,14 +432,16 @@ bx_vga_c::read(Bit32u address, unsigned 
           RETURN(BX_VGA_THIS s.attribute_ctrl.color_select);
           break;
         default:
-          bx_printf("vga_io_read: 3c1: address %02xh?\n",
-            (unsigned) BX_VGA_THIS s.attribute_ctrl.address);
+	  if(bio->getdbg().video)
+          	bio->printf("[VGA] vga_io_read: 3c1: address %02xh?\n",
+			(unsigned) BX_VGA_THIS s.attribute_ctrl.address);
           RETURN(0);
         }
       break;
 
     case 0x03c2: /* Input Status 0 */
-      bx_printf("vga: io read 3c2: input status #0: ignoring\n");
+	if(bio->getdbg().video)
+		bio->printf("[VGA] io read 3c2: input status #0: ignoring\n");
       RETURN(0);
       break;
 
@@ -446,11 +452,13 @@ bx_vga_c::read(Bit32u address, unsigned 
     case 0x03c5: /* Sequencer Registers 00..04 */
       switch (BX_VGA_THIS s.sequencer.index) {
         case 0: /* sequencer: reset */
-bx_printf("*** io read 3c5 case 0: sequencer reset\n");
+		if(bio->getdbg().video)
+bio->printf("[VGA] *** io read 3c5 case 0: sequencer reset\n");
           RETURN(BX_VGA_THIS s.sequencer.bit0 | (BX_VGA_THIS s.sequencer.bit1<<1));
           break;
         case 1: /* sequencer: clocking mode */
-bx_printf("*** io read 3c5 case 1: sequencer clocking mode\n");
+	 	if(bio->getdbg().video)
+bio->printf("[VGA] *** io read 3c5 case 1: sequencer clocking mode\n");
           RETURN(BX_VGA_THIS s.sequencer.reg1);
           break;
         case 2: /* sequencer: map mask register */
@@ -468,7 +476,8 @@ bx_printf("*** io read 3c5 case 1: seque
           break;
 
         default:
-          bx_printf("vga: io read 3c5: index %u unhandled\n",
+	 	if(bio->getdbg().video)
+          bio->printf("[VGA] io read 3c5: index %u unhandled\n",
             (unsigned) BX_VGA_THIS s.sequencer.index);
           RETURN(0);
         }
@@ -490,7 +499,8 @@ bx_printf("*** io read 3c5 case 1: seque
           retval = BX_VGA_THIS s.pel.data[BX_VGA_THIS s.pel.read_data_register].blue;
           break;
         default:
-          bx_panic("vga: io write 3c9: data cyle is bad value\n");
+	 	if(bio->getdbg().video)
+          bio->printf("[VGA] io write 3c9: data cyle is bad value\n");
           retval = 0; // keep compiler happy
         }
       BX_VGA_THIS s.pel.read_data_cycle++;
@@ -517,7 +527,8 @@ bx_printf("*** io read 3c5 case 1: seque
       break;
 
     case 0x03cd: /* ??? */
-      bx_printf("vga: io read from 03cd\n");
+	 	if(bio->getdbg().video)
+      bio->printf("[VGA] io read from 0x03cd\n");
       RETURN(0x00);
       break;
 
@@ -548,10 +559,11 @@ bx_printf("*** io read 3c5 case 1: seque
             ((BX_VGA_THIS s.graphics_ctrl.read_mode & 0x01) << 3) |
             ((BX_VGA_THIS s.graphics_ctrl.write_mode & 0x03) << 0);
 
-if (BX_VGA_THIS s.graphics_ctrl.odd_even ||
-    BX_VGA_THIS s.graphics_ctrl.shift_reg)
-  bx_printf("read 3cf: reg 05 = %02x\n", (unsigned) retval);
-          RETURN(retval);
+	if (BX_VGA_THIS s.graphics_ctrl.odd_even ||
+		BX_VGA_THIS s.graphics_ctrl.shift_reg)
+	 	if(bio->getdbg().video)
+		bio->printf("[VGA] read 3cf: reg 05 = %02x\n", (unsigned) retval);
+		RETURN(retval);
           break;
         case 6: /* Miscellaneous */
           retval =
@@ -568,11 +580,13 @@ if (BX_VGA_THIS s.graphics_ctrl.odd_even
           break;
         default:
           /* ??? */
-          bx_printf("vga: io read: 3cf: index %u unhandled\n",
+	 	if(bio->getdbg().video)
+          bio->printf("[VGA] io read: 3cf: index %u unhandled\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.index);
           RETURN(0);
         }
-      bx_panic("vga: io read: 3cf: shouldn't get here\n");
+	 	if(bio->getdbg().video)
+      bio->printf("[VGA] io read: 3cf: shouldn't get here\n");
       break;
 
     case 0x03d4: /* CRTC Index Register (color emulation modes) */
@@ -581,9 +595,10 @@ if (BX_VGA_THIS s.graphics_ctrl.odd_even
 
     case 0x03b5: /* CRTC Registers (monochrome emulation modes) */
     case 0x03d5: /* CRTC Registers (color emulation modes) */
-      if (BX_VGA_THIS s.CRTC.address > 0x18)
-        bx_printf("vga_io_read: 3d5: address = %02xh\n",
-          (unsigned) BX_VGA_THIS s.CRTC.address);
+	if(bio->getdbg().video)
+		if (BX_VGA_THIS s.CRTC.address > 0x18)
+			bio->printf("vga_io_read: 3d5: address = %02xh\n",
+				(unsigned) BX_VGA_THIS s.CRTC.address);
       RETURN(BX_VGA_THIS s.CRTC.reg[BX_VGA_THIS s.CRTC.address]);
       break;
 
@@ -592,14 +607,15 @@ if (BX_VGA_THIS s.graphics_ctrl.odd_even
     case 0x03c7: /* */
     case 0x03c8: /* */
     default:
-      bx_panic("*** io read from vga port %x\n", (unsigned) address);
-      RETURN(0); /* keep compiler happy */
+	if(bio->getdbg().video)
+      bio->printf("[VGA] *** io read from vga port %x\n", (unsigned) address);
+      RETURN(0);
     }
 
 #if defined(VGA_TRACE_FEATURE)
   read_return:
-  if (bx_dbg.video)
-	bx_printf("vga: 8-bit read from %04x = %02x\n", (unsigned) address, ret);
+  if (bio->getdbg().video)
+	bio->printf("[VGA] 8-bit read from %04x = %02x\n", (unsigned) address, ret);
   return ret;
 #endif
 }
@@ -646,22 +662,22 @@ bx_vga_c::write(Bit32u address, Bit32u v
   Boolean needs_update;
 
 #if defined(VGA_TRACE_FEATURE)
-  if (!no_log && bx_dbg.video)
+  if (!no_log && bio->getdbg().video)
 	switch (io_len) {
 	      case 1:
-		    bx_printf("vga: 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
+		    bio->printf("[VGA] 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
 		    break;
 	      case 2:
-		    bx_printf("vga: 16-bit write to %04x = %04x\n", (unsigned)address, (unsigned)value);
+		    bio->printf("[VGA] 16-bit write to %04x = %04x\n", (unsigned)address, (unsigned)value);
 		    break;
 	      default:
-		    bx_panic("Weird VGA write size\n");
+		    bio->printf("Weird VGA write size\n");
 	}
 #endif
 
 #if !defined(VGA_TRACE_FEATURE)
-  if (bx_dbg.video)
-    bx_printf("vga_io_write(%04x)=%02x!\n", (unsigned) address,
+  if (bio->getdbg().video)
+    bio->printf("[VGA] vga_io_write(%04x)=%02x!\n", (unsigned) address,
       (unsigned) value);
 #endif
 
@@ -694,25 +710,25 @@ bx_vga_c::write(Bit32u address, Bit32u v
   switch (address) {
     case 0x03b4: /* CRTC Index Register (monochrome emulation modes) */
       if (value > 0x18)
-        bx_panic("vga: io write 3b4: value > 18h\n");
+        bio->panic("[VGA] io write 3b4: value > 18h\n");
       BX_VGA_THIS s.CRTC.address = value;
       break;
 
     case 0x03b5: /* CRTC Registers (monochrome emulation modes) */
-      if (BX_VGA_THIS s.CRTC.address > 0x18)
-        bx_panic("vga: io write 3b5: CRTC reg > 18h\n");
+      if (BX_VGA_THIS s.CRTC.address > 0x18 && bio->getdbg().video)
+        bio->printf("[VGA] io write 3b5: CRTC reg > 18h\n");
       BX_VGA_THIS s.CRTC.reg[BX_VGA_THIS s.CRTC.address] = value;
 #if !defined(VGA_TRACE_FEATURE)
-      if (bx_dbg.video)
-        bx_printf("vga: mono CRTC Reg[%u] = %02x\n",
+      if (bio->getdbg().video)
+        bio->printf("[VGA] mono CRTC Reg[%u] = %02x\n",
           (unsigned) BX_VGA_THIS s.CRTC.address, (unsigned) value);
 #endif
       break;
 
     case 0x03ba: /* Feature Control (monochrome emulation modes) */
 #if !defined(VGA_TRACE_FEATURE)
-      if (bx_dbg.video)
-        bx_printf("vga: io write 3ba: feature control: ignoring\n");
+      if (bio->getdbg().video)
+        bio->printf("[VGA] io write 3ba: feature control: ignoring\n");
 #endif
       break;
 
@@ -721,16 +737,16 @@ bx_vga_c::write(Bit32u address, Bit32u v
         prev_video_enabled = BX_VGA_THIS s.attribute_ctrl.video_enabled;
         BX_VGA_THIS s.attribute_ctrl.video_enabled = (value >> 5) & 0x01;
 #if !defined(VGA_TRACE_FEATURE)
-        if (bx_dbg.video)
-          bx_printf("vga: io write 3c0: video_enabled = %u\n",
+        if (bio->getdbg().video)
+          bio->printf("[VGA] io write 3c0: video_enabled = %u\n",
                   (unsigned) BX_VGA_THIS s.attribute_ctrl.video_enabled);
 #endif
         if (BX_VGA_THIS s.attribute_ctrl.video_enabled == 0)
           bx_gui.clear_screen();
         else if (!prev_video_enabled) {
 #if !defined(VGA_TRACE_FEATURE)
-          if (bx_dbg.video)
-            bx_printf("found enable transition\n");
+          if (bio->getdbg().video)
+            bio->printf("[VGA] found enable transition\n");
 #endif
           // Mark all video as updated so the color changes will go through
           memset(BX_VGA_THIS s.text_snapshot, 0,
@@ -752,7 +768,8 @@ bx_vga_c::write(Bit32u address, Bit32u v
             break;
 
           default:
-            bx_printf("vga: io write 3c0: address mode reg=%u\n",
+		if(bio->getdbg().video)
+            bio->printf("[VGA] io write 3c0: address mode reg=%u\n",
               (unsigned) value);
           }
         }
@@ -764,7 +781,7 @@ bx_vga_c::write(Bit32u address, Bit32u v
           case 0x0c: case 0x0d: case 0x0e: case 0x0f:
             BX_VGA_THIS s.attribute_ctrl.palette_reg[BX_VGA_THIS s.attribute_ctrl.address] =
               value;
-            //bx_printf("vga: io write: 3c0 palette reg[%u] = %02x\n",
+            //bio->printf("[VGA] io write: 3c0 palette reg[%u] = %02x\n",
             //  (unsigned) BX_VGA_THIS s.attribute_ctrl.address,
             //  (unsigned) value);
             break;
@@ -784,45 +801,45 @@ bx_vga_c::write(Bit32u address, Bit32u v
             BX_VGA_THIS s.attribute_ctrl.mode_ctrl.internal_palette_size =
               (value >> 7) & 0x01;
 #if !defined(VGA_TRACE_FEATURE)
-            if (bx_dbg.video)
-              bx_printf("vga: io write 3c0: mode control: %02x h\n",
+            if (bio->getdbg().video)
+              bio->printf("[VGA] io write 3c0: mode control: %02x h\n",
                 (unsigned) value);
 #endif
             break;
           case 0x11: // Overscan Color Register
             BX_VGA_THIS s.attribute_ctrl.overscan_color = (value & 0x3f);
 #if !defined(VGA_TRACE_FEATURE)
-            if (bx_dbg.video)
-              bx_printf("vga: io write 3c0: overscan color = %02x\n",
+            if (bio->getdbg().video)
+              bio->printf("[VGA] io write 3c0: overscan color = %02x\n",
                         (unsigned) value);
 #endif
             break;
           case 0x12: // Color Plane Enable Register
             BX_VGA_THIS s.attribute_ctrl.color_plane_enable = (value & 0x0f);
 #if !defined(VGA_TRACE_FEATURE)
-            if (bx_dbg.video)
-              bx_printf("vga: io write 3c0: color plane enable = %02x\n",
+            if (bio->getdbg().video)
+              bio->printf("[VGA] io write 3c0: color plane enable = %02x\n",
                         (unsigned) value);
 #endif
             break;
           case 0x13: // Horizontal Pixel Panning Register
             BX_VGA_THIS s.attribute_ctrl.horiz_pel_panning = (value & 0x0f);
 #if !defined(VGA_TRACE_FEATURE)
-            if (bx_dbg.video)
-              bx_printf("vga: io write 3c0: horiz pel panning = %02x\n",
+            if (bio->getdbg().video)
+              bio->printf("[VGA] io write 3c0: horiz pel panning = %02x\n",
                         (unsigned) value);
 #endif
             break;
           case 0x14: // Color Select Register
             BX_VGA_THIS s.attribute_ctrl.color_select = (value & 0x0f);
 #if !defined(VGA_TRACE_FEATURE)
-            if (bx_dbg.video)
-              bx_printf("vga: io write 3c0: color select = %02x\n",
+            if (bio->getdbg().video)
+              bio->printf("[VGA] io write 3c0: color select = %02x\n",
                         (unsigned) BX_VGA_THIS s.attribute_ctrl.color_select);
 #endif
             break;
           default:
-            bx_printf("vga: io write 3c0: data-write mode %02x h\n",
+            bio->printf("[VGA] io write 3c0: data-write mode %02x h\n",
               (unsigned) BX_VGA_THIS s.attribute_ctrl.address);
           }
         }
@@ -837,19 +854,19 @@ bx_vga_c::write(Bit32u address, Bit32u v
       BX_VGA_THIS s.misc_output.horiz_sync_pol   = (value >> 6) & 0x01;
       BX_VGA_THIS s.misc_output.vert_sync_pol    = (value >> 7) & 0x01;
 #if !defined(VGA_TRACE_FEATURE)
-      if (bx_dbg.video) {
-        bx_printf("vga: io write 3c2:\n");
-        bx_printf("  color_emulation (attempted) = %u\n",
+      if (bio->getdbg().video) {
+        bio->printf("[VGA] io write 3c2:\n");
+        bio->printf("[VGA]   color_emulation (attempted) = %u\n",
                   (value >> 0) & 0x01 );
-        bx_printf("  enable_ram = %u\n",
+        bio->printf("[VGA]   enable_ram = %u\n",
                   (unsigned) BX_VGA_THIS s.misc_output.enable_ram);
-        bx_printf("  clock_select = %u\n",
+        bio->printf("[VGA]   clock_select = %u\n",
                   (unsigned) BX_VGA_THIS s.misc_output.clock_select);
-        bx_printf("  select_high_bank = %u\n",
+        bio->printf("[VGA]   select_high_bank = %u\n",
                   (unsigned) BX_VGA_THIS s.misc_output.select_high_bank);
-        bx_printf("  horiz_sync_pol = %u\n",
+        bio->printf("[VGA]   horiz_sync_pol = %u\n",
                   (unsigned) BX_VGA_THIS s.misc_output.horiz_sync_pol);
-        bx_printf("  vert_sync_pol = %u\n",
+        bio->printf("[VGA]   vert_sync_pol = %u\n",
                   (unsigned) BX_VGA_THIS s.misc_output.vert_sync_pol);
         }
 #endif
@@ -858,15 +875,15 @@ bx_vga_c::write(Bit32u address, Bit32u v
     case 0x03c3: // VGA enable
       // bit0: enables VGA display if set
 #if !defined(VGA_TRACE_FEATURE)
-      if (bx_dbg.video)
-        bx_printf("vga: io write 3c3: (ignoring) VGA enable = %u\n",
+      if (bio->getdbg().video)
+        bio->printf("[VGA] io write 3c3: (ignoring) VGA enable = %u\n",
                   (unsigned) (value & 0x01) );
 #endif
       break;
 
     case 0x03c4: /* Sequencer Index Register */
-      if (value > 4) {
-        bx_printf("vga: io write 3c4: value > 4\n");
+      if (value > 4 && bio->getdbg().video) {
+        bio->printf("[VGA] io write 3c4: value > 4\n");
         }
       BX_VGA_THIS s.sequencer.index = value;
       break;
@@ -875,8 +892,8 @@ bx_vga_c::write(Bit32u address, Bit32u v
       switch (BX_VGA_THIS s.sequencer.index) {
         case 0: /* sequencer: reset */
 #if !defined(VGA_TRACE_FEATURE)
-          if (bx_dbg.video)
-            bx_printf("vga: io write 3c5=%02x: reset reg: ignoring\n",
+          if (bio->getdbg().video)
+            bio->printf("[VGA] io write 3c5=%02x: reset reg: ignoring\n",
                       (unsigned) value);
 #endif
 BX_VGA_THIS s.sequencer.bit0 = (value >> 0) & 0x01;
@@ -884,8 +901,8 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
           break;
         case 1: /* sequencer: clocking mode */
 #if !defined(VGA_TRACE_FEATURE)
-          if (bx_dbg.video)
-            bx_printf("vga: io write 3c5=%02x: clocking mode reg: ignoring\n",
+          if (bio->getdbg().video)
+            bio->printf("[VGA] io write 3c5=%02x: clocking mode reg: ignoring\n",
                       (unsigned) value);
 #endif
           BX_VGA_THIS s.sequencer.reg1 = value & 0x3f;
@@ -904,27 +921,28 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
           BX_VGA_THIS s.sequencer.chain_four     = (value >> 3) & 0x01;
 
 #if !defined(VGA_TRACE_FEATURE)
-          if (bx_dbg.video) {
-            bx_printf("vga: io write 3c5: index 4:\n");
-            bx_printf("  extended_mem %u\n",
+          if (bio->getdbg().video) {
+            bio->printf("[VGA] io write 3c5: index 4:\n");
+            bio->printf("[VGA]   extended_mem %u\n",
               (unsigned) BX_VGA_THIS s.sequencer.extended_mem);
-            bx_printf("  odd_even %u\n",
+            bio->printf("[VGA]   odd_even %u\n",
               (unsigned) BX_VGA_THIS s.sequencer.odd_even);
-            bx_printf("  chain_four %u\n",
+            bio->printf("[VGA]   chain_four %u\n",
               (unsigned) BX_VGA_THIS s.sequencer.chain_four);
             }
 #endif
           break;
         default:
-          bx_printf("vga: io write 3c5: index %u unhandled\n",
-            (unsigned) BX_VGA_THIS s.sequencer.index);
+		if(bio->getdbg().floppy)
+          		bio->printf("[VGA] io write 3c5: index %u unhandled\n",
+           			 (unsigned) BX_VGA_THIS s.sequencer.index);
         }
       break;
 
     case 0x03c6: /* PEL mask */
       BX_VGA_THIS s.pel.mask = value;
       if (BX_VGA_THIS s.pel.mask != 0xff)
-        bx_printf("vga: io write 3c6: PEL mask=0x%02x != 0xFF\n");
+        bio->printf("[VGA] io write 3c6: PEL mask=0x%02x != 0xFF\n");
       // BX_VGA_THIS s.pel.mask should be and'd with final value before
       // indexing into color registerBX_VGA_THIS s.
       break;
@@ -970,12 +988,12 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
             }
           break;
         default:
-          bx_panic("vga: io write 3c9: data cyle is bad value\n");
+          bio->panic("[VGA] io write 3c9: data cyle is bad value\n");
         }
 
       BX_VGA_THIS s.pel.write_data_cycle++;
       if (BX_VGA_THIS s.pel.write_data_cycle >= 3) {
-        //bx_printf("vga: BX_VGA_THIS s.pel.data[%u] {r=%u, g=%u, b=%u}\n",
+        //bio->printf("[VGA] BX_VGA_THIS s.pel.data[%u] {r=%u, g=%u, b=%u}\n",
         //  (unsigned) BX_VGA_THIS s.pel.write_data_register,
         //  (unsigned) BX_VGA_THIS s.pel.data[BX_VGA_THIS s.pel.write_data_register].red,
         //  (unsigned) BX_VGA_THIS s.pel.data[BX_VGA_THIS s.pel.write_data_register].green,
@@ -995,12 +1013,12 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
 
     case 0x03ce: /* Graphics Controller Index Register */
       if (value > 0x08) /* ??? */
-        bx_printf("vga: io write: 3ce: value > 8\n");
+        bio->printf("[VGA] io write: 3ce: value > 8\n");
       BX_VGA_THIS s.graphics_ctrl.index = value;
       break;
 
     case 0x03cd: /* ??? */
-      bx_printf("vga: io write to 03cd = %02x\n", (unsigned) value);
+      bio->printf("[VGA] io write to 03cd = %02x\n", (unsigned) value);
       break;
 
     case 0x03cf: /* Graphics Controller Registers 00..08 */
@@ -1022,8 +1040,8 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
         case 4: /* Read Map Select */
           BX_VGA_THIS s.graphics_ctrl.read_map_select = value & 0x03;
 #if !defined(VGA_TRACE_FEATURE)
-          if (bx_dbg.video)
-            bx_printf("vga: io write to 03cf = %02x (RMS)\n", (unsigned) value);
+          if (bio->getdbg().video)
+            bio->printf("[VGA] io write to 03cf = %02x (RMS)\n", (unsigned) value);
 #endif
           break;
         case 5: /* Mode */
@@ -1032,11 +1050,11 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
           BX_VGA_THIS s.graphics_ctrl.odd_even   = (value >> 4) & 0x01;
           BX_VGA_THIS s.graphics_ctrl.shift_reg         = (value >> 5) & 0x03;
 
-          if (BX_VGA_THIS s.graphics_ctrl.odd_even)
-            bx_printf("vga: io write: 3cf: reg 05: value = %02xh\n",
+          if (BX_VGA_THIS s.graphics_ctrl.odd_even && bio->getdbg().video)
+            bio->printf("[VGA] io write: 3cf: reg 05: value = %02xh\n",
               (unsigned) value);
-          if (BX_VGA_THIS s.graphics_ctrl.shift_reg)
-            bx_printf("vga: io write: 3cf: reg 05: value = %02xh\n",
+          if (BX_VGA_THIS s.graphics_ctrl.shift_reg && bio->getdbg().video)
+            bio->printf("[VGA] io write: 3cf: reg 05: value = %02xh\n",
               (unsigned) value);
           break;
         case 6: /* Miscellaneous */
@@ -1048,14 +1066,14 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
           BX_VGA_THIS s.graphics_ctrl.chain_odd_even = (value >> 1) & 0x01;
           BX_VGA_THIS s.graphics_ctrl.memory_mapping = (value >> 2) & 0x03;
 #if !defined(VGA_TRACE_FEATURE)
-          if (bx_dbg.video) {
-            bx_printf("memory_mapping set to %u\n",
+          if (bio->getdbg().video) {
+            bio->printf("[VGA] memory_mapping set to %u\n",
               (unsigned) BX_VGA_THIS s.graphics_ctrl.memory_mapping);
-            bx_printf("graphics mode set to %u\n",
+            bio->printf("[VGA] graphics mode set to %u\n",
               (unsigned) BX_VGA_THIS s.graphics_ctrl.graphics_alpha);
-            bx_printf("odd_even mode set to %u\n",
+            bio->printf("[VGA] odd_even mode set to %u\n",
               (unsigned) BX_VGA_THIS s.graphics_ctrl.odd_even);
-            bx_printf("vga: io write: 3cf: reg 06: value = %02xh\n",
+            bio->printf("[VGA] io write: 3cf: reg 06: value = %02xh\n",
                 (unsigned) value);
             }
 #endif
@@ -1073,7 +1091,7 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
           break;
         default:
           /* ??? */
-          bx_printf("vga: io write: 3cf: index %u unhandled\n",
+          bio->printf("[VGA] io write: 3cf: index %u unhandled\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.index);
         }
       break;
@@ -1081,16 +1099,18 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
     case 0x03d4: /* CRTC Index Register (color emulation modes) */
       BX_VGA_THIS s.CRTC.address = value;
       if (BX_VGA_THIS s.CRTC.address > 0x18)
-        bx_printf("vga_io_write: 3d4: address = %02xh\n",
+	if(bio->getdbg().video)
+        bio->printf("[VGA] vga_io_write: 3d4: address = %02xh\n",
           (unsigned) BX_VGA_THIS s.CRTC.address);
       break;
 
     case 0x03d5: /* CRTC Registers (color emulation modes) */
       if (BX_VGA_THIS s.CRTC.address > 0x18)
-        bx_printf("vga_io_write: 3d5: address = %02xh\n",
+	if(bio->getdbg().video)
+        bio->printf("[VGA] vga_io_write: 3d5: address = %02xh\n",
           (unsigned) BX_VGA_THIS s.CRTC.address);
       BX_VGA_THIS s.CRTC.reg[BX_VGA_THIS s.CRTC.address] = value;
-      //bx_printf("vga: color CRTC Reg[%u] = %02x\n",
+      //bio->printf("[VGA] color CRTC Reg[%u] = %02x\n",
       //  (unsigned) BX_VGA_THIS s.CRTC.address, (unsigned) value);
       if (BX_VGA_THIS s.CRTC.address>=0x0C || BX_VGA_THIS s.CRTC.address<=0x0F) {
         // Start Address or Cursor Location change
@@ -1099,12 +1119,13 @@ BX_VGA_THIS s.sequencer.bit1 = (value >>
       break;
 
     case 0x03da: /* Feature Control (color emulation modes) */
-      bx_printf("vga: io write: 3da: ignoring: feature ctrl & vert sync\n");
+	if(bio->getdbg().floppy)
+		bio->printf("[VGA] io write: 3da: ignoring: feature ctrl & vert sync\n");
       break;
 
     case 0x03c1: /* */
     default:
-      bx_panic("vga: unsupported io write to port %x, val=%02x\n",
+      bio->panic("[VGA] unsupported io write to port %x, val=%02x\n",
         (unsigned) address, (unsigned) value);
     }
 }
@@ -1138,11 +1159,11 @@ bx_vga_c::update(void)
   //        (modes 4 & 5)
   //     2: output data 8 bits at a time from the 4 bit planes
   //        (mode 13 and variants like modeX)
-//fprintf(stderr, "# update()\n");
+//bio->printf("# update()\n");
 
   // if (BX_VGA_THIS s.vga_mem_updated==0 || BX_VGA_THIS s.attribute_ctrl.video_enabled == 0)
   if (BX_VGA_THIS s.vga_mem_updated==0) {
-//bx_printf("update(): updated=%u enabled=%u\n",
+//bio->printf("[VGA] update(): updated=%u enabled=%u\n",
 //(unsigned) BX_VGA_THIS s.vga_mem_updated, (unsigned) BX_VGA_THIS s.attribute_ctrl.video_enabled);
     return;
     }
@@ -1156,7 +1177,7 @@ bx_vga_c::update(void)
     unsigned xti, yti;
 
 
-//bx_printf("update: shiftreg=%u, chain4=%u, mapping=%u\n",
+//bio->printf("[VGA] update: shiftreg=%u, chain4=%u, mapping=%u\n",
 //  (unsigned) BX_VGA_THIS s.graphics_ctrl.shift_reg,
 //  (unsigned) BX_VGA_THIS s.sequencer.chain_four,
 //  (unsigned) BX_VGA_THIS s.graphics_ctrl.memory_mapping);
@@ -1170,7 +1191,7 @@ bx_vga_c::update(void)
 
         determine_screen_dimensions(&iHeight, &iWidth);
 
-        //bx_printf("update(): Mode 12h: 640x480x16colors\n");
+        //bio->printf("[VGA] update(): Mode 12h: 640x480x16colors\n");
         bx_gui.dimension_update(iWidth, iHeight);
 
         for (yti=0; yti<iHeight/Y_TILESIZE; yti++)
@@ -1216,7 +1237,7 @@ bx_vga_c::update(void)
 
       case 1: // output the data in a CGA-compatible 320x200 4 color graphics
               // mode.  (modes 4 & 5)
-        bx_panic("update: shift_reg == 1\n");
+        bio->panic("update: shift_reg == 1\n");
         break; // case 1
 
       case 2: // output the data eight bits at a time from the 4 bit planeBX_VGA_THIS s.
@@ -1228,7 +1249,7 @@ bx_vga_c::update(void)
           // bx_vga_dump_status();
 
           if (BX_VGA_THIS s.misc_output.select_high_bank != 1)
-            bx_panic("update: select_high_bank != 1\n");
+            bio->panic("update: select_high_bank != 1\n");
 
           bx_gui.dimension_update(iWidth, iHeight);
           for (yti=0; yti<iHeight/Y_TILESIZE; yti++)
@@ -1284,7 +1305,7 @@ bx_vga_c::update(void)
         break; // case 2
 
       default:
-        bx_panic("update: shift_reg == %u\n", (unsigned)
+        bio->panic("update: shift_reg == %u\n", (unsigned)
           BX_VGA_THIS s.graphics_ctrl.shift_reg );
       }
 
@@ -1300,7 +1321,7 @@ bx_vga_c::update(void)
     switch (BX_VGA_THIS s.graphics_ctrl.memory_mapping) {
       case 2: // B0000 .. B7FFF
         bx_gui.dimension_update(8*80, 16*25); // ??? should use font size
-//bx_printf("update(): case 2\n");
+//bio->printf("[VGA] update(): case 2\n");
         /* pass old text snapshot & new VGA memory contents */
         start_address = 2*((BX_VGA_THIS s.CRTC.reg[12] << 8) + BX_VGA_THIS s.CRTC.reg[13]);
         cursor_address = 2*((BX_VGA_THIS s.CRTC.reg[0x0e] << 8) |
@@ -1334,7 +1355,7 @@ bx_vga_c::update(void)
         MSL = bx_vga.s.CRTC.reg[0x09] & 0x1f;
         rows = (VDE+1)/(MSL+1);
         if (rows > BX_MAX_TEXT_LINES)
-          bx_panic("vga: text rows>50\n");
+          bio->panic("[VGA] text rows>50\n");
         bx_gui.dimension_update(8*80, 16*rows); // ??? should use font size
         // pass old text snapshot & new VGA memory contents
         start_address = 2*((BX_VGA_THIS s.CRTC.reg[12] << 8) + BX_VGA_THIS s.CRTC.reg[13]);
@@ -1358,7 +1379,7 @@ bx_vga_c::update(void)
         BX_VGA_THIS s.vga_mem_updated = 0;
         break;
       default:
-        bx_printf("update(): color text mode: mem map is %u\n",
+        bio->printf("[VGA] update(): color text mode: mem map is %u\n",
                  (unsigned) BX_VGA_THIS s.graphics_ctrl.memory_mapping);
       }
     }
@@ -1372,8 +1393,8 @@ bx_vga_c::mem_read(Bit32u addr)
 
 
 #if defined(VGA_TRACE_FEATURE)
-//  if (bx_dbg.video)
-//	bx_printf("vga: 8-bit memory read from %08x\n", addr);
+//  if (bio->getdbg().video)
+//	bio->printf("[VGA] 8-bit memory read from %08x\n", addr);
 #endif
 
 // ??? should get rid of references to shift_reg in this function
@@ -1397,14 +1418,14 @@ bx_vga_c::mem_read(Bit32u addr)
       offset = addr - 0xB8000;
 
       if (BX_VGA_THIS s.graphics_ctrl.shift_reg != 2)
-        bx_panic("vga_mem_read: shift_reg = %u\n",
+        bio->panic("vga_mem_read: shift_reg = %u\n",
                  (unsigned) BX_VGA_THIS s.graphics_ctrl.shift_reg);
       return(BX_VGA_THIS s.vga_memory[offset]);
       }
 
     if (BX_VGA_THIS s.graphics_ctrl.memory_mapping != 1) {
-      bx_printf("  location %08x\n", (unsigned) addr);
-      bx_panic("vga_mem_read: graphics: mapping = %u?\n",
+      bio->printf("[VGA]   location %08x\n", (unsigned) addr);
+      bio->panic("vga_mem_read: graphics: mapping = %u?\n",
         (unsigned) BX_VGA_THIS s.graphics_ctrl.memory_mapping);
       return(0);
       }
@@ -1462,7 +1483,7 @@ bx_vga_c::mem_read(Bit32u addr)
         break;
 
       default:
-        bx_panic("vga_mem_read: read mode %u ?\n",
+        bio->panic("vga_mem_read: read mode %u ?\n",
           (unsigned) BX_VGA_THIS s.graphics_ctrl.read_mode);
         return(0);
       }
@@ -1480,8 +1501,8 @@ bx_vga_c::mem_write(Bit32u addr, Bit8u v
   Bit8u new_bit, new_val[4], cpu_data_b[4];
 
 #if defined(VGA_TRACE_FEATURE)
-//  if (bx_dbg.video)
-//	bx_printf("vga: 8-bit memory write to %08x = %02x\n", addr, value);
+//  if (bio->getdbg().video)
+//	bio->printf("[VGA] 8-bit memory write to %08x = %02x\n", addr, value);
 #endif
 
 #ifdef __OS2__
@@ -1510,7 +1531,7 @@ bx_vga_c::mem_write(Bit32u addr, Bit8u v
       offset = addr - 0xB8000;
       }
     else {
-      bx_panic("vga_mem_write: graphics: mapping = %u\n",
+      bio->panic("vga_mem_write: graphics: mapping = %u\n",
                (unsigned) BX_VGA_THIS s.graphics_ctrl.memory_mapping);
       return;
       }
@@ -1576,7 +1597,7 @@ bx_vga_c::mem_write(Bit32u addr, Bit8u v
                     (new_bit ^ (BX_VGA_THIS s.graphics_ctrl.latch[i] & and_mask));
                   break;
                 default:
-                  bx_panic("vga_mem_write: write mode 0: op = %u\n",
+                  bio->panic("vga_mem_write: write mode 0: op = %u\n",
                     (unsigned) BX_VGA_THIS s.graphics_ctrl.raster_op);
                 }
               }
@@ -1600,7 +1621,7 @@ bx_vga_c::mem_write(Bit32u addr, Bit8u v
 
       case 2: /* write mode 2 */
         if (BX_VGA_THIS s.graphics_ctrl.raster_op)
-          bx_panic("vga_mem_write: write mode 2: op = %u\n",
+          bio->panic("vga_mem_write: write mode 2: op = %u\n",
                    (unsigned) BX_VGA_THIS s.graphics_ctrl.raster_op);
         bitmask = BX_VGA_THIS s.graphics_ctrl.bitmask;
         for (i=0; i<4; i++ ) {
@@ -1624,7 +1645,7 @@ bx_vga_c::mem_write(Bit32u addr, Bit8u v
               case 2: /* OR */
               case 3: /* XOR */
               default:
-                bx_panic("vga_mem_write: raster_op = %u?\n",
+                bio->panic("vga_mem_write: raster_op = %u?\n",
                   (unsigned) BX_VGA_THIS s.graphics_ctrl.raster_op);
               }
             }
@@ -1695,7 +1716,7 @@ bx_vga_c::mem_write(Bit32u addr, Bit8u v
         break;
 
       default:
-        bx_panic("vga_mem_write: write mode %u ?\n",
+        bio->panic("vga_mem_write: write mode %u ?\n",
           (unsigned) BX_VGA_THIS s.graphics_ctrl.write_mode);
       }
 
@@ -1729,65 +1750,65 @@ BX_VGA_THIS s.vga_tile_updated[x_tileno]
   void
 bx_vga_c::dump_status(void)
 {
-  bx_printf("s.misc_output.color_emulation = %u\n",
+  bio->printf("[VGA] s.misc_output.color_emulation = %u\n",
             (unsigned) BX_VGA_THIS s.misc_output.color_emulation);
-  bx_printf("s.misc_output.enable_ram = %u\n",
+  bio->printf("[VGA] s.misc_output.enable_ram = %u\n",
             (unsigned) BX_VGA_THIS s.misc_output.enable_ram);
-  bx_printf("s.misc_output.clock_select = %u\n",
+  bio->printf("[VGA] s.misc_output.clock_select = %u\n",
             (unsigned) BX_VGA_THIS s.misc_output.clock_select);
   if (BX_VGA_THIS s.misc_output.clock_select == 0)
-    bx_printf("  25Mhz 640 horiz pixel clock\n");
+    bio->printf("[VGA]   25Mhz 640 horiz pixel clock\n");
   else
-    bx_printf("  28Mhz 720 horiz pixel clock\n");
-  bx_printf("s.misc_output.select_high_bank = %u\n",
+    bio->printf("[VGA]   28Mhz 720 horiz pixel clock\n");
+  bio->printf("[VGA] s.misc_output.select_high_bank = %u\n",
             (unsigned) BX_VGA_THIS s.misc_output.select_high_bank);
-  bx_printf("s.misc_output.horiz_sync_pol = %u\n",
+  bio->printf("[VGA] s.misc_output.horiz_sync_pol = %u\n",
             (unsigned) BX_VGA_THIS s.misc_output.horiz_sync_pol);
-  bx_printf("s.misc_output.vert_sync_pol = %u\n",
+  bio->printf("[VGA] s.misc_output.vert_sync_pol = %u\n",
             (unsigned) BX_VGA_THIS s.misc_output.vert_sync_pol);
   switch ( (BX_VGA_THIS s.misc_output.vert_sync_pol << 1) |
            BX_VGA_THIS s.misc_output.horiz_sync_pol ) {
-    case 0: bx_printf("  (reserved\n"); break;
-    case 1: bx_printf("  400 lines\n"); break;
-    case 2: bx_printf("  350 lines\n"); break;
-    case 3: bx_printf("  480 lines\n"); break;
-    default: bx_printf("  ???\n");
+    case 0: bio->printf("[VGA]   (reserved\n"); break;
+    case 1: bio->printf("[VGA]   400 lines\n"); break;
+    case 2: bio->printf("[VGA]   350 lines\n"); break;
+    case 3: bio->printf("[VGA]   480 lines\n"); break;
+    default: bio->printf("[VGA]   ???\n");
     }
 
-  bx_printf("s.graphics_ctrl.odd_even = %u\n",
+  bio->printf("[VGA] s.graphics_ctrl.odd_even = %u\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.odd_even);
-  bx_printf("s.graphics_ctrl.chain_odd_even = %u\n",
+  bio->printf("[VGA] s.graphics_ctrl.chain_odd_even = %u\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.chain_odd_even);
-  bx_printf("s.graphics_ctrl.shift_reg = %u\n",
+  bio->printf("[VGA] s.graphics_ctrl.shift_reg = %u\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.shift_reg);
-  bx_printf("s.graphics_ctrl.graphics_alpha = %u\n",
+  bio->printf("[VGA] s.graphics_ctrl.graphics_alpha = %u\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.graphics_alpha);
-  bx_printf("s.graphics_ctrl.memory_mapping = %u\n",
+  bio->printf("[VGA] s.graphics_ctrl.memory_mapping = %u\n",
             (unsigned) BX_VGA_THIS s.graphics_ctrl.memory_mapping);
   switch (BX_VGA_THIS s.graphics_ctrl.memory_mapping) {
-    case 0: bx_printf("  A0000-BFFFF\n"); break;
-    case 1: bx_printf("  A0000-AFFFF\n"); break;
-    case 2: bx_printf("  B0000-B7FFF\n"); break;
-    case 3: bx_printf("  B8000-BFFFF\n"); break;
-    default: bx_printf("  ???\n");
+    case 0: bio->printf("[VGA]   A0000-BFFFF\n"); break;
+    case 1: bio->printf("[VGA]   A0000-AFFFF\n"); break;
+    case 2: bio->printf("[VGA]   B0000-B7FFF\n"); break;
+    case 3: bio->printf("[VGA]   B8000-BFFFF\n"); break;
+    default: bio->printf("[VGA]   ???\n");
     }
 
-  bx_printf("s.sequencer.extended_mem = %u\n",
+  bio->printf("[VGA] s.sequencer.extended_mem = %u\n",
             (unsigned) BX_VGA_THIS s.sequencer.extended_mem);
-  bx_printf("s.sequencer.odd_even = %u (inverted)\n",
+  bio->printf("[VGA] s.sequencer.odd_even = %u (inverted)\n",
             (unsigned) BX_VGA_THIS s.sequencer.odd_even);
-  bx_printf("s.sequencer.chain_four = %u\n",
+  bio->printf("[VGA] s.sequencer.chain_four = %u\n",
             (unsigned) BX_VGA_THIS s.sequencer.chain_four);
 
-  bx_printf("s.attribute_ctrl.video_enabled = %u\n",
+  bio->printf("[VGA] s.attribute_ctrl.video_enabled = %u\n",
             (unsigned) BX_VGA_THIS s.attribute_ctrl.video_enabled);
-  bx_printf("s.attribute_ctrl.mode_ctrl.graphics_alpha = %u\n",
+  bio->printf("[VGA] s.attribute_ctrl.mode_ctrl.graphics_alpha = %u\n",
             (unsigned) BX_VGA_THIS s.attribute_ctrl.mode_ctrl.graphics_alpha);
-  bx_printf("s.attribute_ctrl.mode_ctrl.display_type = %u\n",
+  bio->printf("[VGA] s.attribute_ctrl.mode_ctrl.display_type = %u\n",
             (unsigned) BX_VGA_THIS s.attribute_ctrl.mode_ctrl.display_type);
-  bx_printf("s.attribute_ctrl.mode_ctrl.internal_palette_size = %u\n",
+  bio->printf("[VGA] s.attribute_ctrl.mode_ctrl.internal_palette_size = %u\n",
             (unsigned) BX_VGA_THIS s.attribute_ctrl.mode_ctrl.internal_palette_size);
-  bx_printf("s.attribute_ctrl.mode_ctrl.pixel_clock_select = %u\n",
+  bio->printf("[VGA] s.attribute_ctrl.mode_ctrl.pixel_clock_select = %u\n",
             (unsigned) BX_VGA_THIS s.attribute_ctrl.mode_ctrl.pixel_clock_select);
 }
 
