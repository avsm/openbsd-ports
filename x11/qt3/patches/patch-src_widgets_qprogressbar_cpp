$OpenBSD: patch-src_widgets_qprogressbar_cpp,v 1.1 2004/07/22 23:03:09 brad Exp $
--- src/widgets/qprogressbar.cpp.orig	2004-04-19 03:36:18.000000000 -0600
+++ src/widgets/qprogressbar.cpp	2004-06-24 00:00:06.000000000 -0600
@@ -47,6 +47,14 @@
 #endif
 #include <limits.h>
 
+class QProgressBarPrivate
+{
+    public:
+	QProgressBarPrivate() : last_painted_progress( 0 ) { }
+
+    int last_painted_progress;
+};
+
 /*!
     \class QProgressBar qprogressbar.h
     \brief The QProgressBar widget provides a horizontal progress bar.
@@ -99,7 +107,7 @@ QProgressBar::QProgressBar( QWidget *par
       center_indicator( TRUE ),
       auto_indicator( TRUE ),
       percentage_visible( TRUE ),
-      d( 0 )
+      d( new QProgressBarPrivate )
 {
     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
     initFrame();
@@ -130,12 +138,20 @@ QProgressBar::QProgressBar( int totalSte
       center_indicator( TRUE ),
       auto_indicator( TRUE ),
       percentage_visible( TRUE ),
-      d( 0 )
+      d( new QProgressBarPrivate )
 {
     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
     initFrame();
 }
 
+/*!
+    Destroys the object and frees any allocated ressources.
+*/
+
+QProgressBar::~QProgressBar()
+{
+    delete d;
+}
 
 /*!
     Reset the progress bar. The progress bar "rewinds" and shows no
@@ -188,11 +204,16 @@ void QProgressBar::setProgress( int prog
 	 progress < 0 || ( ( progress > total_steps ) && total_steps ) )
 	return;
 
+    const bool needRepaint = isVisible() && requireRepaint( progress );
+
     progress_val = progress;
 
     setIndicator( progress_str, progress_val, total_steps );
 
-    repaint( FALSE );
+    if ( needRepaint ) {
+	repaint( FALSE );
+	d->last_painted_progress = progress;
+    }
 
 #if defined(QT_ACCESSIBILITY_SUPPORT)
     QAccessible::updateAccessibility( this, 0, QAccessible::ValueChanged );
@@ -318,6 +339,31 @@ void QProgressBar::styleChange( QStyle& 
     QFrame::styleChange( old );
 }
 
+/*!
+    This method returns whether changing the progress to the \a newValue
+    would require a repaint of the progress bar. This allows efficient
+    repainting.
+*/
+bool QProgressBar::requireRepaint( int newProgress ) const
+{
+    if ( newProgress == progress_val ||
+	 newProgress == d->last_painted_progress ) {
+	return false;
+    }
+
+    const int width = contentsRect().width();
+    if ( width == 0 ) {
+	return false;
+    }
+
+    float progressPerPixel = 1.0;
+    if ( total_steps > width ) {
+	progressPerPixel = float( total_steps ) / float( width );
+    }
+
+    const int delta = d->last_painted_progress - newProgress;
+    return QABS( delta ) >= progressPerPixel;
+}
 
 /*!
     This method is called to generate the text displayed in the center
