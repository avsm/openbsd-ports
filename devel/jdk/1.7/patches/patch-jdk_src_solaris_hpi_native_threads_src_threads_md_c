$OpenBSD: patch-jdk_src_solaris_hpi_native_threads_src_threads_md_c,v 1.1 2008/03/19 18:05:46 kurt Exp $
--- jdk/src/solaris/hpi/native_threads/src/threads_md.c.orig	Tue Oct 30 05:04:03 2007
+++ jdk/src/solaris/hpi/native_threads/src/threads_md.c	Thu Nov  8 09:26:40 2007
@@ -54,6 +54,10 @@ extern int InitializeIO(rlim_t limit);
 #error That can NOT possibly be right.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && !defined(SA_SIGINFO)
+#error That can NOT possibly be right.
+#endif
+
 #ifdef SA_SIGINFO
 static void sigusr1Handler(int sig, siginfo_t *info, void *uc);
 #else
@@ -97,9 +101,14 @@ static thread_key_t tid_key = (thread_key_t) -1;
 #ifdef __linux__
 thread_key_t intrJmpbufkey;
 static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
+#elif defined(__OpenBSD__)
+thread_key_t sigusr1Jmpbufkey;
+sigset_t sigusr1Mask = sigmask(SIGUSR1);
+static sigset_t squm = sigmask(SIGUSR1);
 #else
 thread_key_t sigusr1Jmpbufkey;
 sigset_t sigusr1Mask = {{sigmask(SIGUSR1), 0, 0, 0}};
+static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
 #endif
 
 /*
@@ -170,9 +179,6 @@ sysThreadCheckStack()
     }
 }
 
-#ifndef __linux__
-static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
-#endif
 
 
 /*
@@ -187,7 +193,7 @@ sysThreadAlloc(sys_thread_t **tidP)
     if (tid == NULL) {
         return SYS_NOMEM;
     }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
 
@@ -474,7 +480,7 @@ sysThreadCreate(sys_thread_t **tidP, long ss, void (*s
     }
     *tidP = tid;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
     /* Install the backpointer to the Thread object */
@@ -517,6 +523,7 @@ sysThreadCreate(sys_thread_t **tidP, long ss, void (*s
     }
     /* Create the thread. The thread will block waiting to be suspended */
     err = pthread_create(&tid->sys_thread, &attr, _start, (void *)tid);
+    pthread_attr_destroy(&attr);
     sysAssert(err == 0);
     if (err == 0) {
         err = sem_wait(&tid->sem_suspended);
@@ -1049,7 +1056,18 @@ sysGetSysInfo()
          * we want the number of processors configured not the number online
          * since processors may be turned on and off dynamically.
          */
+#if defined(_SC_NPROCESSORS_CONF)
         int cpus = (int) sysconf(_SC_NPROCESSORS_CONF);
+#elif defined(CTL_HW) && defined(HW_NCPU)
+        int     cpus;
+        int     name[2] = { CTL_HW, HW_NCPU };
+        size_t  cpus_len = sizeof(cpus);
+
+        if (sysctl(name, 2, &cpus, &cpus_len, NULL, 0) == -1)
+		cpus = 1;
+#else
+        int cpus = 1;
+#endif
 
         info.isMP = (cpus < 0) ? 1 : (cpus > 1);
         info.name = "native threads";
