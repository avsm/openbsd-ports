$OpenBSD: patch-menu_c,v 1.3 2003/04/07 19:30:21 fgsch Exp $
--- menu.c.orig	Thu Feb 20 10:01:13 2003
+++ menu.c	Fri Apr  4 00:16:19 2003
@@ -329,7 +329,7 @@ void flush_caches(struct terminal *term,
 /* jde v historii o psteps polozek dozadu */
 void go_backwards(struct terminal *term, void *psteps, struct session *ses)
 {
-	int steps = (int) psteps;
+	int steps = (intptr_t) psteps;
 
 	/*if (ses->tq_goto_position)
 		--steps;
@@ -363,7 +363,7 @@ void history_menu(struct terminal *term,
 	foreach(l, ses->history) {
 		if (n/* || ses->tq_goto_position*/) {
 			if (!mi && !(mi = new_menu(3))) return;
-			add_to_menu(&mi, stracpy(l->url), "", "", MENU_FUNC go_backwards, (void *) n, 0);
+			add_to_menu(&mi, stracpy(l->url), "", "", MENU_FUNC go_backwards, (void *)(intptr_t) n, 0);
 		}
 		n++;
 	}
@@ -405,7 +405,7 @@ void menu_toggle(struct terminal *term, 
 
 void display_codepage(struct terminal *term, void *pcp, struct session *ses)
 {
-	int cp = (int)pcp;
+	int cp = (intptr_t)pcp;
 	struct term_spec *t = new_term_spec(term->term);
 	if (t) t->charset = cp;
 	cls_redraw_all_terminals();
@@ -413,7 +413,7 @@ void display_codepage(struct terminal *t
 
 void assumed_codepage(struct terminal *term, void *pcp, struct session *ses)
 {
-	int cp = (int)pcp;
+	int cp = (intptr_t)pcp;
 	ses->ds.assume_cp = cp;
 	redraw_terminal_cls(term);
 }
@@ -426,7 +426,7 @@ void charset_list(struct terminal *term,
 	if (!(mi = new_menu(1))) return;
 	for (i = 0; (n = get_cp_name(i)); i++) {
 		if (is_cp_special(i)) continue;
-		add_to_menu(&mi, get_cp_name(i), "", "", MENU_FUNC display_codepage, (void *)i, 0);
+		add_to_menu(&mi, get_cp_name(i), "", "", MENU_FUNC display_codepage, (void *)(intptr_t)i, 0);
 	}
 	sel = ses->term->spec->charset;
 	if (sel < 0) sel = 0;
@@ -435,7 +435,7 @@ void charset_list(struct terminal *term,
 
 void set_val(struct terminal *term, void *ip, int *d)
 {
-	*d = (int)ip;
+	*d = (intptr_t)ip;
 }
 
 void charset_sel_list(struct terminal *term, struct session *ses, int *ptr)
@@ -445,7 +445,7 @@ void charset_sel_list(struct terminal *t
 	struct menu_item *mi;
 	if (!(mi = new_menu(1))) return;
 	for (i = 0; (n = get_cp_name(i)); i++) {
-		add_to_menu(&mi, get_cp_name(i), "", "", MENU_FUNC set_val, (void *)i, 0);
+		add_to_menu(&mi, get_cp_name(i), "", "", MENU_FUNC set_val, (void *)(intptr_t)i, 0);
 	}
 	sel = *ptr;
 	if (sel < 0) sel = 0;
@@ -738,26 +738,68 @@ int dlg_http_options(struct dialog_data 
 	return 0;
 }
 
+unsigned char *ftp_labels[] = { TEXT(T_USE_PASSIVE), TEXT(T_PASSWORD_FOR_ANONYMOUS_LOGIN) };
+
+void ftpopt_fn(struct dialog_data *dlg)
+{
+	struct terminal *term = dlg->win->term;
+	int max = 0, min = 0;
+	int w, rw;
+	int y = 0;
+	checkboxes_width(term, dlg->dlg->udata, &max, max_text_width);
+	checkboxes_width(term, dlg->dlg->udata, &min, min_text_width);
+	max_text_width(term, ftp_labels[1], &max, AL_LEFT);
+	min_text_width(term, ftp_labels[1], &min, AL_LEFT);
+	max_buttons_width(term, dlg->items + dlg->n - 2, 2, &max);
+	min_buttons_width(term, dlg->items + dlg->n - 2, 2, &min);
+	w = term->x * 9 / 10 - 2 * DIALOG_LB;
+	if (w > max) w = max;
+	if (w < min) w = min;
+	if (w > term->x - 2 * DIALOG_LB) w = term->x - 2 * DIALOG_LB;
+	if (w < 5) w = 5;
+	rw = 0;
+	dlg_format_checkboxes(dlg, NULL, dlg->items, dlg->n - 3, 0, &y, w, &rw, dlg->dlg->udata);
+	y += gf_val(1, G_BFU_FONT_SIZE);
+	dlg_format_text(dlg, NULL, ftp_labels[1], 0, &y, w, &rw, COLOR_DIALOG_TEXT, AL_LEFT);
+	y += gf_val(1, 2 * G_BFU_FONT_SIZE);
+	dlg_format_buttons(dlg, NULL, dlg->items + dlg->n - 2, 2, 0, &y, w, &rw, AL_CENTER);
+	w = rw;
+	dlg->xw = rw + 2 * DIALOG_LB;
+	dlg->yw = y + 2 * DIALOG_TB;
+	center_dlg(dlg);
+	draw_dlg(dlg);
+	y = dlg->y + DIALOG_TB + gf_val(1, G_BFU_FONT_SIZE);
+	dlg_format_checkboxes(dlg, term, dlg->items, dlg->n - 3, dlg->x + DIALOG_LB, &y, w, NULL, dlg->dlg->udata);
+	y += gf_val(1, G_BFU_FONT_SIZE);
+	dlg_format_text(dlg, term, ftp_labels[1], dlg->x + DIALOG_LB, &y, w, NULL, COLOR_DIALOG_TEXT, AL_LEFT);
+	dlg_format_field(dlg, term, dlg->items + 1, dlg->x + DIALOG_LB, &y, w, NULL, AL_LEFT);
+	y += gf_val(1, G_BFU_FONT_SIZE);
+	dlg_format_buttons(dlg, term, dlg->items + dlg->n - 2, 2, dlg->x + DIALOG_LB, &y, w, &rw, AL_CENTER);
+}
+
 int dlg_ftp_options(struct dialog_data *dlg, struct dialog_item_data *di)
 {
 	struct dialog *d;
-	if (!(d = mem_alloc(sizeof(struct dialog) + 4 * sizeof(struct dialog_item)))) return 0;
-	memset(d, 0, sizeof(struct dialog) + 4 * sizeof(struct dialog_item));
+	if (!(d = mem_alloc(sizeof(struct dialog) + 5 * sizeof(struct dialog_item)))) return 0;
+	memset(d, 0, sizeof(struct dialog) + 5 * sizeof(struct dialog_item));
 	d->title = TEXT(T_FTP_OPTIONS);
-	d->fn = input_field_fn;
-	d->udata = TEXT(T_PASSWORD_FOR_ANONYMOUS_LOGIN);
-	d->items[0].type = D_FIELD;
-	d->items[0].dlen = MAX_STR_LEN;
-	d->items[0].data = di->cdata;
-	d->items[1].type = D_BUTTON;
-	d->items[1].gid = B_ENTER;
-	d->items[1].fn = ok_dialog;
-	d->items[1].text = TEXT(T_OK);
+	d->fn = ftpopt_fn;
+	d->udata = ftp_labels;
+	d->items[0].type = D_CHECKBOX;
+	d->items[0].dlen = sizeof(int);
+	d->items[0].data = (void *)&ftp_passive;
+	d->items[1].type = D_FIELD;
+	d->items[1].dlen = MAX_STR_LEN;
+	d->items[1].data = di->cdata;
 	d->items[2].type = D_BUTTON;
-	d->items[2].gid = B_ESC;
-	d->items[2].fn = cancel_dialog;
-	d->items[2].text = TEXT(T_CANCEL);
-	d->items[3].type = D_END;
+	d->items[2].gid = B_ENTER;
+	d->items[2].fn = ok_dialog;
+	d->items[2].text = TEXT(T_OK);
+	d->items[3].type = D_BUTTON;
+	d->items[3].gid = B_ESC;
+	d->items[3].fn = cancel_dialog;
+	d->items[3].text = TEXT(T_CANCEL);
+	d->items[4].type = D_END;
  	do_dialog(dlg->win->term, d, getml(d, NULL));
 	return 0;
 }
@@ -1739,7 +1781,7 @@ void miscelaneous_options(struct termina
 
 void menu_set_language(struct terminal *term, void *pcp, struct session *ses)
 {
-	set_language((int)pcp);
+	set_language((intptr_t)pcp);
 	cls_redraw_all_terminals();
 }
 
@@ -1751,7 +1793,7 @@ void menu_language_list(struct terminal 
 	if (!(mi = new_menu(1))) return;
 	for (i = 0; i < n_languages(); i++) {
 		n = language_name(i);
-		add_to_menu(&mi, n, "", "", MENU_FUNC menu_set_language, (void *)i, 0);
+		add_to_menu(&mi, n, "", "", MENU_FUNC menu_set_language, (void *)(intptr_t)i, 0);
 	}
 	sel = current_language;
 	do_menu_selected(term, mi, ses, sel);
