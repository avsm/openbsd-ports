$OpenBSD: patch-cpu_access_cc,v 1.1 2001/02/02 16:59:06 todd Exp $
--- cpu/access.cc.orig	Sat Mar 25 21:39:07 2000
+++ cpu/access.cc	Tue Oct 31 12:48:34 2000
@@ -39,18 +39,18 @@ BX_CPU_C::write_virtual_checks(bx_segmen
 
   if ( protected_mode() ) {
     if ( seg->cache.valid==0 ) {
-      bx_printf("seg = %s\n", BX_CPU_THIS_PTR strseg(seg));
-      bx_printf("seg->selector.value = %04x\n", (unsigned) seg->selector.value);
-      bx_printf("write_virtual_checks: valid bit = 0\n");
-bx_printf("CS: %04x\n", (unsigned) BX_CPU_THIS_PTR sregs[1].selector.value);
-bx_printf("IP: %04x\n", (unsigned) BX_CPU_THIS_PTR prev_eip);
+      bio->printf("[CPU%u] seg = %s\n", BX_CPU_THIS_PTR strseg(seg), BX_SIM_ID);
+      bio->printf("[CPU%u] seg->selector.value = %04x\n", BX_SIM_ID, (unsigned) seg->selector.value);
+      bio->printf("[CPU%u] write_virtual_checks: valid bit = 0\n", BX_SIM_ID);
+bio->printf("[CPU%u] CS: %04x\n", BX_SIM_ID, (unsigned) BX_CPU_THIS_PTR sregs[1].selector.value);
+bio->printf("[CPU%u] IP: %04x\n", BX_SIM_ID, (unsigned) BX_CPU_THIS_PTR prev_eip);
 debug(BX_CPU_THIS_PTR eip);
       exception(BX_GP_EXCEPTION, 0, 0);
       return;
       }
 
     if (seg->cache.p == 0) { /* not present */
-bx_printf("write_virtual_checks(): segment not present\n");
+bio->printf("[CPU%u] write_virtual_checks(): segment not present\n", BX_SIM_ID);
       exception(int_number(seg), 0, 0);
       return;
       }
@@ -62,13 +62,13 @@ bx_printf("write_virtual_checks(): segme
       case 10: case 11: // execute/read
       case 12: case 13: // execute only, conforming
       case 14: case 15: // execute/read-only, conforming
-bx_printf("write_virtual_checks(): no write access to seg\n");
+bio->printf("[CPU%u] write_virtual_checks(): no write access to seg\n", BX_SIM_ID);
         exception(int_number(seg), 0, 0);
         return;
 
       case 2: case 3: /* read/write */
         if ( (offset+length-1) > seg->cache.u.segment.limit_scaled ) {
-bx_printf("write_virtual_checks(): write beyond limit, r/w\n");
+bio->printf("[CPU%u] write_virtual_checks(): write beyond limit, r/w\n", BX_SIM_ID);
           exception(int_number(seg), 0, 0);
           return;
           }
@@ -82,7 +82,7 @@ bx_printf("write_virtual_checks(): write
         if ( (offset <= seg->cache.u.segment.limit_scaled) ||
              (offset > upper_limit) ||
              ((upper_limit - offset) < (length - 1)) ) {
-bx_printf("write_virtual_checks(): write beyond limit, r/w ED\n");
+bio->printf("[CPU%] write_virtual_checks(): write beyond limit, r/w ED\n", BX_SIM_ID);
           exception(int_number(seg), 0, 0);
           return;
           }
@@ -94,7 +94,7 @@ bx_printf("write_virtual_checks(): write
 
   else { /* real mode */
     if ( (offset + length - 1)  >  seg->cache.u.segment.limit_scaled) {
-      //bx_printf("write_virtual_checks() SEG EXCEPTION:  %x:%x + %x\n",
+      //bio->printf("[CPU%u] write_virtual_checks() SEG EXCEPTION:  %x:%x + %x\n", BX_SIM_ID,
       //  (unsigned) seg->selector.value, (unsigned) offset, (unsigned) length);
       if (seg == & BX_CPU_THIS_PTR sregs[2]) exception(BX_SS_EXCEPTION, 0, 0);
       else exception(BX_GP_EXCEPTION, 0, 0);
@@ -111,19 +111,19 @@ BX_CPU_C::read_virtual_checks(bx_segment
 
   if ( protected_mode() ) {
     if ( seg->cache.valid==0 ) {
-      bx_printf("seg = %s\n", BX_CPU_THIS_PTR strseg(seg));
-      bx_printf("seg->selector.value = %04x\n", (unsigned) seg->selector.value);
-      //bx_printf("read_virtual_checks: valid bit = 0\n");
-      //bx_printf("CS: %04x\n", (unsigned)
+      bio->printf("[CPU%u] seg = %s\n", BX_CPU_THIS_PTR strseg(seg), BX_SIM_ID);
+      bio->printf("[CPU%u] seg->selector.value = %04x\n", BX_SIM_ID, (unsigned) seg->selector.value);
+      //bio->printf("[CPU%u] read_virtual_checks: valid bit = 0\n", BX_SIM_ID);
+      //bio->printf("[CPU%u] CS: %04x\n", BX_SIM_ID, (unsigned)
       //   BX_CPU_THIS_PTR sregs[1].selector.value);
-      //bx_printf("IP: %04x\n", (unsigned) BX_CPU_THIS_PTR prev_eip);
+      //bio->printf("[CPU%u] IP: %04x\n", BX_SIM_ID, (unsigned) BX_CPU_THIS_PTR prev_eip);
       //debug(BX_CPU_THIS_PTR eip);
       exception(BX_GP_EXCEPTION, 0, 0);
       return;
       }
 
     if (seg->cache.p == 0) { /* not present */
-bx_printf("read_virtual_checks(): segment not present\n");
+bio->printf("[CPU%u] read_virtual_checks(): segment not present\n", BX_SIM_ID);
       exception(int_number(seg), 0, 0);
       return;
       }
@@ -133,7 +133,7 @@ bx_printf("read_virtual_checks(): segmen
       case 10: case 11: /* execute/read */
       case 14: case 15: /* execute/read-only, conforming */
         if ( (offset+length-1) > seg->cache.u.segment.limit_scaled ) {
-bx_printf("read_virtual_checks(): write beyond limit\n");
+bio->printf("[CPU%u] read_virtual_checks(): write beyond limit\n", BX_SIM_ID);
           exception(int_number(seg), 0, 0);
           return;
           }
@@ -141,7 +141,7 @@ bx_printf("read_virtual_checks(): write 
 
       case 2: case 3: /* read/write */
         if ( (offset+length-1) > seg->cache.u.segment.limit_scaled ) {
-bx_printf("read_virtual_checks(): write beyond limit\n");
+bio->printf("[CPU%u] read_virtual_checks(): write beyond limit\n", BX_SIM_ID);
           exception(int_number(seg), 0, 0);
           return;
           }
@@ -155,7 +155,7 @@ bx_printf("read_virtual_checks(): write 
         if ( (offset <= seg->cache.u.segment.limit_scaled) ||
              (offset > upper_limit) ||
              ((upper_limit - offset) < (length - 1)) ) {
-bx_printf("read_virtual_checks(): write beyond limit\n");
+bio->printf("[CPU%u] read_virtual_checks(): write beyond limit\n", BX_SIM_ID);
           exception(int_number(seg), 0, 0);
           return;
           }
@@ -169,7 +169,7 @@ bx_printf("read_virtual_checks(): write 
         if ( (offset <= seg->cache.u.segment.limit_scaled) ||
              (offset > upper_limit) ||
              ((upper_limit - offset) < (length - 1)) ) {
-bx_printf("read_virtual_checks(): write beyond limit\n");
+bio->printf("[CPU%u] read_virtual_checks(): write beyond limit\n", BX_SIM_ID);
           exception(int_number(seg), 0, 0);
           return;
           }
@@ -178,7 +178,7 @@ bx_printf("read_virtual_checks(): write 
       case 8: case 9: /* execute only */
       case 12: case 13: /* execute only, conforming */
         /* can't read or write an execute-only segment */
-bx_printf("read_virtual_checks(): execute only\n");
+bio->printf("[CPU%u] read_virtual_checks(): execute only\n", BX_SIM_ID);
         exception(int_number(seg), 0, 0);
         return;
         break;
@@ -188,7 +188,7 @@ bx_printf("read_virtual_checks(): execut
 
   else { /* real mode */
     if ( (offset + length - 1)  >  seg->cache.u.segment.limit_scaled) {
-      //bx_printf("read_virtual_checks() SEG EXCEPTION:  %x:%x + %x\n",
+      //bio->printf("[CPU%u] read_virtual_checks() SEG EXCEPTION:  %x:%x + %x\n", BX_SIM_ID,
       //  (unsigned) seg->selector.value, (unsigned) offset, (unsigned) length);
       if (seg == & BX_CPU_THIS_PTR sregs[2]) exception(BX_SS_EXCEPTION, 0, 0);
       else exception(BX_GP_EXCEPTION, 0, 0);
@@ -210,7 +210,7 @@ BX_CPU_C::strseg(bx_segment_reg_t *seg)
   else if (seg == &BX_CPU_THIS_PTR sregs[4]) return("FS");
   else if (seg == &BX_CPU_THIS_PTR sregs[5]) return("GS");
   else {
-    bx_printf("undefined segment passed to strseg()!\n");
+    bio->printf("[CPU%u] undefined segment passed to strseg()!\n", BX_SIM_ID);
     return("??");
     }
 }
