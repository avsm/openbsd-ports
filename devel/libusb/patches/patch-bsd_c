$OpenBSD: patch-bsd_c,v 1.11 2011/01/17 18:03:49 sebastia Exp $

usb_os_find_busses(): these ioctls only need read access.  do not
  force read-write access to /dev/usb* to use libusb.

usb_os_find_devices(): ugen(4) aren't necessarily the first driver
  to attach to the device, since ugen can attach to unclaimed
  interfaces.


--- bsd.c.orig	Sat Mar  4 03:52:46 2006
+++ bsd.c	Mon Jan 17 08:24:49 2011
@@ -361,7 +361,7 @@ int usb_bulk_read(usb_dev_handle *dev, int ep, char *b
 int usb_interrupt_write(usb_dev_handle *dev, int ep, char *bytes, int size,
                         int timeout)
 {
-  int fd, ret, sent = 0;
+  int fd, ret;
 
   /* Ensure the endpoint address is correct */
   ep &= ~USB_ENDPOINT_IN;
@@ -383,8 +383,7 @@ int usb_interrupt_write(usb_dev_handle *dev, int ep, c
     USB_ERROR_STR(-errno, "error setting timeout: %s",
                   strerror(errno));
 
-  do {
-    ret = write(fd, bytes+sent, size-sent);
+  ret = write(fd, bytes, size);
     if (ret < 0)
 #ifdef __FreeBSD_kernel__
       USB_ERROR_STR(-errno, "error writing to interrupt endpoint %s.%d: %s",
@@ -394,16 +393,13 @@ int usb_interrupt_write(usb_dev_handle *dev, int ep, c
                   dev->device->filename, UE_GET_ADDR(ep), strerror(errno));
 #endif
 
-    sent += ret;
-  } while (ret > 0 && sent < size);
-
-  return sent;
+  return ret;
 }
 
 int usb_interrupt_read(usb_dev_handle *dev, int ep, char *bytes, int size,
                        int timeout)
 {
-  int fd, ret, retrieved = 0, one = 1;
+  int fd, ret, one = 1;
 
   /* Ensure the endpoint address is correct */
   ep |= USB_ENDPOINT_IN;
@@ -428,8 +424,7 @@ int usb_interrupt_read(usb_dev_handle *dev, int ep, ch
   if (ret < 0)
     USB_ERROR_STR(-errno, "error setting short xfer: %s", strerror(errno));
 
-  do {
-    ret = read(fd, bytes+retrieved, size-retrieved);
+  ret = read(fd, bytes, size);
     if (ret < 0)
 #ifdef __FreeBSD_kernel__
       USB_ERROR_STR(-errno, "error reading from interrupt endpoint %s.%d: %s",
@@ -438,10 +433,7 @@ int usb_interrupt_read(usb_dev_handle *dev, int ep, ch
       USB_ERROR_STR(-errno, "error reading from interrupt endpoint %s.%02d: %s",
                   dev->device->filename, UE_GET_ADDR(ep), strerror(errno));
 #endif
-    retrieved += ret;
-  } while (ret > 0 && retrieved < size);
-
-  return retrieved;
+  return ret;
 }
 
 int usb_control_msg(usb_dev_handle *dev, int requesttype, int request,
@@ -477,7 +469,7 @@ int usb_control_msg(usb_dev_handle *dev, int requestty
     USB_ERROR_STR(-errno, "error sending control message: %s",
                   strerror(errno));
 
-  return UGETW(req.ucr_request.wLength);
+  return req.ucr_actlen;
 }
 
 int usb_os_find_busses(struct usb_bus **busses)
@@ -491,7 +483,7 @@ int usb_os_find_busses(struct usb_bus **busses)
     struct usb_bus *bus;
 
     snprintf(buf, sizeof(buf) - 1, "/dev/usb%d", controller);
-    fd = open(buf, O_RDWR);
+    fd = open(buf, O_RDONLY);
     if (fd < 0) {
       if (usb_debug >= 2)
         if (errno != ENXIO && errno != ENOENT)
@@ -525,7 +517,8 @@ int usb_os_find_devices(struct usb_bus *bus, struct us
 {
   struct usb_device *fdev = NULL;
   int cfd, dfd;
-  int device;
+  int device, i;
+  char devname[USB_MAX_DEVNAMELEN];
 
   cfd = open(bus->dirname, O_RDONLY);
   if (cfd < 0)
@@ -543,15 +536,20 @@ int usb_os_find_devices(struct usb_bus *bus, struct us
       continue;
 
     /* There's a device; is it one we should mess with? */
-
-    if (strncmp(di.udi_devnames[0], "ugen", 4) != 0)
-      /* best not to play with things we don't understand */
+    devname[0] = '\0';
+    for (i = 0; i < USB_MAX_DEVNAMES; i++) {
+      if (strncmp(di.udi_devnames[i], "ugen", 4) == 0) {
+	snprintf(devname, sizeof(devname), di.udi_devnames[i]);
+        break;
+      }
+    }
+    if (devname[0] == '\0')
       continue;
 
 #ifdef __FreeBSD_kernel__
     snprintf(buf, sizeof(buf) - 1, "/dev/%s", di.udi_devnames[0]);
 #else
-    snprintf(buf, sizeof(buf) - 1, "/dev/%s.00", di.udi_devnames[0]);
+    snprintf(buf, sizeof(buf) - 1, "/dev/%s.00", devname);
 #endif
 
     /* Open its control endpoint */
@@ -575,7 +573,7 @@ int usb_os_find_devices(struct usb_bus *bus, struct us
      * This seemed easier than having 2 variables...
      */
 #if (__NetBSD__ || __OpenBSD__)
-    snprintf(buf, sizeof(buf) - 1, "/dev/%s", di.udi_devnames[0]);
+    snprintf(buf, sizeof(buf) - 1, "/dev/%s", devname);
 #endif
 
     strncpy(dev->filename, buf, sizeof(dev->filename) - 1);
@@ -623,9 +621,21 @@ int usb_resetep(usb_dev_handle *dev, unsigned int ep)
 
 int usb_clear_halt(usb_dev_handle *dev, unsigned int ep)
 {
-  /* Not yet done, because I haven't needed it. */
+  int ret;
+  struct usb_ctl_request ctl_req;
 
-  USB_ERROR_STR(-ENOSYS, "usb_clear_halt called, unimplemented on BSD");
+  ctl_req.ucr_addr = 0; // Not used for this type of request
+  ctl_req.ucr_request.bmRequestType = UT_WRITE_ENDPOINT;
+  ctl_req.ucr_request.bRequest = UR_CLEAR_FEATURE;
+  USETW(ctl_req.ucr_request.wValue, UF_ENDPOINT_HALT);
+  USETW(ctl_req.ucr_request.wIndex, ep);
+  USETW(ctl_req.ucr_request.wLength, 0);
+  ctl_req.ucr_flags = 0;
+
+  if ((ret = ioctl(dev->fd, USB_DO_REQUEST, &ctl_req)) < 0)
+      USB_ERROR_STR(-errno, "clear_halt:  failed for %d", ep);
+
+  return ret;
 }
 
 int usb_reset(usb_dev_handle *dev)
