$OpenBSD: patch-extras_libdvdcss_css_c,v 1.1.1.1 2001/11/02 15:22:08 espie Exp $
--- extras/libdvdcss/css.c.orig	Mon Oct 22 14:53:44 2001
+++ extras/libdvdcss/css.c	Mon Oct 22 14:59:37 2001
@@ -393,8 +393,11 @@ int CSSGetTitleKey( dvdcss_handle dvdcss
     }
     memcpy( p_key, p_buffer, KEY_SIZE );
     
-    fprintf( stderr, "libdvdcss debug: title key is" );
-    printHex( p_key, KEY_SIZE );
+    if (dvdcss->b_debug)
+    {
+    	fprintf( stderr, "libdvdcss debug: title key is" );
+	printHex( p_key, KEY_SIZE );
+    }
     
     _dvdcss_debug( dvdcss, "got title key" );
     return 1;
@@ -650,9 +653,9 @@ static int CSSAttackPattern( u8 p_sec[0x
  
    DVD specifies that there must only be one type of data in every sector.
    Every sector is one pack and so must obviously be 2048 bytes long.
-   For the last pice of video data before a VOBU boundary there might not
-   be exactly the right amount of data to fill a sector. They one has to 
-   pad the pack to 2048 bytes. For just a few bytes this is doen in the
+   For the last piece of video data before a VOBU boundary there might not
+   be exactly the right amount of data to fill a sector. Then one has to 
+   pad the pack to 2048 bytes. For just a few bytes this is done in the
    header but for any large amount you insert a PES packet from the 
    Padding stream. This looks like 0x00 00 01 be xx xx ff ff ...
    where xx xx is the length of the padding stream.
@@ -665,7 +668,7 @@ static int CSSAttackPadding( u8 p_sec[0x
 
     i_pes_length = (p_sec[0x12]<<8) | p_sec[0x13];
     
-    // Coverd by the test below but usfull for debuging
+    // Covered by the test below but useful for debuging
     if( i_pes_length == 0x800 - 0x14 ) return 0;
     
     /* There must be room for at least 4? bytes of padding stream, 
@@ -676,13 +679,13 @@ static int CSSAttackPadding( u8 p_sec[0x
 	  p_sec[0x14 + i_pes_length + 1] == 0x00 &&
 	  p_sec[0x14 + i_pes_length + 2] == 0x01 ) )
     { 
-      fprintf( stderr, "plain %d %02x %02x %02x %02x (type %02x sub %02x)\n", 
-	       0x800 - 0x14 - 4 - 2 - i_pes_length,
-	       p_sec[0x14 + i_pes_length + 0],
-	       p_sec[0x14 + i_pes_length + 1],
-	       p_sec[0x14 + i_pes_length + 2],
-	       p_sec[0x14 + i_pes_length + 3],
-	       p_sec[0x11], p_sec[0x17 + p_sec[0x16]]);
+//      fprintf( stderr, "plain %d %02x %02x %02x %02x (type %02x sub %02x)\n", 
+//	       0x800 - 0x14 - 4 - 2 - i_pes_length,
+//	       p_sec[0x14 + i_pes_length + 0],
+//	       p_sec[0x14 + i_pes_length + 1],
+//	       p_sec[0x14 + i_pes_length + 2],
+//	       p_sec[0x14 + i_pes_length + 3],
+//	       p_sec[0x11], p_sec[0x17 + p_sec[0x16]]);
       return 0;
     }
     
@@ -716,9 +719,9 @@ static int CSSAttackPadding( u8 p_sec[0x
     {
         //fprintf( stderr, "key is %02x %02x %02x %02x %02x ",
         //	     p_key[0], p_key[1], p_key[2], p_key[3], p_key[4] );
-        fprintf( stderr, "at block %5d padding len %4d "
-		 "type %02x sub %02x\n",  i_pos, i_pes_length, 
-		 p_sec[0x11], p_sec[0x17 + p_sec[0x16]]);
+//    	fprintf( stderr, "at block %5d padding len %4d "
+//		 "type %02x sub %02x\n",  i_pos, i_pes_length, 
+//		 p_sec[0x11], p_sec[0x17 + p_sec[0x16]]);
     }
     
     return 0;
@@ -777,7 +780,7 @@ int CSSGetKey( dvdcss_handle dvdcss, int
 	}
 	
 	if( p_buf[0x0d] & 0x07 )
-	    fprintf( stderr, "stuffing in pack header\n" ); 
+	    _dvdcss_debug( dvdcss, "stuffing in pack header" ); 
 	
         /* PES_scrambling_control does not exist in a system_header or 
 	   a padding stream or a private_stream2. (and others). */
