.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Screen 3"
.TH Screen 3 "2002-09-28" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
Term::Screen \-  A Simple all perl Term::Cap based screen positioning module
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&   require Term::Screen;
.Ve
.PP
.Vb 10
\&   $scr = new Term::Screen;
\&   unless ($scr) { die " Something's wrong \en"; }
\&   $scr->clrscr();
\&   $scr->at(5,3);
\&   $scr->puts("this is some stuff");
\&   $scr->at(10,10)->bold()->puts("hi!")->normal();
\&      # you can concatenate many calls (not getch)
\&   $c = $scr->getch();      # doesn't need Enter key 
\&   ...
\&   if ($scr->key_pressed()) { print "ha you hit a key!"; }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Term::Screen is a very simple screen positioning module that should
work wherever \f(CW\*(C`Term::Cap\*(C'\fR does. It is set up for Unix using stty's but
these dependences are isolated by evals in the \f(CW\*(C`new\*(C'\fR constructor. Thus
you may create a child module implementing Screen with \s-1MS\-DOS\s0, ioctl,
or other means to get raw and unblocked input. This is not a replacement
for Curses \*(-- it has no memory.  This was written so that it could be
easily changed to fit nasty systems, and to be available first thing.
.PP
The input functions getch, key_pressed, echo, and noecho are implemented
so as to work under a fairly standard Unix system. They use 'stty'
to set raw and no echo modes and turn on auto flush. All of these are
\&'eval'ed so that this class can be inherited for new definitions easily.
.PP
Term::Screen was designed to be \*(L"required\*(R", then used with object syntax
as shown above. One quirk (which the author was used to so he didn't
care) is that for function key translation, no delay is set. So for many
terminals to get an esc character, you have to hit another char after it,
generally another esc.
.SH "PUBLIC INTERFACE"
.IX Header "PUBLIC INTERFACE"
Term::Screen has a very minimal set of of fixed character terminal position
and character reading commands:
.IP "\fInew()\fR" 4
.IX Item "new()"
Initialize the screen. Does not clear the screen, but does home the cursor.
.IP "term(term)" 4
.IX Item "term(term)"
Sets or Gets the Term::Cap object used by this object.
.IP "rows(rows)" 4
.IX Item "rows(rows)"
Returns and/or sets the number of rows on the terminal.
.IP "cols(cols)" 4
.IX Item "cols(cols)"
Returns and/or sets the number of cols on the terminal.
.IP "at(row,col)" 4
.IX Item "at(row,col)"
Moves cursor to (row,col) where (0,0) is upper left corner, \- if the spot is
illegal does whatever 'cm' in termcap does, since that is what it uses.
.IP "resize(r,c)" 4
.IX Item "resize(r,c)"
Tell screen the new number of rows & cols physically you can skip the r & c
and get new checked vals from stty or termcap.  Term::Screen does not
handle resize signals internally, but you can do it by checking and updating
screen size using this function.
.IP "\fInormal()\fR" 4
.IX Item "normal()"
Turn off any highlightling (bold, reverse)
.IP "\fIbold()\fR" 4
.IX Item "bold()"
The md value from termcap \- turn on bold usually
.IP "\fIreverse()\fR" 4
.IX Item "reverse()"
The mr value from termcap \- turn on reverse text often. these last 
two default to whatever is available.
.IP "\fIclrscr()\fR" 4
.IX Item "clrscr()"
Clear the screen and home cursor
.IP "\fIclreol()\fR" 4
.IX Item "clreol()"
Clear to the end of the line \- cursor doesn't move
.IP "\fIclreos()\fR" 4
.IX Item "clreos()"
Clear to end of screen \- right and down, cursor doesn't move.
.IP "\fIil()\fR" 4
.IX Item "il()"
Insert blank line before line cursor is on, moving lower lines down.
.IP "\fIdl()\fR" 4
.IX Item "dl()"
Delete line cursor is on, moving lower lines up.
.IP "\fIic_exists()\fR" 4
.IX Item "ic_exists()"
Insert character option is available.
.IP "\fIic()\fR" 4
.IX Item "ic()"
Insert character at current position move rest to the right.
.IP "\fIdc_exists()\fR" 4
.IX Item "dc_exists()"
Delete char option exists and is available.
.IP "\fIdc()\fR" 4
.IX Item "dc()"
Delete character at current position moving rest to the left.
.PP
The following are the I/O functions. They provide standard useful
single character reading values. getch returns either a single char or
the name of a function key when a key is pressed. The only exception is
when you hit a character that is the start of a function key sequence.
In this case getch keeps waiting for the next char to see if it is fn key.
Generally this is the escape key, and why you need to hit esc twice.
To get a stright char, just use the regular 'gets' perl function. You
will need to echo it yourself if you want.
.IP "puts(str)" 4
.IX Item "puts(str)"
Prints \f(CW$s\fR and returns the screen object. Used to do things like
\&\f(CW\*(C`$scr\-\*(C'\fRat(10,0)\->puts(\*(L"Hi!\*(R")\->at(0,0);>. You can just use
print if you want.
.IP "\fIgetch()\fR" 4
.IX Item "getch()"
Returns just a char in raw mode. Function keys are returned as their
capability names, e.g. the up key would return \*(L"ku\*(R".  See the 
\&\f(CW\*(C`get_fn_keys\*(C'\fR function for what a lot of the names are. This will wait
for next char if in a possible fn key string, so you would need to type
\&'esc' 'esc' most likely to get out of getch, since 'esc' is usually the
leading char for function keys. You can use perl's getc, to go 'underneath'
getch if you want. See the table in \fIScreen::get_fn_keys()\fR for more
information.
.IP "def_key('name','input string')" 4
.IX Item "def_key('name','input string')"
Lets you define your own function key sequence.  'name' is what will be
returned by getch.  'input string' is what the fn key sends literally.  This
will override any prev definitions of the input.  A whole bunch of defaults
are defined for xterms rxvt's, etc. in the get_fn_keys function. 
.IP "key_pressed([sec])" 4
.IX Item "key_pressed([sec])"
Returns true if there is a character waiting.  You can pass an option time in
seconds to wait. 
.IP "\fIecho()\fR" 4
.IX Item "echo()"
Tells getch to echo the input to the screen. (the default.)
.IP "\fInoecho()\fR" 4
.IX Item "noecho()"
Tells getch \s-1NOT\s0 to echo input to the screen. 
.IP "\fIflush_input()\fR" 4
.IX Item "flush_input()"
Clears input buffer and removes any incoming chars.
.IP "stuff_input(str)" 4
.IX Item "stuff_input(str)"
Lets you stuff chars into the input buffer to be read like keystrokes.
This is only the \f(CW\*(C`getch\*(C'\fR method buffer, the underlying getc stuff 
is not touched.
.SH "AUTHOR"
.IX Header "AUTHOR"
Term::Screen.pm by Mark Kaehny (kaehny@execpc.com)
Currently maintained by Jonathan Stowe <jns@gellyfish.com>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Please see the \s-1README\s0 file in the distribution kit for the license details
for this module.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Term::Cap, termcap, curses, stty, select
