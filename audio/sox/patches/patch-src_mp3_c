$OpenBSD: patch-src_mp3_c,v 1.1 2008/07/08 15:03:37 naddy Exp $
--- src/mp3.c.orig	Sun Jun 29 18:37:31 2008
+++ src/mp3.c	Sun Jun 29 18:51:20 2008
@@ -423,31 +423,56 @@ st_ssize_t st_mp3write(ft_t ft, st_sample_t *buf, st_s
   struct mp3priv *p = (struct mp3priv *) ft->priv;
   char *mp3buffer;
   int mp3buffer_size;
-  long *buffer_l, *buffer_r;
+  short signed int *buffer_l, *buffer_r = NULL;
   int nsamples = samp/ft->info.channels;
   int i,j;
   st_ssize_t done = 0;
   int written;
 
-  if ( (buffer_r=(long*)malloc(nsamples*sizeof(long))) == NULL){
+  /* NOTE: This logic assumes that "short int" is 16-bits
+   * on all platforms.  It happens to be for all that I know
+   * about.
+   *
+   * Lame ultimately wants data scaled to 16-bit samples
+   * and assumes for the majority of cases that your passing
+   * in something scaled based on passed in datatype
+   * (16, 32, 64, and float).
+   * 
+   * If we used long buffers then this means it expects
+   * different scalling between 32-bit and 64-bit CPU's.
+   *
+   * We might as well scale it ourselfs to 16-bit to allow
+   * malloc()'ing a smaller buffer and call a consistent
+   * interface.
+   */
+  if ((buffer_l =
+       (short signed int *)malloc(nsamples*
+                                  sizeof(short signed int))) == NULL){
     st_fail_errno(ft,ST_ENOMEM,"Memory allocation failed");
     goto end4;
   }
 
-  if (ft->info.channels==2){ /* Why isn't there a lame_encode_buffer_long_interleaved? */
-    if ( (buffer_l=(long*)malloc(nsamples*sizeof(long))) == NULL){
+  if (ft->info.channels == 2){
+    /* lame doesn't support iterleaved samples so we must break
+     * them out into seperate buffers.
+     */
+    if ((buffer_r = 
+         (short signed int *)malloc(nsamples*
+                                    sizeof(short signed int))) == NULL){
       st_fail_errno(ft,ST_ENOMEM,"Memory allocation failed");
       goto end3;
     }
+
     j=0;
-    for (i=0;i<nsamples;i++){
-      buffer_l[i]=(long)buf[j++];   /* Should we paranoically check whether long is actually 32 bits? */
-      buffer_r[i]=(long)buf[j++];
+    for (i=0; i<nsamples; i++){
+      buffer_l[i]=ST_SAMPLE_TO_SIGNED_WORD(buf[j++]);
+      buffer_r[i]=ST_SAMPLE_TO_SIGNED_WORD(buf[j++]);
     }
   }
   else{
-    buffer_l=(long*)buf;
-    memset(buffer_r,0,nsamples*sizeof(long));
+    j=0;
+    for (i=0; i<nsamples; i++)
+      buffer_l[i]=ST_SAMPLE_TO_SIGNED_WORD(buf[j++]);
   }
 
   mp3buffer_size=1.25*nsamples + 7200;
@@ -456,12 +481,9 @@ st_ssize_t st_mp3write(ft_t ft, st_sample_t *buf, st_s
     goto end2;
   }
  
-  if ( (written = lame_encode_buffer_long2(p->gfp,
-                                           buffer_l,
-                                           buffer_r,
-                                           nsamples,
-                                           (unsigned char *)mp3buffer,
-                                           mp3buffer_size)) < 0){
+  if ( (written = lame_encode_buffer(p->gfp, buffer_l, buffer_r,
+                                     nsamples, (unsigned char *)mp3buffer,
+                                     mp3buffer_size)) < 0){
     st_fail_errno(ft,ST_EOF,"Encoding failed");
     goto end;
   }
@@ -477,9 +499,9 @@ st_ssize_t st_mp3write(ft_t ft, st_sample_t *buf, st_s
   free(mp3buffer);
  end2:
   if (ft->info.channels == 2)
-    free(buffer_l);
+    free(buffer_r);
  end3:
-  free(buffer_r);
+  free(buffer_l);
  end4:
   return done;
 }
