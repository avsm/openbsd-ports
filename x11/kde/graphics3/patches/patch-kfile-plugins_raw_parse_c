$OpenBSD: patch-kfile-plugins_raw_parse_c,v 1.1 2006/01/03 14:10:51 espie Exp $
--- kfile-plugins/raw/parse.c.orig	Sat Sep 10 10:19:24 2005
+++ kfile-plugins/raw/parse.c	Sun Nov 20 12:01:25 2005
@@ -10,10 +10,18 @@
    $Date: 2005/05/10 21:43:10 $
  */
 
+/* Hacked for thumbnail extraction in KDE by 
+   Steffen Hansen <hansen@kde.org>
+
+   Based on parse.c and parts of dcraw.c by Dave Coffin
+*/
+
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <ctype.h>
+#include <time.h>
+#include <sys/types.h>
 
 #ifdef WIN32
 #include <winsock2.h>
@@ -32,7 +40,7 @@ typedef long long INT64;
 #endif
 
 typedef unsigned char uchar;
-//typedef unsigned short ushort;
+/*typedef unsigned short ushort;*/
 
 FILE *ifp;
 short order;
@@ -40,12 +48,26 @@ char *fname;
 char make[128], model[128], model2[128], thumb_head[128];
 int width, height, offset, length, bps, is_dng;
 int thumb_offset, thumb_length, thumb_layers;
+float cam_mul[4], pre_mul[4], coeff[3][4];
+#define camera_red  cam_mul[0]
+#define camera_blue cam_mul[2]
+/*float flash_used, canon_5814;*/
+time_t timestamp;
+/*int data_offset, meta_offset*/
+int raw_height, raw_width, top_margin, left_margin;
+static int flip = 0;
 
 struct decode {
   struct decode *branch[2];
   int leaf;
 } first_decode[640], *free_decode;
 
+#define CLASS
+
+#define FORC3 for (c=0; c < 3; c++)
+#define FORC4 for (c=0; c < 4; c++)
+#define FORCC for (c=0; c < colors; c++)
+
 /*
    Get a 2-byte integer, making no assumptions about CPU byte order.
    Nor should we assume that the compiler evaluates left-to-right.
@@ -87,79 +109,11 @@ void tiff_dump(int base, int tag, int ty
   if (count * size[type < 13 ? type:0] > 4)
     fseek (ifp, get4()+base, SEEK_SET);
   save = ftell(ifp);
-  printf("%*stag=0x%x %d, type=%d, count=%d, offset=%06x, data=",
-	level*2, "", tag, tag, type, count, save);
-  if (type==2) putchar('\"');
-  for (j = 0; j < count && j < DLEN; j++)
-    switch (type) {
-      case 1: case 6: case 7:		/* byte values */
-	printf ("%c%02x",(j & 31) || count < 17 ? ' ':'\n', fgetc(ifp) & 0xff);
-	break;
-      case 2:				/* null-terminated ASCII strings */
-	c = fgetc(ifp);
-	putchar(isprint(c) ? c:'.');
-	break;
-      case 3: case 8:			/* word values */
-	printf ("%c%04x",(j & 15) || count < 9 ? ' ':'\n', get2());
-	break;
-      case 4: case 9:			/* dword values */
-	printf ("%c%08x",(j & 7) || count < 5 ? ' ':'\n', get4());
-	break;
-      case 5: case 10:			/* rationals */
-	num = get4();
-	den = get4();
-	printf (" %d/%d", num, den);
-	break;
-    }
-  if (type==2) putchar('\"');
-  putchar('\n');
   fseek (ifp, save, SEEK_SET);
 }
 
 void nikon_decrypt (uchar ci, uchar cj, int tag, int i, int size, uchar *buf)
 {
-  static const uchar xlat[2][256] = {
-  { 0xc1,0xbf,0x6d,0x0d,0x59,0xc5,0x13,0x9d,0x83,0x61,0x6b,0x4f,0xc7,0x7f,0x3d,0x3d,
-    0x53,0x59,0xe3,0xc7,0xe9,0x2f,0x95,0xa7,0x95,0x1f,0xdf,0x7f,0x2b,0x29,0xc7,0x0d,
-    0xdf,0x07,0xef,0x71,0x89,0x3d,0x13,0x3d,0x3b,0x13,0xfb,0x0d,0x89,0xc1,0x65,0x1f,
-    0xb3,0x0d,0x6b,0x29,0xe3,0xfb,0xef,0xa3,0x6b,0x47,0x7f,0x95,0x35,0xa7,0x47,0x4f,
-    0xc7,0xf1,0x59,0x95,0x35,0x11,0x29,0x61,0xf1,0x3d,0xb3,0x2b,0x0d,0x43,0x89,0xc1,
-    0x9d,0x9d,0x89,0x65,0xf1,0xe9,0xdf,0xbf,0x3d,0x7f,0x53,0x97,0xe5,0xe9,0x95,0x17,
-    0x1d,0x3d,0x8b,0xfb,0xc7,0xe3,0x67,0xa7,0x07,0xf1,0x71,0xa7,0x53,0xb5,0x29,0x89,
-    0xe5,0x2b,0xa7,0x17,0x29,0xe9,0x4f,0xc5,0x65,0x6d,0x6b,0xef,0x0d,0x89,0x49,0x2f,
-    0xb3,0x43,0x53,0x65,0x1d,0x49,0xa3,0x13,0x89,0x59,0xef,0x6b,0xef,0x65,0x1d,0x0b,
-    0x59,0x13,0xe3,0x4f,0x9d,0xb3,0x29,0x43,0x2b,0x07,0x1d,0x95,0x59,0x59,0x47,0xfb,
-    0xe5,0xe9,0x61,0x47,0x2f,0x35,0x7f,0x17,0x7f,0xef,0x7f,0x95,0x95,0x71,0xd3,0xa3,
-    0x0b,0x71,0xa3,0xad,0x0b,0x3b,0xb5,0xfb,0xa3,0xbf,0x4f,0x83,0x1d,0xad,0xe9,0x2f,
-    0x71,0x65,0xa3,0xe5,0x07,0x35,0x3d,0x0d,0xb5,0xe9,0xe5,0x47,0x3b,0x9d,0xef,0x35,
-    0xa3,0xbf,0xb3,0xdf,0x53,0xd3,0x97,0x53,0x49,0x71,0x07,0x35,0x61,0x71,0x2f,0x43,
-    0x2f,0x11,0xdf,0x17,0x97,0xfb,0x95,0x3b,0x7f,0x6b,0xd3,0x25,0xbf,0xad,0xc7,0xc5,
-    0xc5,0xb5,0x8b,0xef,0x2f,0xd3,0x07,0x6b,0x25,0x49,0x95,0x25,0x49,0x6d,0x71,0xc7 },
-  { 0xa7,0xbc,0xc9,0xad,0x91,0xdf,0x85,0xe5,0xd4,0x78,0xd5,0x17,0x46,0x7c,0x29,0x4c,
-    0x4d,0x03,0xe9,0x25,0x68,0x11,0x86,0xb3,0xbd,0xf7,0x6f,0x61,0x22,0xa2,0x26,0x34,
-    0x2a,0xbe,0x1e,0x46,0x14,0x68,0x9d,0x44,0x18,0xc2,0x40,0xf4,0x7e,0x5f,0x1b,0xad,
-    0x0b,0x94,0xb6,0x67,0xb4,0x0b,0xe1,0xea,0x95,0x9c,0x66,0xdc,0xe7,0x5d,0x6c,0x05,
-    0xda,0xd5,0xdf,0x7a,0xef,0xf6,0xdb,0x1f,0x82,0x4c,0xc0,0x68,0x47,0xa1,0xbd,0xee,
-    0x39,0x50,0x56,0x4a,0xdd,0xdf,0xa5,0xf8,0xc6,0xda,0xca,0x90,0xca,0x01,0x42,0x9d,
-    0x8b,0x0c,0x73,0x43,0x75,0x05,0x94,0xde,0x24,0xb3,0x80,0x34,0xe5,0x2c,0xdc,0x9b,
-    0x3f,0xca,0x33,0x45,0xd0,0xdb,0x5f,0xf5,0x52,0xc3,0x21,0xda,0xe2,0x22,0x72,0x6b,
-    0x3e,0xd0,0x5b,0xa8,0x87,0x8c,0x06,0x5d,0x0f,0xdd,0x09,0x19,0x93,0xd0,0xb9,0xfc,
-    0x8b,0x0f,0x84,0x60,0x33,0x1c,0x9b,0x45,0xf1,0xf0,0xa3,0x94,0x3a,0x12,0x77,0x33,
-    0x4d,0x44,0x78,0x28,0x3c,0x9e,0xfd,0x65,0x57,0x16,0x94,0x6b,0xfb,0x59,0xd0,0xc8,
-    0x22,0x36,0xdb,0xd2,0x63,0x98,0x43,0xa1,0x04,0x87,0x86,0xf7,0xa6,0x26,0xbb,0xd6,
-    0x59,0x4d,0xbf,0x6a,0x2e,0xaa,0x2b,0xef,0xe6,0x78,0xb6,0x4e,0xe0,0x2f,0xdc,0x7c,
-    0xbe,0x57,0x19,0x32,0x7e,0x2a,0xd0,0xb8,0xba,0x29,0x00,0x3c,0x52,0x7d,0xa8,0x49,
-    0x3b,0x2d,0xeb,0x25,0x49,0xfa,0xa3,0xaa,0x39,0xa7,0xc5,0xa7,0x50,0x11,0x36,0xfb,
-    0xc6,0x67,0x4a,0xf5,0xa5,0x12,0x65,0x7e,0xb0,0xdf,0xaf,0x4e,0xb3,0x61,0x7f,0x2f } };
-  uchar ck=0x60;
-
-  if (strncmp (buf, "02", 2)) return;
-  ci = xlat[0][ci];
-  cj = xlat[1][cj];
-  printf("Decrypted tag 0x%x:\n%*s", tag, (i & 31)*3, "");
-  for (; i < size; i++)
-    printf("%02x%c", buf[i] ^ (cj += ci * ck++), (i & 31) == 31 ? '\n':' ');
-  if (size & 31) puts("");
 }
 
 int parse_tiff_ifd (int base, int level);
@@ -172,7 +126,6 @@ void nef_parse_makernote (base)
   short sorder;
   char buf[10];
 
-  puts("  Nikon MakerNote:");
 /*
    The MakerNote might have its own TIFF header (possibly with
    its own byte-order!), or it might just be a table.
@@ -222,7 +175,7 @@ void nef_parse_makernote (base)
       thumb_length = count;
     }
     if (tag == 0x280 && type == 1) {	/* EPSON */
-      strcpy (thumb_head, "\xff");
+      strncpy (thumb_head, "\xff", sizeof(thumb_head) );
       thumb_offset = ftell(ifp)+1;
       thumb_length = count-1;
     }
@@ -253,7 +206,6 @@ void nef_parse_exif(int base)
 {
   int entries, tag, type, count, save;
 
-  puts("Nikon EXIF tag:");
   entries = get2();
   while (entries--) {
     save = ftell(ifp);
@@ -271,6 +223,7 @@ int parse_tiff_ifd (int base, int level)
 {
   int entries, tag, type, count, slen, save, save2, val, i;
   int comp=0;
+  static const int flip_map[] = { 0,1,3,2,4,6,7,5 };
 
   entries = get2();
   if (entries > 255) return 1;
@@ -331,6 +284,9 @@ int parse_tiff_ifd (int base, int level)
       case 0x111:			/* StripOffset */
 	if (!offset || is_dng) offset = val;
 	break;
+      case 0x112:           /* Orientation */
+	flip = flip_map[(val-1) & 7];
+	break;
       case 0x117:			/* StripByteCounts */
 	if (!length || is_dng) length = val;
 	if (offset > val && !strncmp(make,"KODAK",5) && !is_dng)
@@ -339,7 +295,6 @@ int parse_tiff_ifd (int base, int level)
       case 0x14a:			/* SubIFD tag */
 	save2 = ftell(ifp);
 	for (i=0; i < count; i++) {
-	  printf ("SubIFD #%d:\n", i+1);
 	  fseek (ifp, save2 + i*4, SEEK_SET);
 	  fseek (ifp, get4()+base, SEEK_SET);
 	  parse_tiff_ifd (base, level+1);
@@ -426,87 +381,140 @@ void parse_minolta()
     }
     fseek (ifp, save+len+8, SEEK_SET);
   }
-  strcpy (thumb_head, "\xff");
+  strncpy (thumb_head, "\xff", sizeof(thumb_head) );
   thumb_offset++;
   thumb_length--;
 }
 
 /*
-   Parse the CIFF structure.
+   Parse a CIFF file, better known as Canon CRW format.
  */
-void parse_ciff (int offset, int length, int level)
+void parse_ciff (int offset, int length, int level /*unused*/)
 {
-  int tboff, nrecs, i, j, type, len, dlen, roff, aoff=0, save;
-  char c, name[256];
+  int tboff, nrecs, i, c, type, len, roff, aoff, save, wbi=-1;
+  static const int remap[] = { 1,2,3,4,5,1 };
+  static const int remap_10d[] = { 0,1,3,4,5,6,0,0,2,8 };
+  static const int remap_s70[] = { 0,1,2,9,4,3,6,7,8,9,10,0,0,0,7,0,0,8 };
+  ushort key[] = { 0x410, 0x45f3 };
 
+  if (strcmp(model,"Canon PowerShot G6") &&
+      strcmp(model,"Canon PowerShot S60") &&
+      strcmp(model,"Canon PowerShot S70") &&
+      strcmp(model,"Canon PowerShot Pro1"))
+    key[0] = key[1] = 0;
   fseek (ifp, offset+length-4, SEEK_SET);
   tboff = get4() + offset;
   fseek (ifp, tboff, SEEK_SET);
   nrecs = get2();
   if (nrecs > 100) return;
-  printf ("%*s%d records:\n", level*2, "", nrecs);
   for (i = 0; i < nrecs; i++) {
-    save = ftell(ifp);
     type = get2();
-    printf ("%*stype=0x%04x", level*2, "", type);
-    if (type & 0x4000) {
-      len = 8;
-      type &= 0x3fff;
-    } else {
-      len  = get4();
-      roff = get4();
-      aoff = offset + roff;
-      printf (", length=%d, reloff=%d, absoff=%d",
-		len, roff, aoff);
+    len  = get4();
+    roff = get4();
+    aoff = offset + roff;
+    save = ftell(ifp);
+    if (type == 0x080a) {		/* Get the camera make and model */
       fseek (ifp, aoff, SEEK_SET);
+      fread (make, 64, 1, ifp);
+      fseek (ifp, aoff+strlen(make)+1, SEEK_SET);
+      fread (model, 64, 1, ifp);
     }
-    if ((type & 0xe700) == 0)
-      printf (", data=");
-    if (type == 0x0032)			/* display as words */
-	type |= 0x1000;
-    dlen = len < DLEN ? len:DLEN;
-    switch (type >> 8) {
-      case 0x28:
-      case 0x30:
-	putchar('\n');
-	parse_ciff (aoff, len, level+1);
-	fseek (ifp, save+10, SEEK_SET);
-	continue;
-      case 0x00:			/* byte values */
-	for (j = 0; j < dlen; j++)
-	  printf ("%c%02x",(j & 31) || dlen < 16 ? ' ':'\n', fgetc(ifp) & 0xff);
-	break;
-      case 0x08:			/* null-terminated ASCII strings */
-	putchar('\"');
-	for (j = 0; j < dlen; j++) {
-	  c = fgetc(ifp);
-	  putchar( isprint(c) ? c:'.');
-	}
-	putchar('\"');
-	break;
-      case 0x10:			/* word values */
-	for (j = 0; j < dlen; j+=2)
-	  printf ("%c%5u",(j & 31) || dlen < 16 ? ' ':'\n', get2());
-	break;
-      case 0x18:			/* dword values */
-	for (j = 0; j < dlen; j+=4)
-	  printf ("%c%08x",(j & 31) || dlen < 16 ? ' ':'\n', get4());
+    if (type == 0x102a) {		/* Find the White Balance index */
+      fseek (ifp, aoff+14, SEEK_SET);	/* 0=auto, 1=daylight, 2=cloudy ... */
+      wbi = get2();
+      if (((!strcmp(model,"Canon EOS DIGITAL REBEL") ||
+	    !strcmp(model,"Canon EOS 300D DIGITAL"))) && wbi == 6)
+	wbi++;
     }
-    putchar('\n');
-    fseek (ifp, save+10, SEEK_SET);
-    if (type == 0x080a) {		/* Get the camera name */
+    if (type == 0x102c) {		/* Get white balance (G2) */
+      if (!strcmp(model,"Canon PowerShot G1") ||
+	  !strcmp(model,"Canon PowerShot Pro90 IS")) {
+	fseek (ifp, aoff+120, SEEK_SET);
+	FORC4 cam_mul[c ^ 2] = get2();
+      } else {
+	fseek (ifp, aoff+100, SEEK_SET);
+	goto common;
+      }
+    }
+    if (type == 0x0032) {		/* Get white balance (D30 & G3) */
+      if (!strcmp(model,"Canon EOS D30")) {
+	fseek (ifp, aoff+72, SEEK_SET);
+common:
+	camera_red   = get2() ^ key[0];
+	camera_red   =(get2() ^ key[1]) / camera_red;
+	camera_blue  = get2() ^ key[0];
+	camera_blue /= get2() ^ key[1];
+      } else if (!strcmp(model,"Canon PowerShot G6") ||
+		 !strcmp(model,"Canon PowerShot S60") ||
+		 !strcmp(model,"Canon PowerShot S70")) {
+	fseek (ifp, aoff+96 + remap_s70[wbi]*8, SEEK_SET);
+	goto common;
+      } else if (!strcmp(model,"Canon PowerShot Pro1")) {
+	fseek (ifp, aoff+96 + wbi*8, SEEK_SET);
+	goto common;
+      } else {
+	fseek (ifp, aoff+80 + (wbi < 6 ? remap[wbi]*8 : 0), SEEK_SET);
+	if (!camera_red)
+	  goto common;
+      }
+    }
+    if (type == 0x10a9) {		/* Get white balance (D60) */
+      if (!strcmp(model,"Canon EOS 10D"))
+	wbi = remap_10d[wbi];
+      fseek (ifp, aoff+2 + wbi*8, SEEK_SET);
+      camera_red  = get2();
+      camera_red /= get2();
+      camera_blue = get2();
+      camera_blue = get2() / camera_blue;
+    }
+      /* Skip this for now /steffen */
+#if 0
+    if (type == 0x1030 && (wbi == 6 || wbi == 15)) {
+      fseek (ifp, aoff, SEEK_SET);	/* Get white sample */
+      ciff_block_1030();
+    }
+#endif
+    if (type == 0x1031) {		/* Get the raw width and height */
+      fseek (ifp, aoff+2, SEEK_SET);
+      raw_width  = get2();
+      raw_height = get2();
+    }
+    if (type == 0x180e) {		/* Get the timestamp */
       fseek (ifp, aoff, SEEK_SET);
-      fread (name, 256, 1, ifp);
-      strcpy (make, name);
-      strcpy (model, name + strlen(make)+1);
+      timestamp = get4();
     }
+    if (type == 0x580e)
+      timestamp = len;
+#if 0
+    if (type == 0x5813)
+      flash_used = *((float *) &len);
+    if (type == 0x5814)
+      canon_5814 = *((float *) &len);
+#endif
+    if (type == 0x1810) {		/* Get the rotation */
+      fseek (ifp, aoff+12, SEEK_SET);
+      flip = get4();
+    }
+      /* Skip this for now /steffen */
+#if 0
+    if (type == 0x1835) {		/* Get the decoder table */
+      fseek (ifp, aoff, SEEK_SET);
+      crw_init_tables (get4());
+    }
+#endif
     if (type == 0x2007) {		/* Found the JPEG thumbnail */
       thumb_offset = aoff;
       thumb_length = len;
     }
+    if (type >> 8 == 0x28 || type >> 8 == 0x30)	/* Get sub-tables */
+      parse_ciff(aoff, len, level+1);
+    fseek (ifp, save, SEEK_SET);
   }
+  if (wbi == 0 && !strcmp(model,"Canon EOS D30"))
+    camera_red = -1;			/* Use my auto WB for this photo */
 }
 
+
 void parse_mos(int level)
 {
   uchar data[256];
@@ -518,16 +526,12 @@ void parse_mos(int level)
     fread (data, 1, 8, ifp);
     if (strcmp(data,"PKTS")) break;
     strcpy (model, "Valeo");
-    printf ("%*s%s ", level, "", data);
     fread (data, 1, 40, ifp);
     skip = get4();
-    printf ("%s %d bytes: ", data, skip);
     if (!strcmp(data,"icc_camera_to_tone_matrix")) {
       for (i=0; i < skip/4; i++) {
 	j = get4();
-	printf ("%f ", *((float *) &j));
       }
-      putchar('\n');
       continue;
     }
     if (!strcmp(data,"JPEG_preview_data")) {
@@ -540,7 +544,6 @@ void parse_mos(int level)
     data[sizeof data - 1] = 0;
     while ((cp=index(data,'\n')))
       *cp = ' ';
-    printf ("%s\n",data);
     parse_mos(level+2);
     fseek (ifp, skip, SEEK_CUR);
   }
@@ -640,14 +643,11 @@ void parse_foveon()
     tag = get4();
     save = ftell(ifp);
     fseek (ifp, off, SEEK_SET);
-    printf ("%c%c%c%c at offset %06x, length %06x, ",
-	tag, tag >> 8, tag >> 16, tag >> 24, off, len);
     if (get4() != (0x20434553 | (tag << 24))) {
       printf ("Bad Section identifier at %6x\n", off);
       goto next;
     }
     val = get4();
-    printf ("version %d.%d, ",val >> 16, val & 0xffff);
     switch (tag) {
       case 0x32414d49:			/* IMA2 */
       case 0x47414d49:			/* IMAG */
@@ -756,9 +756,9 @@ void parse_foveon()
 	  get_utf8 (poff[i][1], value, 128);
 	  printf ("  %s = %s\n", name, value);
 	  if (!strcmp (name,"CAMMANUF"))
-	    strcpy (make, value);
+	    strncpy (make, value, sizeof(make));
 	  if (!strcmp (name,"CAMMODEL"))
-	    strcpy (model, value);
+	    strncpy (model, value, sizeof(value));
 	}
     }
 next:
@@ -903,24 +903,6 @@ void kodak_yuv_decode (FILE *tfp)
   free(out);
 }
 
-void parse_fuji (int offset)
-{
-  int entries, tag, len;
-
-  fseek (ifp, offset, SEEK_SET);
-  fseek (ifp, get4(), SEEK_SET);
-  entries = get4();
-  if (entries > 60) return;
-  while (entries--) {
-    tag = get2();
-    len = get2();
-    printf ("Fuji tag=0x%x, len=%d, data =",tag,len);
-    while (len--)
-      printf (" %02x",fgetc(ifp));
-    putchar ('\n');
-  }
-}
-
 void parse_phase_one (int base)
 {
   unsigned entries, tag, type, len, data, save;
@@ -973,7 +955,7 @@ void parse_jpeg (int offset)
   }
 }
 
-char *memmem (char *haystack, size_t haystacklen,
+char *raw_memmem (char *haystack, size_t haystacklen,
               char *needle, size_t needlelen)
 {
   char *c;
@@ -985,13 +967,13 @@ char *memmem (char *haystack, size_t hay
 
 /*
    Identify which camera created this file, and set global variables
-   accordingly.	 Return nonzero if the file cannot be decoded.
+   accordingly.	 
+   Return nonzero if the file cannot be decoded or no thumbnail is found
  */
-int identify()
+int identify(FILE* tfp)
 {
-  char head[32], thumb_name[256], *thumb, *rgb, *cp;
+  char head[32], *thumb, *rgb, *cp;
   unsigned hlen, fsize, toff, tlen, lsize, i;
-  FILE *tfp;
 
   make[0] = model[0] = model2[0] = is_dng = 0;
   thumb_head[0] = thumb_offset = thumb_length = thumb_layers = 0;
@@ -1001,8 +983,8 @@ int identify()
   fread (head, 1, 32, ifp);
   fseek (ifp, 0, SEEK_END);
   fsize = ftell(ifp);
-  if ((cp = memmem (head, 32, "MMMMRawT", 8)) ||
-      (cp = memmem (head, 32, "IIIITwaR", 8)))
+  if ((cp = raw_memmem (head, 32, "MMMMRawT", 8)) ||
+      (cp = raw_memmem (head, 32, "IIIITwaR", 8)))
     parse_phase_one (cp - head);
   else if (order == 0x4949 || order == 0x4d4d) {
     if (!memcmp(head+6,"HEAPCCDR",8)) {
@@ -1020,9 +1002,6 @@ int identify()
     fseek (ifp, 84, SEEK_SET);
     toff = get4();
     tlen = get4();
-    parse_fuji (92);
-    if (toff > 120) parse_fuji (120);
-    parse_tiff (toff+12);
     thumb_offset = toff;
     thumb_length = tlen;
   } else if (!memcmp (head, "DSC-Image", 9))
@@ -1034,27 +1013,12 @@ int identify()
   fseek (ifp, 3472, SEEK_SET);
   parse_mos(0);
   parse_jpeg(0);
-  if (model[0] == 0) {
-    fprintf (stderr, "%s: unsupported file format.\n", fname);
-    return 1;
-  }
-  fprintf (stderr, "Findings for %s:\n", fname);
-  fprintf (stderr, "Make   is \"%s\"\n", make);
-  fprintf (stderr, "Model  is \"%s\"\n", model);
-  if (model2[0])
-    fprintf (stderr, "Model2 is \"%s\"\n", model2);
 
   if (!thumb_length) {
     fprintf (stderr, "Thumbnail image not found\n");
-    return 0;
+    return -1;
   }
-  strcpy (thumb_name, fname);
-  strcat (thumb_name, ".thumb");
-  tfp = fopen (thumb_name, "wb");
-  if (!tfp) {
-    perror(thumb_name);
-    return 0;
-  }
+
   if (is_dng) goto dng_skip;
   if (!strncmp(model,"DCS Pro",7)) {
     kodak_yuv_decode (tfp);
@@ -1080,7 +1044,7 @@ dng_skip:
     rgb = (char *) malloc(thumb_length);
     if (!rgb) {
       fprintf (stderr, "Cannot allocate %d bytes!!\n", thumb_length);
-      exit(1);
+      return -1;
     }
     lsize = thumb_length/3;
     for (i=0; i < thumb_length; i++)
@@ -1092,35 +1056,23 @@ dng_skip:
   fwrite(thumb, 1, thumb_length, tfp);
   free (thumb);
 done:
-  fclose (tfp);
-  fprintf (stderr, "Thumbnail image written to %s.\n", thumb_name);
+  fprintf (stderr, "Thumbnail image written, make=%s, model=%s\n",&(make[0]),&(model[0]));
   return 0;
 }
 
-int main(int argc, char **argv)
+int extract_thumbnail( FILE* input, FILE* output, int* orientation )
 {
-  int arg;
-
-  if (argc == 1)
-  {
-    fprintf (stderr,
-    "\nRaw Photo Parser and Thumbnail Extracter"
-    "\nby Dave Coffin, dcoffin a cybercom o net"
-    "\n\nUsage:  %s [options] file1.crw file2.crw ...\n", argv[0]);
-    return 1;
+  /* Coffin's code has different meaning for orientation
+	 values than TIFF, so we map them to TIFF values */
+  static const int flip_map[] = { 0,1,3,2,4,7,5,6 };
+  int rc;
+  ifp = input;
+  rc = identify(output);
+  switch ((flip+3600) % 360) {
+  case 270:  flip = 5;  break;
+  case 180:  flip = 3;  break;
+  case  90:  flip = 6;
   }
-
-  for (arg=1; arg < argc; arg++)
-  {
-    fname = argv[arg];
-    ifp = fopen (fname,"rb");
-    if (!ifp) {
-      perror (fname);
-      continue;
-    }
-    printf ("\nParsing %s:\n", fname);
-    identify();
-    fclose (ifp);
-  }
-  return 0;
+  if( orientation ) *orientation = flip_map[flip%7];
+  return rc;
 }
