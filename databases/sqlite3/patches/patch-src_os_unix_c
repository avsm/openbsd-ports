$OpenBSD: patch-src_os_unix_c,v 1.5 2009/01/31 15:49:34 simon Exp $
--- src/os_unix.c.orig	Thu Jan 15 15:01:46 2009
+++ src/os_unix.c	Tue Jan 27 10:18:24 2009
@@ -141,6 +141,9 @@
 #if SQLITE_THREADSAFE
 # include <pthread.h>
 # define SQLITE_UNIX_THREADS 1
+# if SQLITE_THREAD_OVERRIDE_LOCK != 1 || defined(SQLITE_TEST)
+#  define SQLITE_NEED_TID_CHECKS 1
+# endif
 #endif
 
 /*
@@ -184,7 +187,7 @@ struct unixFile {
   int lastErrno;                   /* The unix errno from the last I/O error */
   void *lockingContext;            /* Locking style specific state */
   int openFlags;                   /* The flags specified at open */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;                   /* The thread that "owns" this unixFile */
 #endif
 #if OS_VXWORKS
@@ -247,7 +250,7 @@ struct unixFile {
 ** The threadid macro resolves to the thread-id or to 0.  Used for
 ** testing and debugging only.
 */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 #define threadid pthread_self()
 #else
 #define threadid 0
@@ -657,7 +660,7 @@ static void vxworksReleaseFileId(struct vxworksFileId 
 ** recomputed because its key includes the thread-id.  See the 
 ** transferOwnership() function below for additional information
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 # define SET_THREADID(X)   (X)->tid = pthread_self()
 # define CHECK_THREADID(X) (threadsOverrideEachOthersLocks==0 && \
                             !pthread_equal((X)->tid, pthread_self()))
@@ -692,7 +695,7 @@ struct unixFileId {
 */
 struct unixLockKey {
   struct unixFileId fid;  /* Unique identifier for the file */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;  /* Thread ID of lock owner. Zero if not using LinuxThreads */
 #endif
 };
@@ -767,7 +770,7 @@ static struct unixOpenCnt *openList = 0;
 ** it a global so that the test code can change its value in order to verify
 ** that the right stuff happens in either case.
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 #  ifndef SQLITE_THREAD_OVERRIDE_LOCK
 #    define SQLITE_THREAD_OVERRIDE_LOCK -1
 #  endif
@@ -788,7 +791,7 @@ struct threadTestData {
   int result;            /* Result of the locking operation */
 };
 
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This function is used as the main routine for a thread launched by
 ** testThreadLockingBehavior(). It tests whether the shared-lock obtained
@@ -806,7 +809,7 @@ static void *threadLockingTest(void *pArg){
 #endif /* SQLITE_THREADSAFE && defined(__linux__) */
 
 
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This procedure attempts to determine whether or not threads
 ** can override each others locks then sets the 
@@ -946,7 +949,7 @@ static int findLockInfo(
 #else
   lockKey.fid.ino = statbuf.st_ino;
 #endif
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   if( threadsOverrideEachOthersLocks<0 ){
     testThreadLockingBehavior(fd);
   }
@@ -1023,7 +1026,7 @@ exit_findlockinfo:
 ** If the unixFile is locked and an ownership is wrong, then return
 ** SQLITE_MISUSE.  SQLITE_OK is returned if everything works.
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 static int transferOwnership(unixFile *pFile){
   int rc;
   pthread_t hSelf;
