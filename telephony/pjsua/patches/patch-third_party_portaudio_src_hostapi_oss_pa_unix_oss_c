$OpenBSD: patch-third_party_portaudio_src_hostapi_oss_pa_unix_oss_c,v 1.3 2008/06/18 21:16:39 todd Exp $
--- third_party/portaudio/src/hostapi/oss/pa_unix_oss.c.orig	Sun Mar 25 15:20:31 2007
+++ third_party/portaudio/src/hostapi/oss/pa_unix_oss.c	Wed Jun 18 14:37:03 2008
@@ -8,6 +8,8 @@
  *   Dominic Mazzoni
  *   Arve Knudsen
  *
+ * Updated to Id: pa_unix_oss.c 1278 2007-09-12 17:39:48Z aknudsen $
+ *
  * Based on the Open Source API proposed by Ross Bencina
  * Copyright (c) 1999-2002 Ross Bencina, Phil Burk
  *
@@ -32,19 +34,19 @@
  */
 
 /*
- * The text above constitutes the entire PortAudio license; however, 
+ * The text above constitutes the entire PortAudio license; however,
  * the PortAudio community also makes the following non-binding requests:
  *
  * Any person wishing to distribute modifications to the Software is
  * requested to send the modifications to the original developer so that
- * they can be incorporated into the canonical version. It is also 
- * requested that these non-binding requests be included along with the 
+ * they can be incorporated into the canonical version. It is also
+ * requested that these non-binding requests be included along with the
  * license above.
  */
 
 /**
  @file
- @ingroup hostaip_src
+ @ingroup hostapi_src
 */
 
 #include <stdio.h>
@@ -63,18 +65,8 @@
 #include <limits.h>
 #include <semaphore.h>
 
-#ifdef HAVE_SYS_SOUNDCARD_H
-# include <sys/soundcard.h>
-# define DEVICE_NAME_BASE            "/dev/dsp"
-#elif defined(HAVE_LINUX_SOUNDCARD_H)
-# include <linux/soundcard.h>
-# define DEVICE_NAME_BASE            "/dev/dsp"
-#elif defined(HAVE_MACHINE_SOUNDCARD_H)
-# include <machine/soundcard.h> /* JH20010905 */
+# include <soundcard.h>
 # define DEVICE_NAME_BASE            "/dev/audio"
-#else
-# error No sound card header file
-#endif
 
 #include "portaudio.h"
 #include "pa_util.h"
@@ -84,6 +76,7 @@
 #include "pa_cpuload.h"
 #include "pa_process.h"
 #include "pa_unix_util.h"
+#include "pa_debugprint.h"
 
 static int sysErr_;
 static pthread_t mainThread_;
@@ -113,7 +106,7 @@ static pthread_t mainThread_;
  */
 static int Get_AFMT_S16_NE( void )
 {
-    long testData = 1; 
+    long testData = 1;
     char *ptr = (char *) &testData;
     int isLittle = ( *ptr == 1 ); /* Does address point to least significant byte? */
     return isLittle ? AFMT_S16_LE : AFMT_S16_BE;
@@ -384,7 +377,7 @@ static PaError QueryDirection( const char *deviceName,
         {
             maxNumChannels = (stereo) ? 2 : 1;
         }
-        PA_DEBUG(( "%s: use SNDCTL_DSP_STEREO, maxNumChannels = %d\n", __FUNCTION__, maxNumChannels ))
+        PA_DEBUG(( "%s: use SNDCTL_DSP_STEREO, maxNumChannels = %d\n", __FUNCTION__, maxNumChannels ));
     }
 
     /* During channel negotiation, the last ioctl() may have failed. This can
@@ -402,8 +395,12 @@ static PaError QueryDirection( const char *deviceName,
         sr = 44100;
         if( ioctl( devHandle, SNDCTL_DSP_SPEED, &sr ) < 0 )
         {
-            result = paUnanticipatedHostError;
-            goto error;
+            sr = 48000;
+            if( ioctl( devHandle, SNDCTL_DSP_SPEED, &sr ) < 0 )
+            {
+                result = paUnanticipatedHostError;
+                goto error;
+	    }
         }
 
         *defaultSampleRate = sr;
@@ -507,9 +504,9 @@ static PaError BuildDeviceList( PaOSSHostApiRepresenta
     /* Find devices by calling QueryDevice on each
      * potential device names.  When we find a valid one,
      * add it to a linked list.
-     * A: Can there only be 10 devices? */
+     * A: Set an arbitrary of 100 devices, should probably be a smarter way. */
 
-    for( i = 0; i < 10; i++ )
+    for( i = 0; i < 100; i++ )
     {
        char deviceName[32];
        PaDeviceInfo *deviceInfo;
@@ -809,9 +806,11 @@ static PaError OpenDevices( const char *idevName, cons
         ENSURE_( *idev = open( idevName, flags ), paDeviceUnavailable );
         PA_ENSURE( ModifyBlocking( *idev, 1 ) ); /* Blocking */
 
+#ifndef __OpenBSD__
         /* Initially disable */
         enableBits = ~PCM_ENABLE_INPUT;
         ENSURE_( ioctl( *idev, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );
+#endif
     }
     if( odevName )
     {
@@ -820,9 +819,11 @@ static PaError OpenDevices( const char *idevName, cons
             ENSURE_( *odev = open( odevName, flags ), paDeviceUnavailable );
             PA_ENSURE( ModifyBlocking( *odev, 1 ) ); /* Blocking */
 
+#ifndef __OpenBSD__
             /* Initially disable */
             enableBits = ~PCM_ENABLE_OUTPUT;
             ENSURE_( ioctl( *odev, SNDCTL_DSP_SETTRIGGER, &enableBits ), paUnanticipatedHostError );
+#endif
         }
         else
         {
@@ -848,6 +849,7 @@ static PaError PaOssStream_Initialize( PaOssStream *st
     memset( stream, 0, sizeof (PaOssStream) );
     stream->isStopped = 1;
 
+    ENSURE_( sem_init( &stream->semaphore, 0, 0 ), paInternalError );
     PA_ENSURE( PaUtil_InitializeThreading( &stream->threading ) );
 
     if( inputParameters && outputParameters )
@@ -884,7 +886,6 @@ static PaError PaOssStream_Initialize( PaOssStream *st
                                                &ossApi->blockingStreamInterface, callback, userData );
     }    
 
-    ENSURE_( sem_init( &stream->semaphore, 0, 0 ), paInternalError );
 
 error:
     return result;
@@ -975,8 +976,8 @@ static int CalcHigherLogTwo( int n )
     return log2;
 }
 
-static PaError PaOssStreamComponent_Configure( PaOssStreamComponent *component, double sampleRate, unsigned long framesPerBuffer,
-        StreamMode streamMode, PaOssStreamComponent *master )
+static PaError PaOssStreamComponent_Configure( PaOssStreamComponent *component, double sampleRate, unsigned long
+        framesPerBuffer, StreamMode streamMode, PaOssStreamComponent *master )
 {
     PaError result = paNoError;
     int temp, nativeFormat;
@@ -986,7 +987,7 @@ static PaError PaOssStreamComponent_Configure( PaOssSt
     int frgmt;
     int numBufs;
     int bytesPerBuf;
-    double bufSz;
+    unsigned long bufSz;
     unsigned long fragSz;
     audio_buf_info bufInfo;
 
@@ -998,21 +999,21 @@ static PaError PaOssStreamComponent_Configure( PaOssSt
          * The hardware need not respect the requested fragment size, so we may have to adapt.
          */
         if( framesPerBuffer == paFramesPerBufferUnspecified )
-        { 
-            bufSz = component->latency * sampleRate;
+        {
+            bufSz = (unsigned long)(component->latency * sampleRate);
             fragSz = bufSz / 4;
         }
         else
         {
             fragSz = framesPerBuffer;
-            bufSz = component->latency * sampleRate + fragSz; /* Latency + 1 buffer */
+            bufSz = (unsigned long)(component->latency * sampleRate) + fragSz; /* Latency + 1 buffer */
         }
 
         PA_ENSURE( GetAvailableFormats( component, &availableFormats ) );
         hostFormat = PaUtil_SelectClosestAvailableFormat( availableFormats, component->userFormat );
 
         /* OSS demands at least 2 buffers, and 16 bytes per buffer */
-        numBufs = PA_MAX( bufSz / fragSz, 2 );
+        numBufs = (int)PA_MAX( bufSz / fragSz, 2 );
         bytesPerBuf = PA_MAX( fragSz * Pa_GetSampleSize( hostFormat ) * chans, 16 );
 
         /* The fragment parameters are encoded like this:
@@ -1119,7 +1120,8 @@ static PaError PaOssStream_Configure( PaOssStream *str
     if( stream->capture )
     {
         PaOssStreamComponent *component = stream->capture;
-        PaOssStreamComponent_Configure( component, sampleRate, framesPerBuffer, StreamMode_In, NULL );
+        PA_ENSURE( PaOssStreamComponent_Configure( component, sampleRate, framesPerBuffer, StreamMode_In,
+                    NULL ) );
 
         assert( component->hostChannelCount > 0 );
         assert( component->hostFrames > 0 );
@@ -1187,6 +1189,7 @@ static PaError OpenStream( struct PaUtilHostApiReprese
     const PaDeviceInfo *inputDeviceInfo = 0, *outputDeviceInfo = 0;
     int bpInitialized = 0;
     double inLatency = 0., outLatency = 0.;
+    int i = 0;
 
     /* validate platform specific flags */
     if( (streamFlags & paPlatformSpecificFlags) != 0 )
@@ -1222,7 +1225,14 @@ static PaError OpenStream( struct PaUtilHostApiReprese
                 return paInvalidChannelCount;
         }
     }
-    
+
+#if 0
+    /* Round framesPerBuffer to the next power-of-two to make OSS happy. */
+    framesPerBuffer &= INT_MAX;
+    for (i = 1; framesPerBuffer > i; i <<= 1) ;
+    framesPerBuffer = i;
+#endif
+
     /* allocate and do basic initialization of the stream structure */
     PA_UNLESS( stream = (PaOssStream*)PaUtil_AllocateMemory( sizeof(PaOssStream) ), paInsufficientMemory );
     PA_ENSURE( PaOssStream_Initialize( stream, inputParameters, outputParameters, streamCallback, userData, streamFlags, ossHostApi ) );
@@ -1594,7 +1604,8 @@ static void *PaOSS_AudioThreadProc( void *userData )
          */
         if( !initiateProcessing )
         {
-            PA_ENSURE( PaOssStream_WaitForFrames( stream, &framesAvail ) );  /* Wait on available frames */
+            /* Wait on available frames */
+            PA_ENSURE( PaOssStream_WaitForFrames( stream, &framesAvail ) );
             assert( framesAvail % stream->framesPerHostBuffer == 0 );
         }
         else
@@ -1933,11 +1944,11 @@ static signed long GetStreamReadAvailable( PaStream* s
 static signed long GetStreamWriteAvailable( PaStream* s )
 {
     PaOssStream *stream = (PaOssStream*)s;
-    int delay = 0;
+    struct count_info delay;
 
-    if( ioctl( stream->playback->fd, SNDCTL_DSP_GETODELAY, &delay ) < 0 )
+    if( ioctl( stream->playback->fd, SNDCTL_DSP_GETOPTR, &delay ) < 0 )
         return paUnanticipatedHostError;
-    
-    return (PaOssStreamComponent_BufferSize( stream->playback ) - delay) / PaOssStreamComponent_FrameSize( stream->playback );
+
+    return (PaOssStreamComponent_BufferSize( stream->playback ) - delay.ptr) / PaOssStreamComponent_FrameSize( stream->playback );
 }
 
