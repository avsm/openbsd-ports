$OpenBSD: patch-src_os_unix_c,v 1.12 2010/04/02 20:07:11 sthen Exp $
--- src/os_unix.c.orig	Mon Mar  8 15:08:54 2010
+++ src/os_unix.c	Fri Mar 26 19:44:15 2010
@@ -109,6 +109,14 @@
 # define _LARGEFILE_SOURCE 1
 #endif
 
+/* PRNG device to use */
+#ifdef __OpenBSD__
+#define RAND_DEV "/dev/arandom"
+#else
+#define RAND_DEV "/dev/urandom"
+#endif
+
+
 /*
 ** standard include files.
 */
@@ -147,6 +155,9 @@
 #if SQLITE_THREADSAFE
 # include <pthread.h>
 # define SQLITE_UNIX_THREADS 1
+# if SQLITE_THREAD_OVERRIDE_LOCK != 1 || defined(SQLITE_TEST)
+#  define SQLITE_NEED_TID_CHECKS 1
+# endif
 #endif
 
 /*
@@ -210,7 +221,7 @@ struct unixFile {
 #if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
   unsigned fsFlags;                 /* cached details from statfs() */
 #endif
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;                   /* The thread that "owns" this unixFile */
 #endif
 #if OS_VXWORKS
@@ -278,7 +289,7 @@ struct unixFile {
 ** The threadid macro resolves to the thread-id or to 0.  Used for
 ** testing and debugging only.
 */
-#if SQLITE_THREADSAFE
+#if SQLITE_NEED_TID_CHECKS
 #define threadid pthread_self()
 #else
 #define threadid 0
@@ -704,7 +715,7 @@ static void vxworksReleaseFileId(struct vxworksFileId 
 ** recomputed because its key includes the thread-id.  See the 
 ** transferOwnership() function below for additional information
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 # define SET_THREADID(X)   (X)->tid = pthread_self()
 # define CHECK_THREADID(X) (threadsOverrideEachOthersLocks==0 && \
                             !pthread_equal((X)->tid, pthread_self()))
@@ -739,7 +750,7 @@ struct unixFileId {
 */
 struct unixLockKey {
   struct unixFileId fid;  /* Unique identifier for the file */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   pthread_t tid;  /* Thread ID of lock owner. Zero if not using LinuxThreads */
 #endif
 };
@@ -816,7 +827,7 @@ static struct unixOpenCnt *openList = 0;
 ** it a global so that the test code can change its value in order to verify
 ** that the right stuff happens in either case.
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 #  ifndef SQLITE_THREAD_OVERRIDE_LOCK
 #    define SQLITE_THREAD_OVERRIDE_LOCK -1
 #  endif
@@ -837,7 +848,7 @@ struct threadTestData {
   int result;            /* Result of the locking operation */
 };
 
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This function is used as the main routine for a thread launched by
 ** testThreadLockingBehavior(). It tests whether the shared-lock obtained
@@ -855,7 +866,7 @@ static void *threadLockingTest(void *pArg){
 #endif /* SQLITE_THREADSAFE && defined(__linux__) */
 
 
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 /*
 ** This procedure attempts to determine whether or not threads
 ** can override each others locks then sets the 
@@ -1025,7 +1036,7 @@ static int findLockInfo(
 #else
   lockKey.fid.ino = statbuf.st_ino;
 #endif
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
   if( threadsOverrideEachOthersLocks<0 ){
     testThreadLockingBehavior(fd);
   }
@@ -1098,7 +1109,7 @@ exit_findlockinfo:
 ** If the unixFile is locked and an ownership is wrong, then return
 ** SQLITE_MISUSE.  SQLITE_OK is returned if everything works.
 */
-#if SQLITE_THREADSAFE && defined(__linux__)
+#if SQLITE_NEED_TID_CHECKS
 static int transferOwnership(unixFile *pFile){
   int rc;
   pthread_t hSelf;
@@ -4385,7 +4396,7 @@ static void *unixDlOpen(sqlite3_vfs *NotUsed, const ch
 ** error message.
 */
 static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){
-  char *zErr;
+  const char *zErr;
   UNUSED_PARAMETER(NotUsed);
   unixEnterMutex();
   zErr = dlerror();
@@ -4451,7 +4462,7 @@ static int unixRandomness(sqlite3_vfs *NotUsed, int nB
 #if !defined(SQLITE_TEST)
   {
     int pid, fd;
-    fd = open("/dev/urandom", O_RDONLY);
+    fd = open(RAND_DEV, O_RDONLY);
     if( fd<0 ){
       time_t t;
       time(&t);
