$OpenBSD: patch-etc_afpd_unix_c,v 1.2 2003/08/22 11:18:19 naddy Exp $
--- etc/afpd/unix.c.orig	Mon Aug 18 14:38:03 2003
+++ etc/afpd/unix.c	Mon Aug 18 14:47:24 2003
@@ -289,7 +289,7 @@ const int dropbox;
 int setdeskmode( mode )
 const mode_t	mode;
 {
-    char		wd[ MAXPATHLEN + 1];
+    char		wd[MAXPATHLEN];
     struct stat         st;
     char		modbuf[ 12 + 1], *m;
     struct dirent	*deskp, *subp;
@@ -312,8 +312,8 @@ const mode_t	mode;
                 strcmp( deskp->d_name, ".." ) == 0 || strlen( deskp->d_name ) > 2 ) {
             continue;
         }
-        strcpy( modbuf, deskp->d_name );
-        strcat( modbuf, "/" );
+        (void)strlcpy(modbuf, deskp->d_name, sizeof(modbuf));
+        (void)strlcat(modbuf, "/", sizeof(modbuf));
         m = strchr( modbuf, '\0' );
         if (( sub = opendir( deskp->d_name )) == NULL ) {
             continue;
@@ -324,7 +324,7 @@ const mode_t	mode;
                 continue;
             }
             *m = '\0';
-            strcat( modbuf, subp->d_name );
+            (void)strlcat( modbuf, subp->d_name, sizeof(modbuf));
             /* XXX: need to preserve special modes */
             if (stat(modbuf, &st) < 0) {
                 LOG(log_error, logtype_afpd, "setdeskmode: stat %s: %s",
@@ -388,7 +388,7 @@ const mode_t mode;
 const int noadouble;
 const int dropbox;
 {
-    char		buf[ MAXPATHLEN + 1];
+    char		buf[MAXPATHLEN];
     struct stat		st;
     char		*m;
     struct dirent	*dirp;
@@ -436,8 +436,8 @@ const int dropbox;
         LOG(log_error, logtype_afpd, "setdirmode: opendir .AppleDouble: %s", strerror(errno) );
         return( -1 );
     }
-    strcpy( buf, ".AppleDouble" );
-    strcat( buf, "/" );
+    (void)strlcpy(buf, ".AppleDouble", sizeof(buf));
+    (void)strlcat(buf, "/" ,sizeof(buf));
     m = strchr( buf, '\0' );
     for ( dirp = readdir( dir ); dirp != NULL; dirp = readdir( dir )) {
         if ( strcmp( dirp->d_name, "." ) == 0 ||
@@ -445,7 +445,7 @@ const int dropbox;
             continue;
         }
         *m = '\0';
-        strcat( buf, dirp->d_name );
+        (void)strlcat(buf, dirp->d_name, sizeof(buf));
 
         if ( stat( buf, &st ) < 0 ) {
             LOG(log_error, logtype_afpd, "setdirmode: stat %s: %s", buf, strerror(errno) );
@@ -476,7 +476,7 @@ int setdeskowner( uid, gid )
 const uid_t	uid;
 const gid_t	gid;
 {
-    char		wd[ MAXPATHLEN + 1];
+    char		wd[MAXPATHLEN];
     char		modbuf[12 + 1], *m;
     struct dirent	*deskp, *subp;
     DIR			*desk, *sub;
@@ -499,8 +499,8 @@ const gid_t	gid;
                 strlen( deskp->d_name ) > 2 ) {
             continue;
         }
-        strcpy( modbuf, deskp->d_name );
-        strcat( modbuf, "/" );
+        (void)strlcpy(modbuf, deskp->d_name, sizeof(modbuf));
+        (void)strlcat(modbuf, "/", sizeof(modbuf));
         m = strchr( modbuf, '\0' );
         if (( sub = opendir( deskp->d_name )) == NULL ) {
             continue;
@@ -511,7 +511,7 @@ const gid_t	gid;
                 continue;
             }
             *m = '\0';
-            strcat( modbuf, subp->d_name );
+            (void)strlcat(modbuf, subp->d_name, sizeof(modbuf));
             /* XXX: add special any uid, ignore group bits */
             if ( chown( modbuf, uid, gid ) < 0 && errno != EPERM ) {
                 LOG(log_error, logtype_afpd, "setdeskown: chown %s: %s",
@@ -547,7 +547,7 @@ const uid_t	uid;
 const gid_t	gid;
 const int   noadouble;
 {
-    char		buf[ MAXPATHLEN + 1];
+    char		buf[MAXPATHLEN];
     struct stat		st;
     char		*m;
     struct dirent	*dirp;
@@ -579,8 +579,8 @@ const int   noadouble;
             goto setdirowner_noadouble;
         return( -1 );
     }
-    strcpy( buf, ".AppleDouble" );
-    strcat( buf, "/" );
+    (void)strlcpy(buf, ".AppleDouble", sizeof(buf));
+    (void)strlcat(buf, "/", sizeof(buf));
     m = strchr( buf, '\0' );
     for ( dirp = readdir( dir ); dirp != NULL; dirp = readdir( dir )) {
         if ( strcmp( dirp->d_name, "." ) == 0 ||
@@ -588,7 +588,7 @@ const int   noadouble;
             continue;
         }
         *m = '\0';
-        strcat( buf, dirp->d_name );
+        (void)strlcat(buf, dirp->d_name, sizeof(buf));
         if ( chown( buf, uid, gid ) < 0 && errno != EPERM ) {
             LOG(log_debug, logtype_afpd, "setdirowner: chown %d/%d %s: %s",
                 uid, gid, buf, strerror(errno) );
