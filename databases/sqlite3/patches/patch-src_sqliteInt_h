$OpenBSD: patch-src_sqliteInt_h,v 1.6 2009/12/19 23:08:48 sthen Exp $
--- src/sqliteInt.h.orig	Fri Jun 26 16:14:55 2009
+++ src/sqliteInt.h	Fri Dec 18 22:05:53 2009
@@ -35,11 +35,6 @@
 #pragma warn -spa /* Suspicious pointer arithmetic */
 #endif
 
-/* Needed for various definitions... */
-#ifndef _GNU_SOURCE
-# define _GNU_SOURCE
-#endif
-
 /*
 ** Include standard header files as necessary
 */
@@ -439,33 +434,26 @@ typedef INT8_TYPE i8;              /* 1-byte signed in
 */
 #define SQLITE_MAX_U32  ((((u64)1)<<32)-1)
 
-/*
-** Macros to determine whether the machine is big or little endian,
-** evaluated at runtime.
-*/
-#ifdef SQLITE_AMALGAMATION
-const int sqlite3one = 1;
+#include <sys/endian.h>
+#if _BYTE_ORDER == _BIG_ENDIAN
+#define SQLITE_BIGENDIAN	1
+#define SQLITE_LITTLEENDIAN	0
+#define SQLITE_UTF16NATIVE	SQLITE_UTF16BE
+#elif _BYTE_ORDER == _LITTLE_ENDIAN
+#define SQLITE_BIGENDIAN	0
+#define SQLITE_LITTLEENDIAN	1
+#define SQLITE_UTF16NATIVE	SQLITE_UTF16LE
 #else
-extern const int sqlite3one;
+#error "Help, I'm trapped in a PDP11"
 #endif
-#if defined(i386) || defined(__i386__) || defined(_M_IX86)\
-                             || defined(__x86_64) || defined(__x86_64__)
-# define SQLITE_BIGENDIAN    0
-# define SQLITE_LITTLEENDIAN 1
-# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE
-#else
-# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)
-# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)
-# define SQLITE_UTF16NATIVE (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)
-#endif
 
 /*
 ** Constants for the largest and smallest possible 64-bit signed integers.
 ** These macros are designed to work correctly on both 32-bit and 64-bit
 ** compilers.
 */
-#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))
-#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)
+#define LARGEST_INT64	INT64_MAX
+#define SMALLEST_INT64	INT64_MIN
 
 /* 
 ** Round up a number to the next larger multiple of 8.  This is used
@@ -1511,7 +1499,7 @@ struct Expr {
 
   int iTable;            /* TK_COLUMN: cursor number of table holding column
                          ** TK_REGISTER: register number */
-  i16 iColumn;           /* TK_COLUMN: column index.  -1 for rowid */
+  int iColumn;           /* TK_COLUMN: column index.  -1 for rowid */
   i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */
   i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */
   u16 flags2;            /* Second set of flags.  EP2_... */
