$OpenBSD: patch-base_src_common_SDR_c,v 1.2 2002/08/28 22:23:29 todd Exp $
--- base/src/common/SDR.c.orig	Mon Jul 29 22:48:31 2002
+++ base/src/common/SDR.c	Wed Aug 28 14:26:40 2002
@@ -116,13 +116,15 @@ file_stream_putc(SDR_stream *s, int c)
   s->pos++;
   s->len++;
   s->bound++;
-  return fputc(c, s->state);
+  return fputc(c, (FILE*)s->state);
 }
 
 static ocmoff_t
 file_stream_puts(SDR_stream *s, const void *vp, ocmoff_t len)
 {
-  size_t wlen = fwrite(vp, 1, len, s->state);
+  size_t wlen = fwrite(vp, 1, len, (FILE*)s->state);
+  if(len != wlen || ferror((FILE*)s->state))
+    THROW(ExTruncated, format("Writing to %s was truncated\n", s->name));
   s->pos += wlen;
   s->len += wlen;
   s->bound += wlen;
@@ -142,7 +144,7 @@ file_stream_getc(SDR_stream *s)
 {
   int c;
 
-  c = fgetc(s->state);
+  c = fgetc((FILE*)s->state);
   s->pos++;
   return c;
 }
@@ -150,7 +152,7 @@ file_stream_getc(SDR_stream *s)
 static ocmoff_t
 file_stream_gets(SDR_stream *s, void *vp, ocmoff_t len)
 {
-  size_t rlen = fread(vp, 1, len, s->state);
+  size_t rlen = fread(vp, 1, len, (FILE*)s->state);
   s->pos += rlen;
   
   return rlen;
@@ -161,8 +163,8 @@ file_stream_reread(SDR_stream *s)
 {
   assert(s->state);
 
-  fflush(s->state);
-  rewind(s->state);
+  fflush((FILE*)s->state);
+  rewind((FILE*)s->state);
   s->pos = 0;
 
   s->mode = MODE_RSTREAM;
@@ -175,7 +177,7 @@ static void
 file_stream_close(SDR_stream *s)
 {
   if (s->state) {
-    fflush(s->state);
+    fflush((FILE*)s->state);
     xfclose((FILE *) s->state);
   }
   s->state = 0;
@@ -1028,7 +1030,7 @@ stream_autodetect_format(SDR_stream *str
       /* Texty format starts with TEXTY\n
        *
        * The newline isn't really necessary, but otherwise the file
-       * will look kind of ugly, with stupid stuff like Tobtype ...
+       * will look kind of ugly, with stupid stuff like TEXTYobtype 5...
        */
       const char* expecting = "EXTY\n";
 
@@ -1046,6 +1048,26 @@ stream_autodetect_format(SDR_stream *str
 
       break;
     }
+  case 'D':
+    {
+      /* Texty format starts with DTEXTY\n
+       */
+      const char* expecting = "TEXTY\n";
+
+      do {
+        c = stream_getc(stream);
+        if(c != *expecting)
+          THROW(ExMalformed,
+                format("Bad stream format (thought it was DTEXTY); "
+                       "source \"%s\", starts with char %x\n",
+                       stream->name, c));
+        expecting++;
+      } while (c != '\n');
+
+      stream->format = SDR_DTEXTY;
+
+      break;
+    }
   default:
     {
       THROW(ExMalformed, 
@@ -2125,6 +2147,11 @@ isSafeChar(unsigned char c)
   return (isprint(c) && c != ENCODE_CHAR) || isspace(c);
 }
 
+static void dtexty_onCreate(SDR_stream *strm)
+{
+  stream_printf(strm, "DTEXTY\n");
+}
+
 static ocmoff_t
 encodedLength(const void *vp, ocmoff_t len)
 {
@@ -2207,7 +2234,6 @@ dtexty_get_field(const char *name, char 
   {
     /* Do an in-place conversion to safe form on the string that came
        back: */
-    
     unsigned char *base = fld->rep;
     unsigned char *end = base + fld->value;
     unsigned char *to = fld->rep;
@@ -2240,8 +2266,7 @@ dtexty_get_field(const char *name, char 
 	  THROW(ExMalformed, "Mis-encoded or malformed input string");
 
       }
-      else
-	*to++ = c;
+      *to++ = c;
     }
 
     fld->value = to - base;	/* len excludes terminating NUL */
@@ -2539,7 +2564,7 @@ static struct serializer sermodes[] = {
     texty_w_obname, texty_r_obname,
     texty_write, texty_read },
   /* DTEXTY streams */
-  { texty_onCreate,
+  { dtexty_onCreate,
     texty_w_u8, texty_r_u8,
     texty_w_u16, texty_r_u16,
     texty_w_u32, texty_r_u32,
