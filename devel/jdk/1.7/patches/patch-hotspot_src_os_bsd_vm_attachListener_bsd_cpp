$OpenBSD: patch-hotspot_src_os_bsd_vm_attachListener_bsd_cpp,v 1.4 2011/01/11 15:47:49 kurt Exp $
--- hotspot/src/os/bsd/vm/attachListener_bsd.cpp.orig	Mon Nov  1 13:14:58 2010
+++ hotspot/src/os/bsd/vm/attachListener_bsd.cpp	Mon Nov  1 13:16:15 2010
@@ -334,6 +334,15 @@ BsdAttachOperation* BsdAttachListener::dequeue() {
 
     // get the credentials of the peer and check the effective uid/guid
     // - check with jeff on this.
+#ifdef _ALLBSD_SOURCE
+    uid_t puid;
+    gid_t pgid;
+    if (::getpeereid(s, &puid, &pgid) != 0) {
+      int res;
+      RESTARTABLE(::close(s), res);
+      continue;
+    }
+#else
     struct ucred cred_info;
     socklen_t optlen = sizeof(cred_info);
     if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
@@ -341,10 +350,13 @@ BsdAttachOperation* BsdAttachListener::dequeue() {
       RESTARTABLE(::close(s), res);
       continue;
     }
+    uid_t puid = cred_info.uid;
+    gid_t pgid = cred_info.gid;
+#endif
     uid_t euid = geteuid();
     gid_t egid = getegid();
 
-    if (cred_info.uid != euid || cred_info.gid != egid) {
+    if (puid != euid || pgid != egid) {
       int res;
       RESTARTABLE(::close(s), res);
       continue;
@@ -464,16 +476,13 @@ bool AttachListener::is_init_trigger() {
   if (init_at_startup() || is_initialized()) {
     return false;               // initialized at startup or already initialized
   }
-  char fn[PATH_MAX+1];
-  sprintf(fn, ".attach_pid%d", os::current_process_id());
+  char path[PATH_MAX + 1];
   int ret;
-  struct stat64 st;
-  RESTARTABLE(::stat64(fn, &st), ret);
-  if (ret == -1) {
-    snprintf(fn, sizeof(fn), "%s/.attach_pid%d",
-             os::get_temp_directory(), os::current_process_id());
-    RESTARTABLE(::stat64(fn, &st), ret);
-  }
+  struct stat st;
+
+  snprintf(path, PATH_MAX + 1, "%s/.attach_pid%d",
+           os::get_temp_directory(), os::current_process_id());
+  RESTARTABLE(::stat(path, &st), ret);
   if (ret == 0) {
     // simple check to avoid starting the attach mechanism when
     // a bogus user creates the file
