$OpenBSD: patch-magick_signature_c,v 1.1 2004/11/13 20:14:18 marc Exp $
--- magick/signature.c.orig	Sat Mar 20 08:25:06 2004
+++ magick/signature.c	Thu Nov 11 13:13:09 2004
@@ -367,8 +367,19 @@ static void TransformSignature(Signature
     T2,
     W[64];
 
+  unsigned int
+    uT;
+
   shift=32;
   p=signature_info->message;
+
+  /*
+   * The original code was incorrect on sparc64 (and other arches) in that it
+   * assumes that &signature_info->message is on the appropriate boundary
+   * to cast to an unsigned long.   It isn't.   It causes a bus error
+   * on sparc64.   This code is not much better and assumes that an
+   * unsigned int is 4 bytes long.  At least it doesn't get a bus error.
+   */
   if (signature_info->lsb_first == False)
     {
       if (sizeof(unsigned long) <= 4)
@@ -379,12 +390,11 @@ static void TransformSignature(Signature
           W[i]=Trunc32(T);
         }
       else
-        for (i=0; i < 16; i+=2)
+        for (i=0; i < 16; i++)
         {
-          T=(*((unsigned long *) p));
-          p+=8;
-          W[i]=Trunc32(T >> shift);
-          W[i+1]=Trunc32(T);
+          uT=(*((unsigned int *) p));
+          p+=4;
+          W[i]=uT;
         }
     }
   else
@@ -397,15 +407,12 @@ static void TransformSignature(Signature
           ((T >> 8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);
       }
     else
-      for (i=0; i < 16; i+=2)
+      for (i=0; i < 16; i++)
       {
-        T=(*((unsigned long *) p));
-        p+=8;
-        W[i]=((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000) |
-          ((T >> 8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);
-        T>>=shift;
-        W[i+1]=((T << 24) & 0xff000000) | ((T << 8) & 0x00ff0000) |
-          ((T >> 8) & 0x0000ff00) | ((T >> 24) & 0x000000ff);
+        uT=(*((unsigned int *) p));
+        p+=4;
+        W[i]=((uT << 24) & 0xff000000) | ((uT << 8) & 0x00ff0000) |
+          ((uT >> 8) & 0x0000ff00) | ((uT >> 24) & 0x000000ff);
       }
   /*
     Copy digest to registers.
