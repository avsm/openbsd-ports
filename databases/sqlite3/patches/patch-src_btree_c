$OpenBSD: patch-src_btree_c,v 1.3 2005/05/06 02:58:04 jolan Exp $
--- src/btree.c.orig	Tue Mar 29 07:18:50 2005
+++ src/btree.c	Thu May  5 13:43:52 2005
@@ -211,12 +211,12 @@
 #include "os.h"
 #include <assert.h>
 
-/*
-** This macro rounds values up so that if the value is an address it
-** is guaranteed to be an address that is aligned to an 8-byte boundary.
+/* Round up a number to the next larger multiple of 8.  This is used
+** to force 8-byte alignment on 64-bit architectures.
 */
-#define FORCE_ALIGNMENT(X)   (((X)+7)&~7)
+#define ROUND8(x)   ((x+7)&~7)
 
+
 /* The following value is the maximum cell size assuming a maximum page
 ** size give above.
 */
@@ -308,7 +308,6 @@ struct Btree {
   u8 autoVacuum;        /* True if database supports auto-vacuum */
 #endif
   u16 pageSize;         /* Total number of bytes on a page */
-  u16 psAligned;        /* pageSize rounded up to a multiple of 8 */
   u16 usableSize;       /* Number of usable bytes on each page */
   int maxLocal;         /* Maximum local payload in non-LEAFDATA tables */
   int minLocal;         /* Minimum local payload in non-LEAFDATA tables */
@@ -714,7 +713,7 @@ static void _pageIntegrity(MemPage *pPag
   used = sqliteMallocRaw( pPage->pBt->pageSize );
   if( used==0 ) return;
   usableSize = pPage->pBt->usableSize;
-  assert( pPage->aData==&((unsigned char*)pPage)[-pPage->pBt->psAligned] );
+  assert( pPage->aData==&((unsigned char*)pPage)[-pPage->pBt->pageSize] );
   hdr = pPage->hdrOffset;
   assert( hdr==(pPage->pgno==1 ? 100 : 0) );
   assert( pPage->pgno==sqlite3pager_pagenumber(pPage->aData) );
@@ -1017,7 +1016,7 @@ static int initPage(
   assert( pBt!=0 );
   assert( pParent==0 || pParent->pBt==pBt );
   assert( pPage->pgno==sqlite3pager_pagenumber(pPage->aData) );
-  assert( pPage->aData == &((unsigned char*)pPage)[-pBt->psAligned] );
+  assert( pPage->aData == &((unsigned char*)pPage)[-pBt->pageSize] );
   if( pPage->pParent!=pParent && (pPage->pParent!=0 || pPage->isInit) ){
     /* The parent page should never change unless the file is corrupt */
     return SQLITE_CORRUPT; /* bkpt-CORRUPT */
@@ -1085,7 +1084,7 @@ static void zeroPage(MemPage *pPage, int
   int first;
 
   assert( sqlite3pager_pagenumber(data)==pPage->pgno );
-  assert( &data[pBt->psAligned] == (unsigned char*)pPage );
+  assert( &data[pBt->pageSize] == (unsigned char*)pPage );
   assert( sqlite3pager_iswriteable(data) );
   memset(&data[hdr], 0, pBt->usableSize - hdr);
   data[hdr] = flags;
@@ -1114,7 +1113,7 @@ static int getPage(Btree *pBt, Pgno pgno
   MemPage *pPage;
   rc = sqlite3pager_get(pBt->pPager, pgno, (void**)&aData);
   if( rc ) return rc;
-  pPage = (MemPage*)&aData[pBt->psAligned];
+  pPage = (MemPage*)&aData[pBt->pageSize];
   pPage->aData = aData;
   pPage->pBt = pBt;
   pPage->pgno = pgno;
@@ -1153,7 +1152,7 @@ static void releasePage(MemPage *pPage){
   if( pPage ){
     assert( pPage->aData );
     assert( pPage->pBt );
-    assert( &pPage->aData[pPage->pBt->psAligned]==(unsigned char*)pPage );
+    assert( &pPage->aData[pPage->pBt->pageSize]==(unsigned char*)pPage );
     sqlite3pager_unref(pPage->aData);
   }
 }
@@ -1164,7 +1163,9 @@ static void releasePage(MemPage *pPage){
 ** happens.
 */
 static void pageDestructor(void *pData, int pageSize){
-  MemPage *pPage = (MemPage*)&((char*)pData)[FORCE_ALIGNMENT(pageSize)];
+  MemPage *pPage;
+  assert( (pageSize & 7)==0 );
+  pPage = (MemPage*)&((char*)pData)[pageSize];
   if( pPage->pParent ){
     MemPage *pParent = pPage->pParent;
     pPage->pParent = 0;
@@ -1182,7 +1183,9 @@ static void pageDestructor(void *pData, 
 ** page to agree with the restored data.
 */
 static void pageReinit(void *pData, int pageSize){
-  MemPage *pPage = (MemPage*)&((char*)pData)[FORCE_ALIGNMENT(pageSize)];
+  MemPage *pPage;
+  assert( (pageSize & 7)==0 );
+  pPage = (MemPage*)&((char*)pData)[pageSize];
   if( pPage->isInit ){
     pPage->isInit = 0;
     initPage(pPage, pPage->pParent);
@@ -1238,7 +1241,8 @@ int sqlite3BtreeOpen(
   pBt->readOnly = sqlite3pager_isreadonly(pBt->pPager);
   sqlite3pager_read_fileheader(pBt->pPager, sizeof(zDbHeader), zDbHeader);
   pBt->pageSize = get2byte(&zDbHeader[16]);
-  if( pBt->pageSize<512 || pBt->pageSize>SQLITE_MAX_PAGE_SIZE ){
+  if( pBt->pageSize<512 || pBt->pageSize>SQLITE_MAX_PAGE_SIZE
+       || ((pBt->pageSize-1)&pBt->pageSize)!=0 ){
     pBt->pageSize = SQLITE_DEFAULT_PAGE_SIZE;
     pBt->maxEmbedFrac = 64;   /* 25% */
     pBt->minEmbedFrac = 32;   /* 12.5% */
@@ -1270,7 +1274,7 @@ int sqlite3BtreeOpen(
 #endif
   }
   pBt->usableSize = pBt->pageSize - nReserve;
-  pBt->psAligned = FORCE_ALIGNMENT(pBt->pageSize);
+  assert( (pBt->pageSize & 7)==0 );  /* 8-byte alignment of pageSize */
   sqlite3pager_set_pagesize(pBt->pPager, pBt->pageSize);
   *ppBtree = pBt;
   return SQLITE_OK;
@@ -1357,8 +1361,8 @@ int sqlite3BtreeSetPageSize(Btree *pBt, 
   }
   if( pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE &&
         ((pageSize-1)&pageSize)==0 ){
+    assert( (pageSize & 7)==0 );
     pBt->pageSize = pageSize;
-    pBt->psAligned = FORCE_ALIGNMENT(pageSize);
     sqlite3pager_set_pagesize(pBt->pPager, pageSize);
   }
   pBt->usableSize = pBt->pageSize - nReserve;
@@ -1418,7 +1422,7 @@ int sqlite3BtreeGetAutoVacuum(Btree *pBt
 ** if there is a locking protocol violation.
 */
 static int lockBtree(Btree *pBt){
-  int rc;
+  int rc, pageSize;
   MemPage *pPage1;
   if( pBt->pPage1 ) return SQLITE_OK;
   rc = getPage(pBt, 1, &pPage1);
@@ -1437,12 +1441,16 @@ static int lockBtree(Btree *pBt){
     if( page1[18]>1 || page1[19]>1 ){
       goto page1_init_failed;
     }
-    pBt->pageSize = get2byte(&page1[16]);
-    pBt->usableSize = pBt->pageSize - page1[20];
+    pageSize = get2byte(&page1[16]);
+    if( ((pageSize-1)&pageSize)!=0 ){
+      goto page1_init_failed;
+    }
+    assert( (pageSize & 7)==0 );
+    pBt->pageSize = pageSize;
+    pBt->usableSize = pageSize - page1[20];
     if( pBt->usableSize<500 ){
       goto page1_init_failed;
     }
-    pBt->psAligned = FORCE_ALIGNMENT(pBt->pageSize);
     pBt->maxEmbedFrac = page1[21];
     pBt->minEmbedFrac = page1[22];
     pBt->minLeafFrac = page1[23];
@@ -1509,7 +1517,7 @@ static void unlockBtreeIfUnused(Btree *p
   if( pBt->inTrans==TRANS_NONE && pBt->pCursor==0 && pBt->pPage1!=0 ){
     if( pBt->pPage1->aData==0 ){
       MemPage *pPage = pBt->pPage1;
-      pPage->aData = &((char*)pPage)[-pBt->psAligned];
+      pPage->aData = &((char*)pPage)[-pBt->pageSize];
       pPage->pBt = pBt;
       pPage->pgno = 1;
     }
@@ -3381,7 +3389,7 @@ static int reparentPage(Btree *pBt, Pgno
   assert( pBt->pPager!=0 );
   aData = sqlite3pager_lookup(pBt->pPager, pgno);
   if( aData ){
-    pThis = (MemPage*)&aData[pBt->psAligned];
+    pThis = (MemPage*)&aData[pBt->pageSize];
     assert( pThis->aData==aData );
     if( pThis->isInit ){
       if( pThis->pParent!=pNewParent ){
@@ -3888,15 +3896,19 @@ static int balance_nonroot(MemPage *pPag
     nMaxCells += 1+apOld[i]->nCell+apOld[i]->nOverflow;
   }
 
+  /* Make nMaxCells a multiple of 2 in order to preserve 8-byte
+  ** alignment */
+  nMaxCells = (nMaxCells + 1)&~1;
+
   /*
   ** Allocate space for memory structures
   */
   apCell = sqliteMallocRaw( 
        nMaxCells*sizeof(u8*)                           /* apCell */
      + nMaxCells*sizeof(int)                           /* szCell */
-     + sizeof(MemPage)*NB                              /* aCopy */
-     + pBt->psAligned*(5+NB)                           /* aSpace */
-     + (ISAUTOVACUUM ? nMaxCells : 0)     /* aFrom */
+     + ROUND8(sizeof(MemPage))*NB                      /* aCopy */
+     + pBt->pageSize*(5+NB)                            /* aSpace */
+     + (ISAUTOVACUUM ? nMaxCells : 0)                  /* aFrom */
   );
   if( apCell==0 ){
     rc = SQLITE_NOMEM;
@@ -3904,13 +3916,16 @@ static int balance_nonroot(MemPage *pPag
   }
   szCell = (int*)&apCell[nMaxCells];
   aCopy[0] = (u8*)&szCell[nMaxCells];
+  assert( ((aCopy[0] - (u8*)apCell) & 7)==0 ); /* 8-byte alignment required */
   for(i=1; i<NB; i++){
-    aCopy[i] = &aCopy[i-1][pBt->psAligned+sizeof(MemPage)];
+    aCopy[i] = &aCopy[i-1][pBt->pageSize+ROUND8(sizeof(MemPage))];
+    assert( ((aCopy[i] - (u8*)apCell) & 7)==0 ); /* 8-byte alignment required */
   }
-  aSpace = &aCopy[NB-1][pBt->psAligned+sizeof(MemPage)];
+  aSpace = &aCopy[NB-1][pBt->pageSize+ROUND8(sizeof(MemPage))];
+  assert( ((aSpace - (u8*)apCell) & 7)==0 ); /* 8-byte alignment required */
 #ifndef SQLITE_OMIT_AUTOVACUUM
   if( pBt->autoVacuum ){
-    aFrom = &aSpace[5*pBt->psAligned];
+    aFrom = &aSpace[5*pBt->pageSize];
   }
 #endif
   
@@ -3921,10 +3936,12 @@ static int balance_nonroot(MemPage *pPag
   ** process of being overwritten.
   */
   for(i=0; i<nOld; i++){
-    MemPage *p = apCopy[i] = (MemPage*)&aCopy[i][pBt->psAligned];
-    p->aData = &((u8*)p)[-pBt->psAligned];
-    memcpy(p->aData, apOld[i]->aData, pBt->psAligned + sizeof(MemPage));
-    p->aData = &((u8*)p)[-pBt->psAligned];
+    MemPage *p = apCopy[i] = (MemPage*)&aCopy[i][pBt->pageSize];
+    p->aData = &((u8*)p)[-pBt->pageSize];
+    memcpy(p->aData, apOld[i]->aData, pBt->pageSize + sizeof(MemPage));
+    /* The memcpy() above changes the value of p->aData so we have to
+    ** set it again. */
+    p->aData = &((u8*)p)[-pBt->pageSize];
   }
 
   /*
@@ -3982,7 +3999,7 @@ static int balance_nonroot(MemPage *pPag
         szCell[nCell] = sz;
         pTemp = &aSpace[iSpace];
         iSpace += sz;
-        assert( iSpace<=pBt->psAligned*5 );
+        assert( iSpace<=pBt->pageSize*5 );
         memcpy(pTemp, apDiv[i], sz);
         apCell[nCell] = pTemp+leafCorrection;
 #ifndef SQLITE_OMIT_AUTOVACUUM
@@ -4207,13 +4224,13 @@ static int balance_nonroot(MemPage *pPag
         pCell = &aSpace[iSpace];
         fillInCell(pParent, pCell, 0, info.nKey, 0, 0, &sz);
         iSpace += sz;
-        assert( iSpace<=pBt->psAligned*5 );
+        assert( iSpace<=pBt->pageSize*5 );
         pTemp = 0;
       }else{
         pCell -= 4;
         pTemp = &aSpace[iSpace];
         iSpace += sz;
-        assert( iSpace<=pBt->psAligned*5 );
+        assert( iSpace<=pBt->pageSize*5 );
       }
       rc = insertCell(pParent, nxDiv, pCell, sz, pTemp, 4);
       if( rc!=SQLITE_OK ) goto balance_cleanup;
