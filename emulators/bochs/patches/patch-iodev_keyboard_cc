$OpenBSD: patch-iodev_keyboard_cc,v 1.1 2001/02/02 16:59:11 todd Exp $
--- iodev/keyboard.cc.orig	Sat Mar 25 21:28:49 2000
+++ iodev/keyboard.cc	Tue Oct 31 12:27:44 2000
@@ -131,7 +131,7 @@ bx_keyb_c::init(bx_devices_c *d, bx_cmos
   BX_KEY_THIS s.kbd_controller.irq1_requested = 0;
   BX_KEY_THIS s.kbd_controller.irq12_requested = 0;
 
-//fprintf(stderr, "# keyboard_serial_delay is %u usec\n",
+//bio->printf("#KBD] keyboard_serial_delay is %u usec\n",
 //        (unsigned) bx_options.keyboard_serial_delay);
   BX_KEY_THIS s.kbd_controller.timer_pending = 0;
 
@@ -175,12 +175,14 @@ bx_keyb_c::read(Bit32u   address, unsign
 
   Bit32u ret = 0;
 
-  if (io_len > 1)
-    bx_panic("kbd: io read to address %08x, len=%u\n",
+  if (io_len > 1) {
+    bio->printf("[KBD] io read to address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
+    return ret;
+  }
 
 
-//fprintf(stderr, "# KBD: read from port 0x%04x\n", (unsigned) address);
+//bio->printf("#KBD] read from port 0x%04x\n", (unsigned) address);
 
   if (address == 0x60) { /* output buffer */
     Bit8u   val;
@@ -204,11 +206,11 @@ bx_keyb_c::read(Bit32u   address, unsign
         BX_KEY_THIS s.controller_Qsize--;
         }
 
-//bx_printf("mouse: ___io_read aux = 0x%02x\n", (unsigned) val);
+//bio->printf("[MOUSE] ___io_read aux = 0x%02x\n", (unsigned) val);
 
       activate_timer();
-      if (bx_dbg.keyboard)
-        bx_printf("KBD: READ(%02x) = %02x\n", (unsigned) address,
+      if (bio->getdbg().keyboard)
+        bio->printf("[KBD] READ(%02x) = %02x\n", (unsigned) address,
           (unsigned) val);
       RETURN(val);
       }
@@ -217,7 +219,7 @@ bx_keyb_c::read(Bit32u   address, unsign
       BX_KEY_THIS s.kbd_controller.kbd_output_buffer = 0;
       BX_KEY_THIS s.kbd_controller.outb = 0;
       BX_KEY_THIS s.kbd_controller.auxb = 0;
-//fprintf(stderr, "# ___io_read kbd\n");
+//bio->printf("#MOUSE] ___io_read kbd\n");
 
       if (BX_KEY_THIS s.controller_Qsize) {
         unsigned i;
@@ -234,15 +236,15 @@ bx_keyb_c::read(Bit32u   address, unsign
         }
 
       activate_timer();
-      if (bx_dbg.keyboard)
-        bx_printf("KBD: READ(%02x) = %02x\n", (unsigned) address,
+      if (bio->getdbg().keyboard)
+        bio->printf("[KBD] READ(%02x) = %02x\n", (unsigned) address,
           (unsigned) val);
       RETURN(val);
       }
     else {
-      if (bx_dbg.keyboard) {
-        bx_printf("KBD: num_elements = %d\n", BX_KEY_THIS s.kbd_internal_buffer.num_elements);
-        bx_printf("KBD: read from port 60h with outb empty\n");
+      if (bio->getdbg().keyboard) {
+        bio->printf("[KBD] num_elements = %d\n", BX_KEY_THIS s.kbd_internal_buffer.num_elements);
+        bio->printf("[KBD] read from port 60h with outb empty\n");
         }
       val = 0;
       RETURN(val);
@@ -267,21 +269,21 @@ bx_keyb_c::read(Bit32u   address, unsign
 #else /* BX_CPU_LEVEL > 0 */
   /* XT MODE, System 8255 Mode Register */
   else if (address == 0x64) { /* status register */
-    if (bx_dbg.keyboard)
-      bx_printf("KBD: IO read from port 64h, system 8255 mode register\n");
+    if (bio->getdbg().keyboard)
+      bio->printf("[KBD] IO read from port 64h, system 8255 mode register\n");
     RETURN(BX_KEY_THIS s.kbd_controller.outb);
     }
 #endif /* BX_CPU_LEVEL > 0 */
 
   else {
-    bx_panic("KBD: unknown address in io read to keyboard port %x\n",
+    bio->printf("[KBD] unknown address in io read to keyboard port %x\n",
       (unsigned) address);
     RETURN(0); /* keep compiler happy */
     }
 
   read_return:
-  if (bx_dbg.keyboard)
-	bx_printf("keyboard: 8-bit read from %04x = %02x\n", (unsigned)address, ret);
+  if (bio->getdbg().keyboard)
+	bio->printf("[KBD] 8-bit read from %04x = %02x\n", (unsigned)address, ret);
   return ret;
 }
 
@@ -306,15 +308,17 @@ bx_keyb_c::write( Bit32u   address, Bit3
 #endif  // !BX_USE_KEY_SMF
   Bit8u   command_byte;
 
-  if (io_len > 1)
-    bx_panic("kbd: io write to address %08x, len=%u\n",
+  if (io_len > 1) {
+    bio->printf("[KBD] io write to address %08x, len=%u\n",
              (unsigned) address, (unsigned) io_len);
+    return;
+  }
 
-  if (bx_dbg.keyboard)
-	bx_printf("keyboard: 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
+  if (bio->getdbg().keyboard)
+	bio->printf("[KBD] 8-bit write to %04x = %02x\n", (unsigned)address, (unsigned)value);
 
 
-//fprintf(stderr, "# KBD: WRITE(%02x) = %02x\n", (unsigned) address,
+//bio->printf("[KBD] WRITE(%02x) = %02x\n", (unsigned) address,
 //      (unsigned) value);
 
   switch (address) {
@@ -325,7 +329,8 @@ bx_keyb_c::write( Bit32u   address, Bit3
         // data byte written last to 0x60
         BX_KEY_THIS s.kbd_controller.c_d = 0;
         if (BX_KEY_THIS s.kbd_controller.inpb) {
-          bx_panic("KBD: write to port 60h, not ready for write\n");
+          bio->printf("[KBD] write to port 60h, not ready for write\n");
+	  break;
           }
         switch (BX_KEY_THIS s.kbd_controller.last_comm) {
           case 0x60: // write command byte
@@ -346,21 +351,22 @@ bx_keyb_c::write( Bit32u   address, Bit3
             else if (BX_KEY_THIS s.kbd_controller.allow_irq1  && BX_KEY_THIS s.kbd_controller.outb)
               BX_KEY_THIS s.kbd_controller.irq1_requested = 1;
 
-//fprintf(stderr, "# allow_irq12 set to %u\n", (unsigned)
+//bio->printf("#KBD] allow_irq12 set to %u\n", (unsigned)
 //  BX_KEY_THIS s.kbd_controller.allow_irq12);
             if ( !scan_convert )
-              bx_printf("keyboard: (mch) scan convert turned off\n");
+              bio->printf("[KBD] (mch) scan convert turned off\n");
 
 	    // (mch) NT needs this
 	    BX_KEY_THIS s.kbd_controller.scan_convert = scan_convert;
             }
             break;
           case 0xd1: // write output port
-            if (bx_dbg.keyboard)
-              bx_printf("KBD: write output port with value %02xh\n",
+            if (bio->getdbg().keyboard)
+              bio->printf("[KBD] write output port with value %02xh\n",
                 (unsigned) value);
             BX_SET_ENABLE_A20( (value & 0x02) != 0 );
-            if (!(value & 0x01)) bx_panic("KBD: IO write: processor reset requested!\n");
+            if (!(value & 0x01)) /* XXX insert reset?? */
+		bio->printf("[KBD] IO write: processor reset requested!\n");
             break;
           case 0xd4: // Write to mouse
             // I don't think this enables the AUX clock
@@ -375,7 +381,7 @@ bx_keyb_c::write( Bit32u   address, Bit3
             break;
 
           default:
-            bx_panic("KBD: === unsupported write to port 60h(lastcomm=%02x): %02x\n",
+            bio->printf("[KBD] === unsupported write to port 60h(lastcomm=%02x): %02x\n",
               (unsigned) BX_KEY_THIS s.kbd_controller.last_comm, (unsigned) value);
           }
         }
@@ -386,7 +392,7 @@ bx_keyb_c::write( Bit32u   address, Bit3
         /* pass byte to keyboard */
         /* ??? should conditionally pass to mouse device here ??? */
         if (BX_KEY_THIS s.kbd_controller.kbd_clock_enabled==0) {
-          bx_printf("KBD: keyboard disabled & send of byte %02x to kbd\n",
+          bio->printf("[KBD] keyboard disabled & send of byte %02x to kbd\n",
             (unsigned) value);
           }
         kbd_ctrl_to_kbd(value);
@@ -402,11 +408,11 @@ bx_keyb_c::write( Bit32u   address, Bit3
 
       switch (value) {
         case 0x20: // get keyboard command byte
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: get keyboard command byte\n");
+          if (bio->getdbg().keyboard)
+            bio->printf("[KBD] get keyboard command byte\n");
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           command_byte =
@@ -420,37 +426,37 @@ bx_panic("kbd: OUTB set and command 0x%0
           controller_enQ(command_byte, 0);
           break;
         case 0x60: // write command byte
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: write command byte\n");
+          if (bio->getdbg().keyboard)
+            bio->printf("[KBD] write command byte\n");
           // following byte written to port 60h is command byte
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
 
         case 0xa1:
-          bx_printf ("KBD: Dummy out Green PC for now : 0xa1\n");
+          bio->printf ("[KBD] Dummy out Green PC for now : 0xa1\n");
           break;
 
         case 0xa7: // disable the aux device
           set_aux_clock_enable(0);
-          if (bx_dbg.keyboard) bx_printf("KBD: aux device disabled\n");
+          if (bio->getdbg().keyboard) bio->printf("[KBD] aux device disabled\n");
           break;
         case 0xa8: // enable the aux device
           set_aux_clock_enable(1);
-          if (bx_dbg.keyboard) bx_printf("KBD: aux device enabled\n");
+          if (bio->getdbg().keyboard) bio->printf("[KBD] aux device enabled\n");
           break;
         case 0xa9: // Test Mouse Port
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           controller_enQ(0x00, 0); // no errors detected
           break;
         case 0xaa: // motherboard controller self test
-          if (bx_dbg.keyboard) bx_printf("KBD: Self Test\n");
+          if (bio->getdbg().keyboard) bio->printf("[KBD] Self Test\n");
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
 	  // (mch) Why is this commented out??? Enabling
@@ -460,34 +466,34 @@ bx_panic("kbd: OUTB set and command 0x%0
         case 0xab: // Interface Test
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           controller_enQ(0x00, 0);
           break;
         case 0xad: // disable keyboard
           set_kbd_clock_enable(0);
-          if (bx_dbg.keyboard) bx_printf("KBD: keyboard disabled\n");
+          if (bio->getdbg().keyboard) bio->printf("[KBD] keyboard disabled\n");
           break;
         case 0xae: // enable keyboard
           set_kbd_clock_enable(1);
-          if (bx_dbg.keyboard) bx_printf("KBD: keyboard enabled\n");
+          if (bio->getdbg().keyboard) bio->printf("[KBD] keyboard enabled\n");
           break;
         case 0xc0: // read input port
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           // keyboard power normal
           controller_enQ(0x00, 0);
           break;
         case 0xd0: // read output port: next byte read from port 60h
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: io write to port 64h, command d0h (partial)\n");
+          if (bio->getdbg().keyboard)
+            bio->printf("[KBD] io write to port 64h, command d0h (partial)\n");
           // controller output buffer must be empty
           if (BX_KEY_THIS s.kbd_controller.outb) {
-bx_panic("kbd: OUTB set and command 0x%02x encountered\n", value);
+bio->printf("[KBD] OUTB set and command 0x%02x encountered\n", value);
             break;
             }
           controller_enQ(
@@ -498,20 +504,20 @@ bx_panic("kbd: OUTB set and command 0x%0
           break;
 
         case 0xd1: // write output port: next byte written to port 60h
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: write output port\n");
+          if (bio->getdbg().keyboard)
+            bio->printf("[KBD] write output port\n");
           // following byte to port 60h written to output port
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
 
         case 0xd3: // write mouse output buffer
-          bx_panic("KBD: io write 0x64: command = 0xD3(write mouse outb)\n");
+          bio->printf("[KBD] io write 0x64: command = 0xD3(write mouse outb)\n");
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
 
         case 0xd4: // write to mouse
-          if (bx_dbg.mouse)
-            bx_printf("KBD: io write 0x64: command = 0xD4 (write to mouse)\n");
+          if (bio->getdbg().mouse)
+            bio->printf("[KBD] io write 0x64: command = 0xD4 (write to mouse)\n");
           // following byte written to port 60h
           BX_KEY_THIS s.kbd_controller.expecting_port60h = 1;
           break;
@@ -522,32 +528,34 @@ bx_panic("kbd: OUTB set and command 0x%0
         case 0xc1: // Continuous Input Port Poll, Low
         case 0xc2: // Continuous Input Port Poll, High
         case 0xe0: // Read Test Inputs
-          bx_panic("KBD: io write 0x64: command = %02xh\n", (unsigned) value);
+          bio->printf("[KBD] io write 0x64: command = %02xh\n", (unsigned) value);
           break;
 
         case 0xfe: // System Reset, transition to real mode
-          if (bx_dbg.keyboard)
-            bx_printf("KBD: system reset\n");
-          bx_panic("system reset via KBD ctrl command FEh\n");
+          if (bio->getdbg().keyboard)
+            bio->printf("[KBD] system reset via ctrl command FEh\n");
+          bx_pc_system.ResetSignal( PCS_SET ); /* XXX is this right? */
+	  BX_CPU.reset(BX_RESET_HARDWARE);
           // Use bx_pc_system if necessary bx_cpu.reset_cpu();
-          bx_pc_system.ResetSignal( PCS_SET );
+          // bx_pc_system.ResetSignal( PCS_SET );
           break;
 
         default:
           if (value==0xff || (value>=0xf0 && value<=0xfd)) {
             /* useless pulse output bit commands ??? */
-            if (bx_dbg.keyboard)
-              bx_printf("KBD: io write to port 64h, useless command %02x\n",
+            if (bio->getdbg().keyboard)
+              bio->printf("[KBD] io write to port 64h, useless command %02x\n",
                 (unsigned) value);
             return;
 	    }
-          bx_panic("KBD: unsupported io write to keyboard port %x, value = %x\n",
+          bio->printf("[KBD] unsupported io write to keyboard port %x, value = %x\n",
             (unsigned) address, (unsigned) value);
           break;
         }
       break;
 
-    default: bx_panic("KBD: unknown address in bx_keyb_c::write()\n");
+    default:
+	bio->printf("[KBD] unknown address in bx_keyb_c::write()\n");
     }
 }
 
@@ -557,15 +565,17 @@ bx_keyb_c::gen_scancode(Bit32u   key)
 {
   Bit8u   scancode;
 
-  if (bx_dbg.record_io) {
-	fprintf((FILE*)bx_dbg.record_io, "gen_scancode %lld %x\n", bx_pc_system.time_ticks(), key);
+  if (bio->getdbg().record_io) {
+	fprintf((FILE*)bio->getdbg().record_io, "gen_scancode %lld %x\n", bx_pc_system.time_ticks(), key);
   }
 
-  if (!BX_KEY_THIS s.kbd_controller.scan_convert)
-	bx_panic("keyboard: gen_scancode with scan_convert cleared\n");
+  if (!BX_KEY_THIS s.kbd_controller.scan_convert) {
+	bio->printf("[KBD] gen_scancode with scan_convert cleared\n");
+	return;
+  }
 
-  if (bx_dbg.keyboard)
-    bx_printf("KBD: gen_scancode(): scancode: %08x\n", (unsigned) key);
+  if (bio->getdbg().keyboard)
+    bio->printf("[KBD] gen_scancode(): scancode: %08x\n", (unsigned) key);
 
   // Ignore scancode if keyboard clock is driven low
   if (BX_KEY_THIS s.kbd_controller.kbd_clock_enabled==0)
@@ -640,20 +650,21 @@ bx_keyb_c::gen_scancode(Bit32u   key)
     case BX_KEY_GRAVE:         scancode = 0x29; break;
 
     case BX_KEY_BACKSPACE:     scancode = 0x0e; break;
+    case BX_KEY_KP_ENTER:
     case BX_KEY_ENTER:         scancode = 0x1c; break;
     case BX_KEY_TAB:           scancode = 0x0f; break;
 
     case BX_KEY_LEFT:
-      //fprintf(stderr,"# Grey left-arrow key not on 83-key keyboard\n");
+      //bio->printf("#KBD] Grey left-arrow key not on 83-key keyboard\n");
       scancode = 0x4b; break;
     case BX_KEY_RIGHT:
-      //fprintf(stderr,"# Grey right-arrow key not on 83-key keyboard\n");
+      //bio->printf("#KBD] Grey right-arrow key not on 83-key keyboard\n");
       scancode = 0x4d; break;
     case BX_KEY_UP:
-      //fprintf(stderr,"# Grey up-arrow key not on 83-key keyboard\n");
+      //bio->printf("#KBD] Grey up-arrow key not on 83-key keyboard\n");
       scancode = 0x48; break;
     case BX_KEY_DOWN:
-      //fprintf(stderr,"# Grey down-arrow key not on 83-key keyboard\n");
+      //bio->printf("#KBD] Grey down-arrow key not on 83-key keyboard\n");
       scancode = 0x50; break;
 
     case BX_KEY_KP_LEFT:       scancode = 0x4b; break;
@@ -661,43 +672,46 @@ bx_keyb_c::gen_scancode(Bit32u   key)
     case BX_KEY_KP_UP:         scancode = 0x48; break;
     case BX_KEY_KP_DOWN:       scancode = 0x50; break;
 
-    case BX_KEY_INSERT:
-      fprintf(stderr,"# Grey insert key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_DELETE:
-      fprintf(stderr,"# Grey delete key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_HOME:
-      fprintf(stderr,"# Grey home key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_END:
-      fprintf(stderr,"# Grey end key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_PAGE_UP:
-      fprintf(stderr,"# Grey page-up key not on 83-key keyboard\n");
-      return;
-    case BX_KEY_PAGE_DOWN:
-      fprintf(stderr,"# Grey page-down key not on 83-key keyboard\n");
-      return;
+    //case BX_KEY_INSERT:
+      //bio->printf("#KBD] Grey insert key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_DELETE:
+      //bio->printf("#KBD] Grey delete key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_HOME:
+      //bio->printf("#KBD] Grey home key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_END:
+      //bio->printf("#KBD] Grey end key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_PAGE_UP:
+      //bio->printf("#KBD] Grey page-up key not on 83-key keyboard\n");
+      //return;
+    //case BX_KEY_PAGE_DOWN:
+      //bio->printf("#KBD] Grey page-down key not on 83-key keyboard\n");
+      //return;
 
+    case BX_KEY_INSERT:
     case BX_KEY_KP_INSERT:        scancode = 0x52; break;
+    case BX_KEY_DELETE:
     case BX_KEY_KP_DELETE:        scancode = 0x53; break;
+    case BX_KEY_HOME:
     case BX_KEY_KP_HOME:          scancode = 0x47; break;
+    case BX_KEY_END:
     case BX_KEY_KP_END:           scancode = 0x4f; break;
+    case BX_KEY_PAGE_UP:
     case BX_KEY_KP_PAGE_UP:       scancode = 0x49; break;
+    case BX_KEY_PAGE_DOWN:
     case BX_KEY_KP_PAGE_DOWN:     scancode = 0x51; break;
 
     case BX_KEY_KP_ADD:           scancode = 0x4e; break;
     case BX_KEY_KP_SUBTRACT:      scancode = 0x4a; break;
     case BX_KEY_KP_5:             scancode = 0x4c; break;
-    case BX_KEY_KP_ENTER:
-      fprintf(stderr,"# Grey Enter key not on 83-key keyboard\n");
-      return;
     case BX_KEY_KP_MULTIPLY:
-      fprintf(stderr,"# Grey Multiply key not on 83-key keyboard\n");
+      bio->printf("#KBD] Grey Multiply key not on 83-key keyboard\n");
       return;
     case BX_KEY_KP_DIVIDE:
-      fprintf(stderr,"# Grey Divide key not on 83-key keyboard\n");
+      bio->printf("#KBD] Grey Divide key not on 83-key keyboard\n");
       return;
     case BX_KEY_NUM_LOCK:         scancode = 0x45; break;
 
@@ -713,7 +727,7 @@ bx_keyb_c::gen_scancode(Bit32u   key)
     case BX_KEY_F10:              scancode = 0x44; break;
 
     default:
-      fprintf(stderr, "# bx_keyb_c::gen_scancode : Unhandled %u\n",
+      bio->printf("#KBD] bx_keyb_c::gen_scancode : Unhandled %u\n",
         (unsigned) key);
       return;
     }
@@ -750,8 +764,8 @@ bx_keyb_c::set_aux_clock_enable(Bit8u   
 {
   Boolean prev_aux_clock_enabled;
 
-  if (bx_dbg.keyboard)
-	bx_printf("set_aux_clock_enable(%u)\n", (unsigned) value);
+  if (bio->getdbg().keyboard)
+	bio->printf("[KBD] set_aux_clock_enable(%u)\n", (unsigned) value);
   if (value==0) {
     BX_KEY_THIS s.kbd_controller.aux_clock_enabled = 0;
     }
@@ -768,8 +782,8 @@ bx_keyb_c::set_aux_clock_enable(Bit8u   
 bx_keyb_c::get_kbd_enable(void)
 {
 #ifdef BX_DEBUG
-  if (bx_dbg.keyboard)
-    bx_printf("KBD: get_kbd_enable(): getting kbd_clock_enabled of: %02x\n",
+  if (bio->getdbg().keyboard)
+    bio->printf("[KBD] get_kbd_enable(): getting kbd_clock_enabled of: %02x\n",
       (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
 #endif
 
@@ -781,16 +795,16 @@ bx_keyb_c::controller_enQ(Bit8u   data, 
 {
   // source is 0 for keyboard, 1 for mouse
 
-  if (bx_dbg.keyboard)
-    bx_printf("controller_enQ(%02x)\n", (unsigned) data);
+  if (bio->getdbg().keyboard)
+    bio->printf("[KBD] controller_enQ(%02x)\n", (unsigned) data);
 
   if (BX_KEY_THIS s.kbd_controller.outb)
-    bx_printf("KBD: controller_enQ(): OUTB set!\n");
+    bio->printf("[KBD] controller_enQ(): OUTB set!\n");
 
   // see if we need to Q this byte from the controller
   if (BX_KEY_THIS s.kbd_controller.outb) {
     if (BX_KEY_THIS s.controller_Qsize >= BX_KBD_CONTROLLER_QSIZE)
-      bx_panic("KBD: controller_enq(): controller_Q full!\n");
+      bio->printf("[KBD] controller_enq(): controller_Q full!\n");
     BX_KEY_THIS s.controller_Q[BX_KEY_THIS s.controller_Qsize++] = data;
     BX_KEY_THIS s.controller_Qsource = source;
     return;
@@ -820,7 +834,7 @@ bx_keyb_c::kbd_enQ_imm(Bit8u val)
       int tail;
 
       if (BX_KEY_THIS s.kbd_internal_buffer.num_elements >= BX_KBD_ELEMENTS) {
-	    bx_panic("KBD: internal keyboard buffer full (imm)\n");
+	    bio->printf("[KBD] internal keyboard buffer full (imm)\n");
 	    return;
       }
 
@@ -841,18 +855,18 @@ bx_keyb_c::kbd_enQ(Bit8u   scancode)
 {
   int tail;
 
-  if (bx_dbg.keyboard)
-    bx_printf("enQ(%02x)\n", (unsigned) scancode);
+  if (bio->getdbg().keyboard)
+    bio->printf("[KBD] enQ(%02x)\n", (unsigned) scancode);
 
   if (BX_KEY_THIS s.kbd_internal_buffer.num_elements >= BX_KBD_ELEMENTS) {
-    bx_printf("KBD: internal keyboard buffer full, ignoring scancode.(%02x)\n",
+    bio->printf("[KBD] internal keyboard buffer full, ignoring scancode.(%02x)\n",
       (unsigned) scancode);
     return;
     }
 
   /* enqueue scancode in multibyte internal keyboard buffer */
-  if (bx_dbg.keyboard)
-    bx_printf("KBD: enQ: putting scancode %02x in internal buffer\n",
+  if (bio->getdbg().keyboard)
+    bio->printf("[KBD] enQ: putting scancode %02x in internal buffer\n",
       (unsigned) scancode);
   tail = (BX_KEY_THIS s.kbd_internal_buffer.head + BX_KEY_THIS s.kbd_internal_buffer.num_elements) %
    BX_KBD_ELEMENTS;
@@ -861,14 +875,14 @@ bx_keyb_c::kbd_enQ(Bit8u   scancode)
 
   if (!BX_KEY_THIS s.kbd_controller.outb && BX_KEY_THIS s.kbd_controller.kbd_clock_enabled) {
     activate_timer();
-//fprintf(stderr, "# activating timer...\n");
+//bio->printf("#KBD] activating timer...\n");
     return;
     }
-//fprintf(stderr, "# not activating timer...\n");
-//fprintf(stderr, "#   allow_irq1 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq1);
-//fprintf(stderr, "#   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
-//fprintf(stderr, "#   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
-//fprintf(stderr, "#   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_output_buffer);
+//bio->printf("#KBD] not activating timer...\n");
+//bio->printf("#KBD]   allow_irq1 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq1);
+//bio->printf("#KBD]   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
+//bio->printf("#KBD]   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_clock_enabled);
+//bio->printf("#KBD]   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.kbd_output_buffer);
 }
 
   Boolean
@@ -878,7 +892,7 @@ bx_keyb_c::mouse_enQ_packet(Bit8u   b1, 
     return(0); /* buffer doesn't have the space */
     }
 
-//bx_printf("mouse: enQ_packet(%02x, %02x, %02x)\n",
+//bio->printf("[MOUSE] enQ_packet(%02x, %02x, %02x)\n",
 //  (unsigned) b1, (unsigned) b2, (unsigned) b3);
 
   mouse_enQ(b1);
@@ -893,15 +907,15 @@ bx_keyb_c::mouse_enQ(Bit8u   mouse_data)
 {
   int tail;
 
-  if (bx_dbg.mouse)
-    bx_printf("mouse_enQ(%02x)\n", (unsigned) mouse_data);
+  if (bio->getdbg().mouse)
+    bio->printf("[MOUSE] mouse_enQ(%02x)\n", (unsigned) mouse_data);
 
   if (BX_KEY_THIS s.mouse_internal_buffer.num_elements >= BX_MOUSE_BUFF_SIZE) {
-    bx_printf("mouse: internal mouse buffer full, ignoring mouse data.(%02x)\n",
+    bio->printf("[MOUSE] internal mouse buffer full, ignoring mouse data.(%02x)\n",
       (unsigned) mouse_data);
     return;
     }
-//fprintf(stderr, "# mouse_enq() aux_clock_enabled = %u\n",
+//bio->printf("#MOUSE] mouse_enq() aux_clock_enabled = %u\n",
 //  (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
 
   /* enqueue mouse data in multibyte internal mouse buffer */
@@ -912,33 +926,33 @@ bx_keyb_c::mouse_enQ(Bit8u   mouse_data)
 
   if (!BX_KEY_THIS s.kbd_controller.outb && BX_KEY_THIS s.kbd_controller.aux_clock_enabled) {
     activate_timer();
-//fprintf(stderr, "# activating timer...\n");
+//bio->printf("#MOUSE] activating timer...\n");
     return;
     }
-//fprintf(stderr, "# not activating timer...\n");
-//fprintf(stderr, "#   allow_irq12= %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
-//fprintf(stderr, "#   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
-//fprintf(stderr, "#   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
-//fprintf(stderr, "#   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_output_buffer);
+//bio->printf("#MOUSE] not activating timer...\n");
+//bio->printf("#MOUSE]   allow_irq12= %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
+//bio->printf("#MOUSE]   outb       = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.outb);
+//bio->printf("#MOUSE]   clock_enab = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
+//bio->printf("#MOUSE]   out_buffer = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.aux_output_buffer);
 }
 
   void
 bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value)
 {
-  if (bx_dbg.keyboard)
-	bx_printf("KBD: controller passed byte %02xh to keyboard\n");
+  if (bio->getdbg().keyboard)
+	bio->printf("[KBD] controller passed byte %02xh to keyboard\n");
 
   if (BX_KEY_THIS s.kbd_internal_buffer.expecting_typematic) {
     BX_KEY_THIS s.kbd_internal_buffer.expecting_typematic = 0;
     BX_KEY_THIS s.kbd_internal_buffer.delay = (value >> 5) & 0x03;
     switch (BX_KEY_THIS s.kbd_internal_buffer.delay) {
-      case 0: bx_printf("KBD: setting delay to 250 mS\n"); break;
-      case 1: bx_printf("KBD: setting delay to 250 mS\n"); break;
-      case 2: bx_printf("KBD: setting delay to 250 mS\n"); break;
-      case 3: bx_printf("KBD: setting delay to 250 mS\n"); break;
+      case 0: bio->printf("[KBD] setting delay to 250 mS\n"); break;
+      case 1: bio->printf("[KBD] setting delay to 250 mS\n"); break;
+      case 2: bio->printf("[KBD] setting delay to 250 mS\n"); break;
+      case 3: bio->printf("[KBD] setting delay to 250 mS\n"); break;
       }
     BX_KEY_THIS s.kbd_internal_buffer.repeat_rate = value & 0x1f;
-    bx_printf("KBD: setting repeat rate to %u\n", (unsigned) value);
+    bio->printf("[KBD] setting repeat rate to %u\n", (unsigned) value);
     kbd_enQ(0xFA); // send ACK
     return;
     }
@@ -946,7 +960,7 @@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
   if (BX_KEY_THIS s.kbd_internal_buffer.expecting_led_write) {
     BX_KEY_THIS s.kbd_internal_buffer.expecting_led_write = 0;
     BX_KEY_THIS s.kbd_internal_buffer.led_status = value;
-    bx_printf("KBD: LED status set to %02x\n",
+    bio->printf("[KBD] LED status set to %02x\n",
       (unsigned) BX_KEY_THIS s.kbd_internal_buffer.led_status);
     kbd_enQ(0xFA); // send ACK %%%
     return;
@@ -977,14 +991,14 @@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       break;
 
     case 0xf2:  // identify keyboard
-      bx_printf("KBD: indentify keyboard command received\n");
+      bio->printf("[KBD] indentify keyboard command received\n");
       kbd_enQ(0xFA); // AT sends ACK, MFII sends ACK+ABh+41h
       return;
       break;
 
     case 0xf3:  // typematic info
       BX_KEY_THIS s.kbd_internal_buffer.expecting_typematic = 1;
-      bx_printf("KBD: setting typematic info\n");
+      bio->printf("[KBD] setting typematic info\n");
       kbd_enQ(0xFA); // send ACK
       return;
       break;
@@ -1000,7 +1014,7 @@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       resetinternals(1);
       kbd_enQ(0xFA); // send ACK
       BX_KEY_THIS s.kbd_internal_buffer.scanning_enabled = 0;
-      bx_printf ("KBD: reset-disable command received\n");
+      bio->printf ("[KBD] reset-disable command received\n");
       return;
       break;
 
@@ -1008,7 +1022,7 @@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       resetinternals(1);
       kbd_enQ(0xFA); // send ACK
       BX_KEY_THIS s.kbd_internal_buffer.scanning_enabled = 1;
-      bx_printf ("KBD: reset-enable command received\n");
+      bio->printf ("[KBD] reset-enable command received\n");
       return;
       break;
 
@@ -1026,12 +1040,12 @@ bx_keyb_c::kbd_ctrl_to_kbd(Bit8u   value
       break;
 
     case 0xfe:  // resend. aiiee.
-      bx_panic ("KBD: got 0xFE (resend)\n");
+      bio->printf("[KBD] got 0xFE (resend)\n");
       return;
       break;
 
     case 0xff:  // reset: internal keyboard reset and afterwards the BAT
-      bx_printf("KBD: rest command received\n");
+      bio->printf("[KBD] rest command received\n");
       kbd_enQ(0xFA); // send ACK
       kbd_enQ(0xAA); // BAT test passed
       return;
@@ -1042,7 +1056,7 @@ case 0xd3:
   return;
 
     default:
-      bx_panic("KBD: kbd_ctrl_to_kbd(): got value of %02x\n",
+      bio->printf("[KBD] kbd_ctrl_to_kbd(): got value of %02x\n",
         (unsigned) value);
       kbd_enQ(0xFA); /* send ACK ??? */
       return;
@@ -1085,14 +1099,14 @@ bx_keyb_c::periodic( Bit32u   usec_delta
 
   /* nothing in outb, look for possible data xfer from keyboard or mouse */
   if (BX_KEY_THIS s.kbd_controller.kbd_clock_enabled && BX_KEY_THIS s.kbd_internal_buffer.num_elements) {
-//fprintf(stderr, "#   servicing keyboard code\n");
-    if (bx_dbg.keyboard)
-      bx_printf("KBD: service_keyboard: key in internal buffer waiting\n");
+//bio->printf("#KBD]   servicing keyboard code\n");
+    if (bio->getdbg().keyboard)
+      bio->printf("[KBD] service_keyboard: key in internal buffer waiting\n");
     BX_KEY_THIS s.kbd_controller.kbd_output_buffer =
       BX_KEY_THIS s.kbd_internal_buffer.buffer[BX_KEY_THIS s.kbd_internal_buffer.head];
     BX_KEY_THIS s.kbd_controller.outb = 1;
     BX_KEY_THIS s.kbd_controller.auxb = 0;
-//fprintf(stderr, "# ___kbd::periodic kbd\n");
+//bio->printf("#KBD] ___kbd::periodic kbd\n");
     BX_KEY_THIS s.kbd_internal_buffer.head = (BX_KEY_THIS s.kbd_internal_buffer.head + 1) %
       BX_KBD_ELEMENTS;
     BX_KEY_THIS s.kbd_internal_buffer.num_elements--;
@@ -1100,26 +1114,26 @@ bx_keyb_c::periodic( Bit32u   usec_delta
       BX_KEY_THIS s.kbd_controller.irq1_requested = 1;
     }
   else if (BX_KEY_THIS s.kbd_controller.aux_clock_enabled && BX_KEY_THIS s.mouse_internal_buffer.num_elements) {
-//fprintf(stderr, "#   servicing mouse code\n");
-    if (bx_dbg.mouse)
-      bx_printf("KBD: service_keyboard: key in internal buffer waiting\n");
+//bio->printf("#MOUSE]   servicing mouse code\n");
+    if (bio->getdbg().mouse)
+      bio->printf("[KBD] service_keyboard: key in internal buffer waiting\n");
     BX_KEY_THIS s.kbd_controller.aux_output_buffer =
       BX_KEY_THIS s.mouse_internal_buffer.buffer[BX_KEY_THIS s.mouse_internal_buffer.head];
 
     BX_KEY_THIS s.kbd_controller.outb = 1;
     BX_KEY_THIS s.kbd_controller.auxb = 1;
-//fprintf(stderr, "# ___kbd:periodic aux\n");
+//bio->printf("#KBD] ___kbd:periodic aux\n");
     BX_KEY_THIS s.mouse_internal_buffer.head = (BX_KEY_THIS s.mouse_internal_buffer.head + 1) %
       BX_MOUSE_BUFF_SIZE;
     BX_KEY_THIS s.mouse_internal_buffer.num_elements--;
-//fprintf(stderr, "#   allow12 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
+//bio->printf("#KBD]   allow12 = %u\n", (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
     if (BX_KEY_THIS s.kbd_controller.allow_irq12)
       BX_KEY_THIS s.kbd_controller.irq12_requested = 1;
     }
   else {
-//fprintf(stderr, "#   servicing no code\n");
-    if (bx_dbg.keyboard) {
-      bx_printf("KBD: service_keyboard(): no keys waiting\n");
+//bio->printf("#KBD]   servicing no code\n");
+    if (bio->getdbg().keyboard) {
+      bio->printf("[KBD] service_keyboard(): no keys waiting\n");
       }
     }
   return(retval);
@@ -1141,13 +1155,13 @@ bx_keyb_c::activate_timer(void)
   void
 bx_keyb_c::kbd_ctrl_to_mouse(Bit8u   value)
 {
-bx_printf("MOUSE: kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
-bx_printf("  enable = %u\n", (unsigned) BX_KEY_THIS s.mouse.enable);
-bx_printf("  allow_irq12 = %u\n",
+bio->printf("[MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+bio->printf("[MOUSE]  enable = %u", (unsigned) BX_KEY_THIS s.mouse.enable);
+bio->printf("[MOUSE]  allow_irq12 = %u\n",
   (unsigned) BX_KEY_THIS s.kbd_controller.allow_irq12);
-bx_printf("  aux_clock_enabled = %u\n",
+bio->printf("[MOUSE]  aux_clock_enabled = %u\n",
   (unsigned) BX_KEY_THIS s.kbd_controller.aux_clock_enabled);
-//fprintf(stderr, "# MOUSE: kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+//bio->printf("#MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
 
   // an ACK (0xFA) is always the first response to any valid input
   // received from the system other than Set-Wrap-Mode & Resend-Command
@@ -1158,8 +1172,8 @@ bx_printf("  aux_clock_enabled = %u\n",
        switch (BX_KEY_THIS s.kbd_controller.last_mouse_command) {
 	     case 0xf3: // Set Mouse Sample Rate
 		   BX_KEY_THIS s.mouse.sample_rate = value;
-		   if (bx_dbg.mouse)
-			 bx_printf("[mouse] Sampling rate set: %d Hz\n", value);
+		   if (bio->getdbg().mouse)
+			 bio->printf("[mouse] Sampling rate set: %d Hz\n", value);
 		   controller_enQ(0xFA, 1); // ack
 		   break;
 
@@ -1178,18 +1192,19 @@ bx_printf("  aux_clock_enabled = %u\n",
 			       BX_KEY_THIS s.mouse.resolution_cpmm = 8;
 			       break;
 			 default:
-			       bx_panic("[mouse] Unknown resolution %d\n", value);
+			       bio->printf("[mouse] Unknown resolution %d\n", value);
 			       break;
 		   }
-		   if (bx_dbg.mouse)
-			 bx_printf("[mouse] Resolution set to %d counts per mm\n",
+		   if (bio->getdbg().mouse)
+			 bio->printf("[mouse] Resolution set to %d counts per mm\n",
 				   BX_KEY_THIS s.mouse.resolution_cpmm);
 
 		   controller_enQ(0xFA, 1); // ack
 		   break;
 
 	     default:
-		   bx_panic("MOUSE: unknown last command (%02xh)\n", (unsigned) BX_KEY_THIS s.kbd_controller.last_mouse_command);
+		   bio->printf("[MOUSE] unknown last command (%02xh)\n", (unsigned) BX_KEY_THIS s.kbd_controller.last_mouse_command);
+		   break;
        }
  } else {
   BX_KEY_THIS s.kbd_controller.expecting_mouse_parameter = 0;
@@ -1198,15 +1213,15 @@ bx_printf("  aux_clock_enabled = %u\n",
     case 0xe6: // Set Mouse Scaling to 1:1
       controller_enQ(0xFA, 1); // ACK
       BX_KEY_THIS s.mouse.scaling         = 2;
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Scaling set to 1:1\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Scaling set to 1:1\n");
       break;
 
     case 0xe7: // Set Mouse Scaling to 2:1
       controller_enQ(0xFA, 1); // ACK
       BX_KEY_THIS s.mouse.scaling         = 2;
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Scaling set to 2:1\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Scaling set to 2:1\n");
       break;
 
     case 0xe8: // Set Mouse Resolution
@@ -1217,8 +1232,8 @@ bx_printf("  aux_clock_enabled = %u\n",
     case 0xf2: // Read Device Type
       controller_enQ(0xFA, 1); // ACK
       controller_enQ(0x00, 1); // Device ID
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Read mouse ID\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Read mouse ID\n");
       break;
 
     case 0xf3: // Set Mouse Sample Rate (sample rate written to port 60h)
@@ -1229,15 +1244,15 @@ bx_printf("  aux_clock_enabled = %u\n",
     case 0xf4: // Enable (in stream mode)
       BX_KEY_THIS s.mouse.enable = 1;
       controller_enQ(0xFA, 1); // ACK
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Mouse enabled (stream mode)\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Mouse enabled (stream mode)\n");
       break;
 
     case 0xf5: // Disable (in stream mode)
       BX_KEY_THIS s.mouse.enable = 0;
       controller_enQ(0xFA, 1); // ACK
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Mouse disabled (stream mode)\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Mouse disabled (stream mode)\n");
       break;
 
     case 0xff: // Reset
@@ -1250,8 +1265,8 @@ bx_printf("  aux_clock_enabled = %u\n",
       controller_enQ(0xFA, 1); // ACK
       controller_enQ(0xAA, 1); // completion code
       controller_enQ(0x00, 1); // ID code (normal mouse, wheelmouse has id 0x3)
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Mouse reset\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Mouse reset\n");
       break;
 
     case 0xe9: // Get mouse information
@@ -1260,12 +1275,12 @@ bx_printf("  aux_clock_enabled = %u\n",
       controller_enQ(BX_KEY_THIS s.mouse.get_status_byte(), 1); // status
       controller_enQ(BX_KEY_THIS s.mouse.get_resolution_byte(), 1); // resolution
       controller_enQ(BX_KEY_THIS s.mouse.sample_rate, 1); // sample rate
-      if (bx_dbg.mouse)
-	    bx_printf("[mouse] Get mouse information\n");
+      if (bio->getdbg().mouse)
+	    bio->printf("[mouse] Get mouse information\n");
       break;
 
     default:
-      bx_panic("MOUSE: kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
+      bio->printf("[MOUSE] kbd_ctrl_to_mouse(%02xh)\n", (unsigned) value);
     }
  }
 }
@@ -1289,7 +1304,7 @@ bx_keyb_c::mouse_motion(int delta_x, int
   if ( (delta_y < -1) || (delta_y > 1) )
     delta_y /= 2;
 
-  //fprintf(stderr, "# MOUSE: Dx=%d Dy=%d\n",
+  //bio->printf("#MOUSE] Dx=%d Dy=%d\n",
   //  delta_x, delta_y);
 
   b1 = (button_state & 0x0f) | 0x08; // bit3 always set
