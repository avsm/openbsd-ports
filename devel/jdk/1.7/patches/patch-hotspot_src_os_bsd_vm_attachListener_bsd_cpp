$OpenBSD: patch-hotspot_src_os_bsd_vm_attachListener_bsd_cpp,v 1.3 2009/05/23 03:03:24 kurt Exp $
--- hotspot/src/os/bsd/vm/attachListener_bsd.cpp.orig	Fri May 15 16:25:27 2009
+++ hotspot/src/os/bsd/vm/attachListener_bsd.cpp	Fri May 15 17:25:06 2009
@@ -179,32 +179,19 @@ int BsdAttachListener::init() {
   struct sockaddr_un addr;
   addr.sun_family = AF_UNIX;
 
-  // FIXME: Prior to b39 the tool-side API expected to find the well
-  // known file in the working directory. To allow this libjvm.so work with
-  // a pre-b39 SDK we create it in the working directory if
-  // +StartAttachListener is used is used. All unit tests for this feature
-  // currently used this flag. Once b39 SDK has been promoted we can remove
-  // this code.
-  if (StartAttachListener) {
-    sprintf(path, ".java_pid%d", os::current_process_id());
-    strcpy(addr.sun_path, path);
-    ::unlink(path);
-    res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
-  }
+  sprintf(path, "%s/.java_pid%d", os::get_temp_directory(), os::current_process_id());
+  strcpy(addr.sun_path, path);
+  ::unlink(path);
+  res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
   if (res == -1) {
-    sprintf(path, "%s/.java_pid%d", os::get_temp_directory(), os::current_process_id());
-    strcpy(addr.sun_path, path);
-    ::unlink(path);
-    res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
-  }
-  if (res == -1) {
     RESTARTABLE(::close(listener), res);
     return -1;
   }
   set_path(path);
 
-  // put in listen mode and set permission
-  if ((::listen(listener, 5) == -1) || (::chmod(path, S_IREAD|S_IWRITE) == -1)) {
+  // put in listen mode and set permission and ownership
+  if ((::listen(listener, 5) == -1) || (::chmod(path, S_IREAD|S_IWRITE) == -1) ||
+      (::chown(path, geteuid(), getegid()) == -1)) {
     RESTARTABLE(::close(listener), res);
     ::unlink(path);
     set_path(NULL);
@@ -330,6 +317,15 @@ BsdAttachOperation* BsdAttachListener::dequeue() {
 
     // get the credentials of the peer and check the effective uid/guid
     // - check with jeff on this.
+#ifdef _ALLBSD_SOURCE
+    uid_t puid;
+    gid_t pgid;
+    if (::getpeereid(s, &puid, &pgid) != 0) {
+      int res;
+      RESTARTABLE(::close(s), res);
+      continue;
+    }
+#else
     struct ucred cred_info;
     socklen_t optlen = sizeof(cred_info);
     if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
@@ -337,10 +333,13 @@ BsdAttachOperation* BsdAttachListener::dequeue() {
       RESTARTABLE(::close(s), res);
       continue;
     }
+    uid_t puid = cred_info.uid;
+    gid_t pgid = cred_info.gid;
+#endif
     uid_t euid = geteuid();
     gid_t egid = getegid();
 
-    if (cred_info.uid != euid || cred_info.gid != egid) {
+    if (puid != euid || pgid != egid) {
       int res;
       RESTARTABLE(::close(s), res);
       continue;
@@ -460,15 +459,12 @@ bool AttachListener::is_init_trigger() {
   if (init_at_startup() || is_initialized()) {
     return false;               // initialized at startup or already initialized
   }
-  char fn[32];
-  sprintf(fn, ".attach_pid%d", os::current_process_id());
+  char path[PATH_MAX + 1];
   int ret;
-  struct stat64 st;
-  RESTARTABLE(::stat64(fn, &st), ret);
-  if (ret == -1) {
-    sprintf(fn, "/tmp/.attach_pid%d", os::current_process_id());
-    RESTARTABLE(::stat64(fn, &st), ret);
-  }
+  struct stat st;
+
+  sprintf(path, "%s/.attach_pid%d", os::get_temp_directory(), os::current_process_id());
+  RESTARTABLE(::stat(path, &st), ret);
   if (ret == 0) {
     // simple check to avoid starting the attach mechanism when
     // a bogus user creates the file
