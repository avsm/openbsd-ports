--- cs/csparse.c.orig	Wed Jul 11 22:37:34 2007
+++ cs/csparse.c	Sun Nov  9 16:28:06 2008
@@ -1948,6 +1948,7 @@ static NEOERR *eval_expr_string(CSPARSE *parse, CSARG 
 {
   char *s1, *s2;
   int out;
+  size_t need;
 
   result->op_type = CS_TYPE_NUM;
   s1 = arg_eval (parse, arg1);
@@ -2022,11 +2023,12 @@ static NEOERR *eval_expr_string(CSPARSE *parse, CSARG 
       case CS_OP_ADD:
 	result->op_type = CS_TYPE_STRING;
 	result->alloc = 1;
-	result->s = (char *) calloc ((strlen(s1) + strlen(s2) + 1), sizeof(char));
+	need = strlen(s1) + strlen(s2) + 1;
+	result->s = (char *) calloc (need, sizeof(char));
 	if (result->s == NULL)
 	  return nerr_raise (NERR_NOMEM, "Unable to allocate memory to concatenate strings in expression: %s + %s", s1, s2);
-	strcpy(result->s, s1);
-	strcat(result->s, s2);
+	strlcpy(result->s, s1, need);
+	strlcat(result->s, s2, need);
 	break;
       default:
 	ne_warn ("Unsupported op %s in eval_expr_string", expand_token_type(op, 1));
@@ -3717,7 +3719,7 @@ static NEOERR * _builtin_str_crc(CSPARSE *parse, CS_FU
   if (val.op_type & (CS_TYPE_VAR | CS_TYPE_STRING))
   {
     char *s = arg_eval(parse, &val);
-    if (s) result->n = ne_crc((unsigned char *)s, strlen(s));
+    if (s) result->n = (INT32) ne_crc((unsigned char *)s, strlen(s));
   }
   if (val.alloc) free(val.s);
   return STATUS_OK;
