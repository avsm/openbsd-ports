$OpenBSD: patch-src_sysdeps_openbsd_c,v 1.11 2008/09/02 11:28:05 landry Exp $
--- src/sysdeps/openbsd.c.orig	Fri Jul  6 16:54:22 2007
+++ src/sysdeps/openbsd.c	Sat Jul 12 09:14:03 2008
@@ -53,41 +53,71 @@ gkrellm_sys_main_cleanup(void)
 #include <sys/dkstat.h>
 #include <kvm.h>
 
-extern	kvm_t	*kvmd;
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/sched.h>
 
+static gint ncpus;
+
+static gint get_ncpus(void);
+
 void
 gkrellm_sys_cpu_read_data(void)
 	{
-	long		cp_time[CPUSTATES];
-	static struct nlist nl[] = {
-#define N_CP_TIME	0
-		{ "_cp_time" },
-		{ "" }
-	};
+	int64_t	cp_time[ncpus][CPUSTATES];
+	size_t size;
+	int i;
 
+	size = sizeof(cp_time[0]);
+	if (ncpus > 1) {
+		for (i = 0; i < ncpus; i++) {
+			int cp_time_mib[] = {CTL_KERN, KERN_CPTIME2, i};
 
-	if (kvmd == NULL)
-		return;
-	if (nl[0].n_type == 0)
-		if (kvm_nlist(kvmd, nl) < 0 || nl[0].n_type == 0)
+			if (sysctl(cp_time_mib, 3, cp_time[i], &size, NULL, 0)
+			    < 0)
+				continue;
+
+			gkrellm_cpu_assign_data(i, cp_time[i][CP_USER],
+			    cp_time[i][CP_NICE], cp_time[i][CP_SYS],
+			    cp_time[i][CP_IDLE]);
+		}
+	} else {
+		int cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
+		long cp_time_tmp[CPUSTATES];
+
+		if (sysctl(cp_time_mib, 2, cp_time_tmp, &size, NULL, 0) < 0)
 			return;
-	if (kvm_read(kvmd, nl[N_CP_TIME].n_value,
-		     (char *)&cp_time, sizeof(cp_time)) != sizeof(cp_time))
-		return;
+		for (i = 0; i < CPUSTATES; i++)
+			cp_time[0][i] = cp_time_tmp[i];
 
-	/* Currently, SMP is not supported */
-	gkrellm_cpu_assign_data(0, cp_time[CP_USER], cp_time[CP_NICE],
-				cp_time[CP_SYS], cp_time[CP_IDLE]);
+		gkrellm_cpu_assign_data(0, cp_time[0][CP_USER],
+		    cp_time[0][CP_NICE], cp_time[0][CP_SYS],
+		    cp_time[0][CP_IDLE]);
+
 	}
+}
 
 gboolean
 gkrellm_sys_cpu_init(void)
-    {
-	gkrellm_cpu_set_number_of_cpus(1);
+{
+	ncpus = get_ncpus();
+	gkrellm_cpu_set_number_of_cpus(ncpus);
 	return TRUE;
-	}
+}
 
+static gint
+get_ncpus(void)
+{
+	static int mib[] = { CTL_HW, HW_NCPU };
+	int ncpus;
+	size_t size = sizeof(int);
 
+	if (sysctl(mib, 2, &ncpus, &size, NULL, 0) < 0)
+		return 1;
+	else
+		return ncpus;
+}
+
 /* ===================================================================== */
 /* Proc monitor interface */
 
@@ -259,41 +289,122 @@ gkrellm_sys_mem_init(void)
 
 
 /* ===================================================================== */
-/* Sensor monitor interface - not implemented */
+/* Sensor monitor interface */
 
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <sys/sensors.h>
+#include <errno.h>
+
+static gboolean
+get_sensor(int dev, int type, int num, gfloat *val)
+{
+	int mib[5] = { CTL_HW, HW_SENSORS };
+	struct sensor sen;
+	size_t len = sizeof(sen);
+
+	mib[2] = dev;
+	mib[3] = type;
+	mib[4] = num;
+	if (sysctl(mib, 5, &sen, &len, NULL, 0) == -1 ||
+	    (SENSOR_FINVALID|SENSOR_FUNKNOWN) & sen.flags)
+		return FALSE;
+
+	*val = (gfloat)sen.value;
+	return TRUE;
+}
+
 gboolean
 gkrellm_sys_sensors_get_temperature(gchar *device_name, gint id,
 		gint iodev, gint interface, gfloat *temp)
-	{
-	return FALSE;
-	}
+{
+	return get_sensor(id, iodev, interface, temp);
+}
 
 gboolean
 gkrellm_sys_sensors_get_fan(gchar *device_name, gint id,
 		gint iodev, gint interface, gfloat *fan)
-	{
-	return FALSE;
-	}
+{
+	return get_sensor(id, iodev, interface, fan);
+}
 
 gboolean
 gkrellm_sys_sensors_get_voltage(gchar *device_name, gint id,
 		gint iodev, gint interface, gfloat *volt)
-	{
-	return FALSE;
+{
+	return get_sensor(id, iodev, interface, volt);
+}
+
+static gboolean
+add_sensdev(int dev, struct sensordev *sensdev)
+{
+	static enum sensor_type stypes[] =
+		{ SENSOR_TEMP, SENSOR_FANRPM, SENSOR_VOLTS_DC };
+	static gint gtypes[] =
+		{ SENSOR_TEMPERATURE, SENSOR_FAN, SENSOR_VOLTAGE };
+	static gfloat fac[] = { 0.000001, 1.0, 0.000001 };
+	static gfloat off[] = { -273.15, 0.0, 0.0 };
+	char name[32];
+	int mib[5] = { CTL_HW, HW_SENSORS };
+	struct sensor sen;
+	size_t len = sizeof(sen);
+	int idx, num;
+	gboolean found = FALSE;
+
+	mib[2] = dev;
+	for (idx = 0; sizeof(stypes) / sizeof(stypes[0]) > idx; idx++) {
+		mib[3] = stypes[idx];
+		for (num = 0; sensdev->maxnumt[stypes[idx]] > num; num++) {
+			mib[4] = num;
+			len = sizeof(sen);
+			if (sysctl(mib, 5, &sen, &len, NULL, 0) == -1) {
+				if (ENOENT != errno)
+					return FALSE;
+				continue;
+			}
+			if (SENSOR_FINVALID & sen.flags)
+				continue;
+			snprintf(name, sizeof(name), "%s.%s%d", sensdev->xname,
+			    sensor_type_s[stypes[idx]], num);
+			gkrellm_sensors_add_sensor(gtypes[idx], NULL, name,
+			    sensdev->num, stypes[idx], num, fac[idx],
+			    off[idx], NULL, (sen.desc[0] ? sen.desc : NULL));
+			found = TRUE;
+		}
 	}
 
+	return found;
+}
+
 gboolean
 gkrellm_sys_sensors_init(void)
-	{
-	return FALSE;
+{
+	int mib[3] = { CTL_HW, HW_SENSORS };
+	struct sensordev sensdev;
+	size_t len = sizeof(sensdev);
+	int dev;
+	gboolean found = FALSE;
+
+	for (dev = 0; MAXSENSORDEVICES > dev; dev++) {
+		mib[2] = dev;
+		if (sysctl(mib, 3, &sensdev, &len, NULL, 0) == -1) {
+			if (ENOENT != errno)
+				return FALSE;
+			continue;
+		}
+		if (add_sensdev(dev, &sensdev))
+			found = TRUE;
 	}
 
+	return found;
+}
 
+
 /* ===================================================================== */
 /* Battery monitor interface */
 #include <sys/ioctl.h>
 
-#if defined(__i386__) || defined(__powerpc__)
+#if defined(__i386__) || defined(__macppc__) || defined(__amd64__) || defined(__arm__) || defined(__sparc__) || defined(__sparc64__)
 
 #include <machine/apmvar.h>
 #define	APMDEV		"/dev/apm"
@@ -405,7 +516,7 @@ gkrellm_sys_disk_read_data(void)
 		/* Separate read/write stats were implemented in NetBSD 1.6K.
 		*/
 
-#if __NetBSD_Version__ >= 106110000
+#if __NetBSD_Version__ >= 106110000 || defined(__OpenBSD__)
 		rbytes = d.dk_rbytes;
 		wbytes = d.dk_wbytes;
 #else
@@ -413,7 +524,7 @@ gkrellm_sys_disk_read_data(void)
 		wbytes = 0;
 #endif
 
-		gkrellm_disk_assign_data_by_name(buf, rbytes, wbytes);
+		gkrellm_disk_assign_data_by_name(buf, rbytes, wbytes, FALSE);
 		}
 	}
 }
