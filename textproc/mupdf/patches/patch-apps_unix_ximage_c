$OpenBSD: patch-apps_unix_ximage_c,v 1.1 2009/07/14 19:20:41 sthen Exp $

trap SHM errors and fall back to !SHM, letting mupdf work with
a remote DISPLAY.

--- apps/unix/ximage.c.orig	Tue Jul  7 19:08:22 2009
+++ apps/unix/ximage.c	Tue Jul 14 18:48:01 2009
@@ -81,6 +81,7 @@ static struct
 	ximage_convert_func_t convert_func;
 
 	int useshm;
+	int shmopcode;
 	XImage *pool[POOLSIZE];
 	/* MUST exist during the lifetime of the shared ximage according to the
 	   xc/doc/hardcopy/Xext/mit-shm.PS.gz */
@@ -295,6 +296,18 @@ next_pool_image(void)
 	return info.pool[info.lastused ++];
 }
 
+static int
+ximage_error_handler(Display *dpy, XErrorEvent *event)
+{
+	if (event->request_code == info.shmopcode) {
+		info.useshm = 0;
+		return 0;
+	}
+
+	XSetErrorHandler(NULL);
+	return (XSetErrorHandler(ximage_error_handler))(dpy, event);
+}
+
 int
 ximage_init(Display *display, int screen, Visual *visual)
 {
@@ -305,6 +318,9 @@ ximage_init(Display *display, int screen, Visual *visu
 	int nformats;
 	int ok;
 	int i;
+	int major;
+	int event;
+	int error;
 
 	info.display = display;
 	info.screen = screen;
@@ -340,6 +356,14 @@ ximage_init(Display *display, int screen, Visual *visu
 
 	/* prepare colormap */
 	make_colormap();
+
+	/* identify opcode for MIT-SHM extension */
+	if(XQueryExtension(display, "MIT-SHM", &major, &event, &error )
+	    && XShmQueryExtension(display))
+		info.shmopcode = major;
+
+	/* intercept non-fatal errors */
+	XSetErrorHandler(ximage_error_handler);
 
 	/* prepare pool of XImages */
 	info.useshm = 1;
