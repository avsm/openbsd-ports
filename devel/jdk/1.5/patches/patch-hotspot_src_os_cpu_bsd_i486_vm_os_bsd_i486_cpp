$OpenBSD: patch-hotspot_src_os_cpu_bsd_i486_vm_os_bsd_i486_cpp,v 1.1.1.1 2005/05/25 17:27:53 kurt Exp $
--- hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp.orig	Tue Jan 25 22:14:33 2005
+++ hotspot/src/os_cpu/bsd_i486/vm/os_bsd_i486.cpp	Tue Jan 25 22:16:08 2005
@@ -28,19 +28,48 @@
 # include <pwd.h>
 # include <poll.h>
 
+# ifdef __FreeBSD__
+#  define context_eip uc_mcontext.mc_eip
+#  define context_esp uc_mcontext.mc_esp
+#  define context_eax uc_mcontext.mc_eax
+#  define context_ebx uc_mcontext.mc_ebx
+#  define context_ecx uc_mcontext.mc_ecx
+#  define context_edx uc_mcontext.mc_edx
+#  define context_ebp uc_mcontext.mc_ebp
+#  define context_esi uc_mcontext.mc_esi
+#  define context_edi uc_mcontext.mc_edi
+#  define context_eflags uc_mcontext.mc_eflags
+#  define context_trapno uc_mcontext.mc_trapno
+# endif
+
 # ifdef __NetBSD__
-#  define mc_eip __gregs[_REG_EIP]
-#  define mc_esp __gregs[_REG_UESP]
-#  define mc_eax __gregs[_REG_EAX]
-#  define mc_ebx __gregs[_REG_EBX]
-#  define mc_ecx __gregs[_REG_ECX]
-#  define mc_edx __gregs[_REG_EDX]
-#  define mc_ebp __gregs[_REG_EBP]
-#  define mc_esi __gregs[_REG_ESI]
-#  define mc_edi __gregs[_REG_EDI]
-#  define mc_eflags __gregs[_REG_EFL]
+#  define context_eip uc_mcontext.__gregs[_REG_EIP]
+#  define context_esp uc_mcontext.__gregs[_REG_UESP]
+#  define context_eax uc_mcontext.__gregs[_REG_EAX]
+#  define context_ebx uc_mcontext.__gregs[_REG_EBX]
+#  define context_ecx uc_mcontext.__gregs[_REG_ECX]
+#  define context_edx uc_mcontext.__gregs[_REG_EDX]
+#  define context_ebp uc_mcontext.__gregs[_REG_EBP]
+#  define context_esi uc_mcontext.__gregs[_REG_ESI]
+#  define context_edi uc_mcontext.__gregs[_REG_EDI]
+#  define context_eflags uc_mcontext.__gregs[_REG_EFL]
+#  define context_trapno uc_mcontext.mc_trapno
 # endif
 
+# ifdef __OpenBSD__
+#  define context_eip sc_eip
+#  define context_esp sc_esp
+#  define context_eax sc_eax
+#  define context_ebx sc_ebx
+#  define context_ecx sc_ecx
+#  define context_edx sc_edx
+#  define context_ebp sc_ebp
+#  define context_esi sc_esi
+#  define context_edi sc_edi
+#  define context_eflags sc_eflags
+#  define context_trapno sc_trapno
+# endif
+
 // Minimum stack size for the VM.  It's easier to document a constant value
 // but it's different for x86 and sparc because the page sizes are different.
 size_t os::Bsd::min_stack_allowed = 64*K;
@@ -59,6 +88,8 @@ char* os::non_memory_address_word() {
 // There are issues with libthread giving out uc_links for different threads
 // on the same uc_link chain and bad or circular links. 
 //
+// OpenBSD dosn't have a uc_link so can't do this check
+#ifndef __OpenBSD__
 bool os::Bsd::valid_ucontext(Thread* thread, ucontext_t* valid, ucontext_t* suspect) {
   if (valid >= suspect || 
       valid->uc_stack.ss_flags != suspect->uc_stack.ss_flags ||
@@ -73,7 +104,7 @@ bool os::Bsd::valid_ucontext(Thread* thr
       DEBUG_ONLY(tty->print_cr("valid_ucontext: uc_link not in thread stack");)
       return false;
     }
-    if (!valid_stack_address(thread,  (address) suspect->uc_mcontext.mc_esp)) {
+    if (!valid_stack_address(thread,  (address) suspect->context_esp)) {
       DEBUG_ONLY(tty->print_cr("valid_ucontext: stackpointer not in thread stack");)
       return false;
     }
@@ -107,20 +138,21 @@ ucontext_t* os::Bsd::get_valid_uc_in_sig
   }
   return retuc;
 }
+#endif // !__OpenBSD__
 
 // Assumes ucontext is valid
 ExtendedPC os::Bsd::ucontext_get_ExtendedPC(ucontext_t *uc) {
-  return ExtendedPC((address)uc->uc_mcontext.mc_eip);
+  return ExtendedPC((address)uc->context_eip);
 }
 
 // Assumes ucontext is valid
 intptr_t* os::Bsd::ucontext_get_sp(ucontext_t *uc) {
-  return (intptr_t*)uc->uc_mcontext.mc_esp;
+  return (intptr_t*)uc->context_esp;
 }
 
 // Assumes ucontext is valid
 intptr_t* os::Bsd::ucontext_get_fp(ucontext_t *uc) {
-  return (intptr_t*)uc->uc_mcontext.mc_ebp;
+  return (intptr_t*)uc->context_ebp;
 }
 
 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
@@ -135,8 +167,12 @@ ExtendedPC os::Bsd::fetch_frame_from_uco
   assert(ret_sp != NULL, "just checking");
   assert(ret_fp != NULL, "just checking");
 
+#ifdef __OpenBSD__
+  return os::fetch_frame_from_context(uc, ret_sp, ret_fp);
+#else
   ucontext_t *luc = os::Bsd::get_valid_uc_in_signal_handler(thread, uc);
   return os::fetch_frame_from_context(luc, ret_sp, ret_fp);
+#endif
 }
 
 ExtendedPC os::fetch_frame_from_context(void* ucVoid, 
@@ -202,25 +238,33 @@ void SetThreadPC_Callback::execute(OSThr
   // success, if not we return failure and the caller can retry.
   // 
   _result = false;
-  if (uc->uc_mcontext.mc_eip == (int)_old_addr.pc() ) {
-    uc->uc_mcontext.mc_eip = (int)_new_addr.pc();
+  if (uc->context_eip == (int)_old_addr.pc() ) {
+    uc->context_eip = (int)_new_addr.pc();
     _result = true;
+#ifndef __OpenBSD__
   } else if (uc->uc_link != NULL) {
     // Check (and validate) one level of stacked ucontext
     ucontext_t* linked_uc = uc->uc_link;
-    if (os::Bsd::valid_ucontext(thread, uc, linked_uc) && linked_uc->uc_mcontext.mc_eip == (int)_old_addr.pc()) {
-      linked_uc->uc_mcontext.mc_eip = (int)_new_addr.pc();
+    if (os::Bsd::valid_ucontext(thread, uc, linked_uc) && linked_uc->context_eip == (int)_old_addr.pc()) {
+      linked_uc->context_eip = (int)_new_addr.pc();
       _result = true;
     }
   }
+#else
+  }
+#endif
 
   thread->safepoint_state()->notify_set_thread_pc_result(_result);
 
 #ifdef ASSERT
   if (!_result) { 
+#ifndef __OpenBSD__
     if (uc->uc_link != NULL) { 
       tty->print_cr("set_thread_pc:(nested) failed to set pc " INTPTR_FORMAT " -> " INTPTR_FORMAT, _old_addr.pc(), _new_addr.pc()); 
     } else { 
+#else
+    {
+#endif
       tty->print_cr("set_thread_pc: failed to set pc " INTPTR_FORMAT " -> " INTPTR_FORMAT, _old_addr.pc(), _new_addr.pc()); 
     } 
   } 
@@ -241,7 +285,7 @@ void GetThreadPC_Callback::execute(OSThr
 
   assert(ProfileVM && thread->is_VM_thread(), "just checking");
     
-  ExtendedPC new_addr((address)uc->uc_mcontext.mc_eip);
+  ExtendedPC new_addr((address)uc->context_eip);
   _addr = new_addr;
 }
 
@@ -326,7 +370,7 @@ int JVM_handle_bsd_signal(int sig, sigin
 
   if (sig == SIGILL && info->si_addr == (caddr_t)sse_check) {
     // the SSE instruction faulted. supports_sse() need return false.
-    uc->uc_mcontext.mc_eip = (int)sse_unavailable;
+    uc->context_eip = (int)sse_unavailable;
     return true;
   }
 
@@ -380,7 +424,7 @@ int JVM_handle_bsd_signal(int sig, sigin
   //%note os_trap_1
   if (info != NULL && thread != NULL) {
     // factor me: getPCfromContext
-    pc = (address) uc->uc_mcontext.mc_eip;
+    pc = (address) uc->context_eip;
     #ifndef CORE
     adjusted_pc = SafepointPolling ? pc : thread->safepoint_state()->compute_adjusted_pc(pc);
     #else
@@ -595,10 +639,10 @@ int JVM_handle_bsd_signal(int sig, sigin
   // Furthermore, a false-positive should be harmless.
   if (UnguardOnExecutionViolation > 0 &&
       (sig == SIGSEGV || sig == SIGBUS) &&
-      uc->uc_mcontext.mc_trapno == T_PAGEFLT) {  // page fault
+      uc->context_trapno == T_PAGEFLT) {  // page fault
     int page_size = os::vm_page_size();
     address addr = (address) info->si_addr;
-    address pc = (address) uc->uc_mcontext.mc_eip;
+    address pc = (address) uc->context_eip;
     // Make sure the pc and the faulting address are sane.
     //
     // If an instruction spans a page boundary, and the page containing
@@ -667,7 +711,7 @@ int JVM_handle_bsd_signal(int sig, sigin
     // 12/02/99: On Sparc it appears that the full context is alsosaved
     // but as yet, no one looks at or restores that saved context
     // factor me: setPC
-    uc->uc_mcontext.mc_eip = (int)stub;
+    uc->context_eip = (int)stub;
     return true;
   }
 
@@ -676,7 +720,7 @@ int JVM_handle_bsd_signal(int sig, sigin
   if (sig == SIGSEGV || sig == SIGBUS) {
     address addr = JNI_FastGetField::find_slowcase_pc(pc);
     if (addr != (address)-1) {
-      uc->uc_mcontext.mc_eip = (int)addr;
+      uc->context_eip = (int)addr;
       return true;
     }
   }
@@ -723,7 +767,7 @@ int JVM_handle_bsd_signal(int sig, sigin
   }
 
   if (pc == NULL && uc != NULL) {
-    pc = (address) uc->uc_mcontext.mc_eip;
+    pc = (address) uc->context_eip;
   }
 
   // unmask current signal
@@ -743,18 +787,18 @@ void os::print_context(outputStream *st,
 
   ucontext_t *uc = (ucontext_t*)context;
   st->print_cr("Registers:");
-  st->print(  "EAX=" INTPTR_FORMAT, uc->uc_mcontext.mc_eax);
-  st->print(", EBX=" INTPTR_FORMAT, uc->uc_mcontext.mc_ebx);
-  st->print(", ECX=" INTPTR_FORMAT, uc->uc_mcontext.mc_ecx);
-  st->print(", EDX=" INTPTR_FORMAT, uc->uc_mcontext.mc_edx);
+  st->print(  "EAX=" INTPTR_FORMAT, uc->context_eax);
+  st->print(", EBX=" INTPTR_FORMAT, uc->context_ebx);
+  st->print(", ECX=" INTPTR_FORMAT, uc->context_ecx);
+  st->print(", EDX=" INTPTR_FORMAT, uc->context_edx);
   st->cr();
-  st->print(  "ESP=" INTPTR_FORMAT, uc->uc_mcontext.mc_esp);
-  st->print(", EBP=" INTPTR_FORMAT, uc->uc_mcontext.mc_ebp);
-  st->print(", ESI=" INTPTR_FORMAT, uc->uc_mcontext.mc_esi);
-  st->print(", EDI=" INTPTR_FORMAT, uc->uc_mcontext.mc_edi);
+  st->print(  "ESP=" INTPTR_FORMAT, uc->context_esp);
+  st->print(", EBP=" INTPTR_FORMAT, uc->context_ebp);
+  st->print(", ESI=" INTPTR_FORMAT, uc->context_esi);
+  st->print(", EDI=" INTPTR_FORMAT, uc->context_edi);
   st->cr();
-  st->print(  "EIP=" INTPTR_FORMAT, uc->uc_mcontext.mc_eip);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.mc_eflags);
+  st->print(  "EIP=" INTPTR_FORMAT, uc->context_eip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_eflags);
   st->cr();
   st->cr();
 
