.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "POE::Filter::XML 3"
.TH POE::Filter::XML 3 "2007-01-02" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
POE::Filter::XML \- A POE Filter for parsing XML
.SH "SYSNOPSIS"
.IX Header "SYSNOPSIS"
.Vb 2
\& use POE::Filter::XML;
\& my $filter = POE::Filter::XML->new();
.Ve
.PP
.Vb 4
\& my $wheel = POE::Wheel:ReadWrite->new(
\&        Filter          => $filter,
\&        InputEvent      => 'input_event',
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
POE::Filter::XML provides \s-1POE\s0 with a completely encapsulated \s-1XML\s0 parsing 
strategy for POE::Wheels that will be dealing with \s-1XML\s0 streams.
.PP
POE::Filter::XML relies upon \s-1XML::SAX\s0 and XML::SAX::ParserFactory to acquire
a parser for parsing \s-1XML\s0. 
.PP
The assumed parser is XML::SAX::Expat::Incremental (Need a real push parser)
.PP
Default, the Filter will spit out POE::Filter::XML::Nodes because that is 
what the default \s-1XML::SAX\s0 compliant Handler produces from the stream it is 
given. You are of course encouraged to override the default Handler for your 
own purposes if you feel POE::Filter::XML::Node to be inadequate.
.PP
Also, Filter requires POE::Filter::XML::Nodes for \fIput()\fR. If you are wanting to
send raw \s-1XML\s0, it is recommened that you subclass the Filter and override \fIput()\fR
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
Since POE::Filter::XML follows the POE::Filter \s-1API\s0 look to POE::Filter for 
documentation. Deviations from Filter \s-1API\s0 will be covered here.
.IP "\fInew()\fR" 4
.IX Item "new()"
\&\fInew()\fR accepts a total of \fIthree\fR\|(3) arguments that are all optional: (1) a string
that is \s-1XML\s0 waiting to be parsed (i.e. xml received from the wheel before the
Filter was instantiated), (2) a coderef to be executed upon a parsing error,
(3) and a \s-1XML::SAX\s0 compliant Handler. 
.Sp
If no options are specified, then a default coderef containing a simple
Carp::confess is generated, and a new instance of POE::Filter::XML::Handler is 
used.
.IP "\fIreset()\fR" 4
.IX Item "reset()"
\&\fIreset()\fR is an internal method that gets called when either a \fIstream_start\fR\|(1)
POE::Filter::XML::Node gets placed into the filter via \fIput()\fR, or when a
\&\fIstream_end\fR\|(1) POE::Filter::XML::Node is pulled out of the queue of finished
Nodes via \fIget_one()\fR. This facilitates automagical behavior when using the 
Filter within the \s-1XMPP\s0 protocol that requires a many new stream initiations.
This method really should never be called outside of the Filter, but it is 
documented here in case the Filter is used outside of the \s-1POE\s0 context.
.Sp
Internally \fIreset()\fR gets another parser, calls \fIreset()\fR on the stored handler
and then deletes any data in the buffer.
.SH "BUGS AND NOTES"
.IX Header "BUGS AND NOTES"
The current XML::SAX::Expat::Incremental version introduces some ugly circular
references due to the way XML::SAX::Expat constructs itself (it stores a 
references to itself inside the XML::Parser object it constructs to get an
OO-like interface within the callbacks passed to it). Upon destroy, I clean
these up with Scalar::Util::weaken and by manually calling \fIrelease()\fR on the
ExpatNB object created within XML::SAX::Expat::Incremental. This is an ugly
hack. If anyone finds some subtle behavior I missed, let me know and I will
drop \s-1XML::SAX\s0 support all together going back to just plain-old XML::Parser.
.PP
Meta filtering was removed. No one was using it and the increased level of
indirection was a posible source of performance issues.
.PP
\&\fIput()\fR now requires POE::Filter::XML::Nodes. Raw \s-1XML\s0 text can no longer be
\&\fIput()\fR into the stream without subclassing the Filter and overriding \fIput()\fR.
.PP
\&\fIreset()\fR semantics were properly worked out to now be automagical and
consistent. Thanks Eric Waters (ewaters@uarc.com).
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (c) 2003 \- 2006 Nicholas Perez. 
Released and distributed under the \s-1GPL\s0.
