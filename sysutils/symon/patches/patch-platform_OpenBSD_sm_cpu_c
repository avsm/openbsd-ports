$OpenBSD: patch-platform_OpenBSD_sm_cpu_c,v 1.2 2007/05/18 12:07:37 henning Exp $
--- platform/OpenBSD/sm_cpu.c.orig	Sun Feb 11 21:09:35 2007
+++ platform/OpenBSD/sm_cpu.c	Wed May 16 13:00:53 2007
@@ -67,11 +67,6 @@
 
 #include "error.h"
 #include "symon.h"
-
-
-/* Globals for this module all start with cp_ */
-static size_t cp_size;
-
 /*
  *  percentages(cnt, out, new, old, diffs) - calculate percentage change
  *      between array "old" and "new", putting the percentages i "out".
@@ -80,84 +75,83 @@ static size_t cp_size;
  *      The routine assumes modulo arithmetic.  This function is especially
  *      useful on BSD mchines for calculating cpu state percentages.
  */
-#ifdef HAS_KERN_CPTIME2
 int
 percentages(int cnt, int64_t *out, int64_t *new, int64_t *old, int64_t *diffs)
 {
-        int64_t change, total_change, *dp, half_total;
-#else
-static int cp_time_mib[] = {CTL_KERN, KERN_CPTIME};
-int
-percentages(int cnt, int *out, register long *new, register long *old, long *diffs)
-{
-        long change, total_change, *dp, half_total;
-#endif
-        int i;
+    int64_t change, total_change, *dp, half_total;
+    int i;
 
+    /* initialization */
+    total_change = 0;
+    dp = diffs;
 
-        /* initialization */
-        total_change = 0;
-        dp = diffs;
-
-        /* calculate changes for each state and the overall change */
-        for (i = 0; i < cnt; i++) {
-                if ((change = *new - *old) < 0) {
-                        /* this only happens when the counter wraps */
-                        change = (*new - *old);
-                }
-                total_change += (*dp++ = change);
-                *old++ = *new++;
+    /* calculate changes for each state and the overall change */
+    for (i = 0; i < cnt; i++) {
+        if ((change = *new - *old) < 0) {
+            /* this only happens when the counter wraps */
+            change = (*new - *old);
         }
+        total_change += (*dp++ = change);
+        *old++ = *new++;
+    }
 
-        /* avoid divide by zero potential */
-        if (total_change == 0)
-                total_change = 1;
+    /* avoid divide by zero potential */
+    if (total_change == 0)
+        total_change = 1;
 
-        /* calculate percentages based on overall change, rounding up */
-        half_total = total_change / 2l;
-        for (i = 0; i < cnt; i++)
-                *out++ = ((*diffs++ * 1000 + half_total) / total_change);
+    /* calculate percentages based on overall change, rounding up */
+    half_total = total_change / 2l;
+    for (i = 0; i < cnt; i++)
+        *out++ = ((*diffs++ * 1000 + half_total) / total_change);
 
-        /* return the total in case the caller wants to use it */
-        return (total_change);
+    /* return the total in case the caller wants to use it */
+    return (total_change);
 }
 
 void
 init_cpu(struct stream *st)
 {
     char buf[SYMON_MAX_OBJSIZE];
-
 #ifdef HAS_KERN_CPTIME2
     const char *errstr;
     int mib[2] = {CTL_HW, HW_NCPU};
     int ncpu;
     long num;
-
     size_t size = sizeof(ncpu);
+#endif
+
+    st->parg.cp.mib[0] = CTL_KERN;
+    st->parg.cp.mib[1] = KERN_CPTIME;
+    st->parg.cp.miblen = 2;
+
+#ifdef HAS_KERN_CPTIME2
     if (sysctl(mib, 2, &ncpu, &size, NULL, 0) == -1) {
         warning("could not determine number of cpus: %.200s", strerror(errno));
         ncpu = 1;
     }
 
-    num = strtonum(st->arg, 0, SYMON_MAXCPUID-1, &errstr);
+    num = strtonum(st->arg, 0, SYMON_MAXCPUID - 1, &errstr);
     if (errstr != NULL) {
         fatal("cpu(%.200s) is invalid: %.200s", st->arg, errstr);
     }
 
-    st->parg.cp.mib[0] = CTL_KERN;
-    st->parg.cp.mib[1] = KERN_CPTIME2;
-    st->parg.cp.mib[2] = num;
-    if (st->parg.cp.mib[2] >= ncpu) {
-        fatal("cpu(%d) is not present", st->parg.cp.mib[2]);
+    if (ncpu > 1) {
+        st->parg.cp.mib[0] = CTL_KERN;
+        st->parg.cp.mib[1] = KERN_CPTIME2;
+        st->parg.cp.mib[2] = num;
+        st->parg.cp.miblen = 3;
+        if (st->parg.cp.mib[2] >= ncpu) {
+            fatal("cpu(%d) is not present", st->parg.cp.mib[2]);
+        }
     }
 #endif
 
-    cp_size = sizeof(st->parg.cp.time);
     /* Call get_cpu once to fill the cp_old structure */
     get_cpu(buf, sizeof(buf), st);
 
     info("started module cpu(%.200s)", st->arg);
 }
+
 void
 gets_cpu()
 {
@@ -167,22 +161,26 @@ gets_cpu()
 int
 get_cpu(char *symon_buf, int maxlen, struct stream *st)
 {
-    int total;
+    int i, total;
+    size_t len;
 
-#ifdef HAS_KERN_CPTIME2
-    if (sysctl(st->parg.cp.mib, 3, &st->parg.cp.time, &cp_size, NULL, 0) < 0) {
-        warning("%s:%d: sysctl kern.cp_time2 for cpu%d failed", __FILE__, __LINE__, st->parg.cp.mib[2]);
+    len = sizeof(st->parg.cp.time2);
+    if (sysctl(st->parg.cp.mib, st->parg.cp.miblen, &st->parg.cp.time2, &len, NULL, 0) < 0) {
+        warning("%s:%d: sysctl kern.cp_time* for cpu%d failed", __FILE__, __LINE__,
+          st->parg.cp.mib[2]);
         return 0;
     }
-#else
-    if (sysctl(cp_time_mib, 2, &st->parg.cp.time, &cp_size, NULL, 0) < 0) {
-        warning("%s:%d: sysctl kern.cp_time failed", __FILE__, __LINE__);
-        return 0;
+
+    /* sysctl will return 32 bit longs for CPTIME and 64 bit longs for CPTIME2 */
+    if (st->parg.cp.mib[1] == KERN_CPTIME) {
+        bcopy(st->parg.cp.time2, st->parg.cp.time1, sizeof(st->parg.cp.time1));
+        for (i = 0; i < CPUSTATES; i++) {
+            st->parg.cp.time2[i] = (int64_t) st->parg.cp.time1[i];
+        }
     }
-#endif
 
     /* convert cp_time counts to percentages */
-    total = percentages(CPUSTATES, st->parg.cp.states, st->parg.cp.time, st->parg.cp.old, st->parg.cp.diff);
+    total = percentages(CPUSTATES, st->parg.cp.states, st->parg.cp.time2, st->parg.cp.old, st->parg.cp.diff);
 
     return snpack(symon_buf, maxlen, st->arg, MT_CPU,
                   (double) (st->parg.cp.states[CP_USER] / 10.0),
