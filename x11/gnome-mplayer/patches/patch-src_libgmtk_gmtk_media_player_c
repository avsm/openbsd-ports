$OpenBSD: patch-src_libgmtk_gmtk_media_player_c,v 1.4 2011/09/29 11:03:19 dcoppa Exp $

Raise event on incomplete QuickTime file, and mark it for retry
(fix apple.com/trailers) - upstream svn revision r2152

Bugfix: ATTRIBUTE_FORCE_CACHE not being processed
(upstream svn revision r44 of gmtk)

Wait for the socket_id to be valid, but in plugin mode it may
not so timeout (upstream svn revision r41 of gmtk)

Fix issue with not being able to play media off an SFTP share
(upstream svn revision r45 of gmtk)

When mplayer reports that it has video, resize the media
window so that mplayer has something to draw to
(upstream svn revision r46 of gmtk)

--- src/libgmtk/gmtk_media_player.c.orig	Tue Jun 28 18:19:18 2011
+++ src/libgmtk/gmtk_media_player.c	Wed Sep 28 14:54:04 2011
@@ -69,15 +69,22 @@ gboolean signal_event(gpointer data)
 
     if (event && event->event_name != NULL 
         && (event->player->restart == FALSE || event->event_data_int == ATTRIBUTE_AF_EXPORT_FILENAME)) {
-        if (g_strcasecmp(event->event_name, "position-changed") == 0 ||
-            g_strcasecmp(event->event_name, "cache-percent-changed") == 0) {
-            g_signal_emit_by_name(event->player, event->event_name, event->event_data_double);
-        } else if (g_strcasecmp(event->event_name, "size_allocate") == 0) {
-            g_signal_emit_by_name(event->player, event->event_name, event->event_allocation);
-        } else {
-            g_signal_emit_by_name(event->player, event->event_name, event->event_data_int);
-        }
-
+		switch (event->type) {
+		case EVENT_TYPE_INT:
+	            g_signal_emit_by_name(event->player, event->event_name, event->event_data_int);
+		    break;
+		case EVENT_TYPE_DOUBLE:
+	            g_signal_emit_by_name(event->player, event->event_name, event->event_data_double);
+		    break;
+		case EVENT_TYPE_BOOLEAN:
+	            g_signal_emit_by_name(event->player, event->event_name, event->event_data_boolean);
+		    break;
+		case EVENT_TYPE_ALLOCATION:
+    		    g_signal_emit_by_name(event->player, event->event_name, event->event_allocation);
+		    break;
+		default:
+		    printf("undefined event %s\n", event->event_name);
+		}
         g_free(event->event_name);
     }
     if (event)
@@ -93,6 +100,7 @@ void create_event_int(GmtkMediaPlayer * player, const 
 
     event = g_new0(GmtkMediaPlayerEvent, 1);
     event->player = player;
+    event->type = EVENT_TYPE_INT;
     event->event_name = g_strdup(name);
     event->event_data_int = value;
     g_idle_add(signal_event, event);
@@ -104,17 +112,31 @@ void create_event_double(GmtkMediaPlayer * player, con
 
     event = g_new0(GmtkMediaPlayerEvent, 1);
     event->player = player;
+    event->type = EVENT_TYPE_DOUBLE;
     event->event_name = g_strdup(name);
     event->event_data_double = value;
     g_idle_add(signal_event, event);
 }
 
+void create_event_boolean(GmtkMediaPlayer * player, const gchar * name, gboolean value)
+{
+    GmtkMediaPlayerEvent *event;
+
+    event = g_new0(GmtkMediaPlayerEvent, 1);
+    event->player = player;
+    event->type = EVENT_TYPE_BOOLEAN;
+    event->event_name = g_strdup(name);
+    event->event_data_boolean = value;
+    g_idle_add(signal_event, event);
+}
+
 void create_event_allocation(GmtkMediaPlayer * player, const gchar * name, GtkAllocation * allocation)
 {
     GmtkMediaPlayerEvent *event;
 
     event = g_new0(GmtkMediaPlayerEvent, 1);
     event->player = player;
+    event->type = EVENT_TYPE_ALLOCATION;
     event->event_name = g_strdup(name);
     event->event_allocation = allocation;
     g_idle_add(signal_event, event);
@@ -300,6 +322,7 @@ static void gmtk_media_player_init(GmtkMediaPlayer * p
     player->channel_in = NULL;
     player->channel_out = NULL;
     player->channel_err = NULL;
+    player->retry_on_full_cache = FALSE;
 }
 
 static void gmtk_media_player_dispose(GObject * object)
@@ -908,6 +931,10 @@ void gmtk_media_player_set_attribute_boolean(GmtkMedia
         player->hardware_ac3 = value;
         break;
 
+    case ATTRIBUTE_FORCE_CACHE:
+        player->force_cache = value;
+        break;
+
     default:
         if (player->debug)
             printf("Unsupported Attribute\n");
@@ -993,6 +1020,14 @@ gboolean gmtk_media_player_get_attribute_boolean(GmtkM
         ret = player->hardware_ac3;
         break;
 
+    case ATTRIBUTE_RETRY_ON_FULL_CACHE:
+	ret = player->retry_on_full_cache;
+	break;
+
+    case ATTRIBUTE_FORCE_CACHE:
+	ret = player->force_cache;
+	break;
+
     default:
         if (player->debug)
             printf("Unsupported Attribute\n");
@@ -1779,6 +1814,9 @@ gpointer launch_mplayer(gpointer data)
     GList *list;
     GmtkMediaPlayerSubtitle *subtitle;
     GmtkMediaPlayerAudioTrack *track;
+#ifdef GIO_ENABLED
+    GFile *file;
+#endif
 
     player->seekable = FALSE;
     player->has_chapters = FALSE;
@@ -1788,6 +1826,7 @@ gpointer launch_mplayer(gpointer data)
     player->title_is_menu = FALSE;
     player->enable_divx = TRUE;
     player->disable_xvmc = FALSE;
+    player->retry_on_full_cache = FALSE;
 
     g_mutex_lock(player->thread_running);
 
@@ -1818,7 +1857,17 @@ gpointer launch_mplayer(gpointer data)
         argn = 0;
         player->playback_error = NO_ERROR;
         if (player->uri != NULL) {
+#ifdef GIO_ENABLED
+            file = g_file_new_for_uri(player->uri);
+            if (file != NULL) {
+		filename = g_file_get_path(file);
+		g_object_unref(file);
+            }
+#else
             filename = g_filename_from_uri(player->uri, NULL, NULL);
+#endif
+            if (filename != NULL)
+		player->type = TYPE_FILE;
         }
 
         player->minimum_mplayer = detect_mplayer_features(player);
@@ -1976,8 +2025,11 @@ gpointer launch_mplayer(gpointer data)
         argv[argn++] = g_strdup_printf("-sub-fuzziness");
         argv[argn++] = g_strdup_printf("%i", player->subtitle_fuzziness);
 
-        while (player->socket_id == 0)
+        // wait for the socket_id to be valid, but in plugin mode it may not so timeout
+        i = 0;
+        while (player->socket_id == 0 && (i++ < 10))
             g_usleep(100);
+
         argv[argn++] = g_strdup_printf("-wid");
         argv[argn++] = g_strdup_printf("0x%x", player->socket_id);
 
@@ -2477,6 +2529,11 @@ gboolean thread_reader_error(GIOChannel * source, GIOC
         error_msg = g_strdup_printf(_("Compressed SWF format not supported"));
     }
 
+    if (strstr(mplayer_output->str, "MOV: missing header (moov/cmov) chunk") != NULL) {
+        player->retry_on_full_cache = TRUE;
+        create_event_boolean(player, "attribute-changed", ATTRIBUTE_RETRY_ON_FULL_CACHE);
+    }
+
     if (strstr(mplayer_output->str, "Title: ") != 0) {
         buf = strstr(mplayer_output->str, "Title:");
         buf = strstr(mplayer_output->str, "Title: ") + strlen("Title: ");
@@ -2875,6 +2932,13 @@ gboolean thread_reader(GIOChannel * source, GIOConditi
             }
             player->video_format = g_strdup(buf);
             create_event_int(player, "attribute-changed", ATTRIBUTE_VIDEO_FORMAT);
+            if (player->video_width == 0 && player->video_height == 0) {
+		if (player->debug)
+		    printf("Setting to minimum size so that mplayer has something to draw to\n");
+		allocation.width = 32;
+		allocation.height = 16;
+		create_event_allocation(player, "size_allocate", &allocation);
+            }
         }
 
         if (strstr(mplayer_output->str, "ID_VIDEO_CODEC") != 0) {
