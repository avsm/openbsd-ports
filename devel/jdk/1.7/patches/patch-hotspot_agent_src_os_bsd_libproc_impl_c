$OpenBSD: patch-hotspot_agent_src_os_bsd_libproc_impl_c,v 1.1 2009/06/10 19:01:09 kurt Exp $
--- hotspot/agent/src/os/bsd/libproc_impl.c.orig	Tue Jun  2 13:04:27 2009
+++ hotspot/agent/src/os/bsd/libproc_impl.c	Tue Jun  2 13:04:34 2009
@@ -178,6 +178,9 @@ lib_info* add_lib_info_fd(struct ps_prochandle* ph, co
    if (newlib->symtab == NULL) {
       print_debug("symbol table build failed for %s\n", newlib->name);
    }
+   else {
+      print_debug("built symbol table for %s\n", newlib->name);
+   }
 
    // even if symbol table building fails, we add the lib_info.
    // This is because we may need to read from the ELF file for core file
@@ -272,7 +275,7 @@ static int thread_db_callback(const td_thrhandle_t *th
 
   print_debug("thread_db : pthread %d (lwp %d)\n", ti.ti_tid, ti.ti_lid);
 
-  if (ptr->callback(ptr->ph, ti.ti_tid, ti.ti_lid) != true)
+  if (ptr->callback(ptr->ph, (pthread_t)ti.ti_tid, ti.ti_lid) != true)
     return TD_ERR;
 
   return TD_OK;
@@ -324,7 +327,7 @@ lwpid_t get_lwp_id(struct ps_prochandle* ph, int index
 }
 
 // get regs for a given lwp
-bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id, struct user_regs_struct* regs) {
+bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id, struct reg* regs) {
   return ph->ops->get_lwp_regs(ph, lwp_id, regs);
 }
 
@@ -375,11 +378,6 @@ bool find_lib(struct ps_prochandle* ph, const char *li
 //--------------------------------------------------------------------------
 // proc service functions
 
-// get process id
-pid_t ps_getpid(struct ps_prochandle *ph) {
-   return ph->pid;
-}
-
 // ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
 // of the load object object_name in the target process identified by ph.
 // It returns the symbol's value as an address in the target process in
@@ -392,17 +390,33 @@ ps_err_e ps_pglobal_lookup(struct ps_prochandle *ph, c
 }
 
 // read "size" bytes info "buf" from address "addr"
-ps_err_e ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
-                   void *buf, size_t size) {
+ps_err_e ps_pread(struct ps_prochandle *ph, psaddr_t  addr,
+                  void *buf, size_t size) {
   return ph->ops->p_pread(ph, (uintptr_t) addr, buf, size)? PS_OK: PS_ERR;
 }
 
 // write "size" bytes of data to debuggee at address "addr"
-ps_err_e ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
-                    const void *buf, size_t size) {
+ps_err_e ps_pwrite(struct ps_prochandle *ph, psaddr_t addr,
+                   const void *buf, size_t size) {
   return ph->ops->p_pwrite(ph, (uintptr_t)addr, buf, size)? PS_OK: PS_ERR;
 }
 
+// fill in ptrace_lwpinfo for lid
+ps_err_e ps_linfo(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+  return ph->ops->get_lwp_info(ph, lwp_id, linfo)? PS_OK: PS_ERR;
+}
+
+// needed for when libthread_db is compiled with TD_DEBUG defined
+void
+ps_plog (const char *format, ...)
+{
+  va_list alist;
+
+  va_start(alist, format);
+  vfprintf(stderr, format, alist);
+  va_end(alist);
+}
+
 // ------------------------------------------------------------------------
 // Functions below this point are not yet implemented. They are here only
 // to make the linker happy.
@@ -427,8 +441,12 @@ ps_err_e ps_lgetregs(struct ps_prochandle *ph, lwpid_t
   return PS_OK;
 }
 
-// new libthread_db of NPTL seem to require this symbol
-ps_err_e ps_get_thread_area() {
-  print_debug("ps_get_thread_area not implemented\n");
+ps_err_e ps_lstop(struct ps_prochandle *ph, lwpid_t lid) {
+  print_debug("ps_lstop not implemented\n");
+  return PS_OK;
+}
+
+ps_err_e ps_pcontinue(struct ps_prochandle *ph) {
+  print_debug("ps_pcontinue not implemented\n");
   return PS_OK;
 }
