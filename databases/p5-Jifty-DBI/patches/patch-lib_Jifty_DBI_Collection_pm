$OpenBSD: patch-lib_Jifty_DBI_Collection_pm,v 1.1.2.1 2011/04/25 13:38:31 jasper Exp $

Security fix for SA44224
Perl Jifty::DBI SQL Injection Vulnerabilities

Patch extracted from 0.68.

--- lib/Jifty/DBI/Collection.pm.orig	Wed Apr 20 09:50:21 2011
+++ lib/Jifty/DBI/Collection.pm	Wed Apr 20 09:53:30 2011
@@ -918,37 +918,28 @@ sub limit {
     #since we're changing the search criteria, we need to redo the search
     $self->redo_search();
 
-    if ( $args{'column'} ) {
+    #If it's a like, we supply the %s around the search term
+    if ( $args{'operator'} =~ /MATCHES/i ) {
+        $args{'value'} = "%" . $args{'value'} . "%";
+    } elsif ( $args{'operator'} =~ /STARTS_?WITH/i ) {
+        $args{'value'} = $args{'value'} . "%";
+    } elsif ( $args{'operator'} =~ /ENDS_?WITH/i ) {
+        $args{'value'} = "%" . $args{'value'};
+    }
+    $args{'operator'} =~ s/(?:MATCHES|ENDS_?WITH|STARTS_?WITH)/LIKE/i;
 
-        #If it's a like, we supply the %s around the search term
-        if ( $args{'operator'} =~ /LIKE/i ) {
-            $args{'value'} = $args{'value'};
-        } elsif ( $args{'operator'} =~ /MATCHES/i ) {
-            $args{'value'}    = "%" . $args{'value'} . "%";
-            $args{'operator'} = "LIKE";
-        } elsif ( $args{'operator'} =~ /STARTSWITH/i ) {
-            $args{'value'}    = $args{'value'} . "%";
-            $args{'operator'} = "LIKE";
-        } elsif ( $args{'operator'} =~ /ENDSWITH/i ) {
-            $args{'value'}    = "%" . $args{'value'};
-            $args{'operator'} = "LIKE";
-        }
+    # Force the value to NULL (non-quoted) if the operator is IS.
+    if ($args{'operator'} =~ /^IS(\s*NOT)?$/i) {
+        $args{'quote_value'} = 0;
+        $args{'value'} = 'NULL';
+    }
 
-        #if we're explicitly told not to to quote the value or
-        # we're doing an IS or IS NOT (null), don't quote the operator.
-
-        if ( $args{'quote_value'} && $args{'operator'} !~ /IS/i ) {
-            my $tmp = $self->_handle->dbh->quote( $args{'value'} );
-
-            # Accomodate DBI drivers that don't understand UTF8
-            if ( $] >= 5.007 ) {
-                require Encode;
-                if ( Encode::is_utf8( $args{'value'} ) ) {
-                    Encode::_utf8_on($tmp);
-                }
-            }
-            $args{'value'} = $tmp;
-        }
+    # Quote the value
+    if ( $args{'quote_value'} ) {
+        if ( $value_ref eq 'ARRAY' ) {
+            map { $_ = $self->_handle->quote_value($_) } @{ $args{'value'} };
+        } else {
+            $args{'value'} = $self->_handle->quote_value( $args{'value'} );
     }
 
     my ( $Clause, $qualified_column );
@@ -1246,6 +1237,11 @@ sub _order_clause {
             and ( $rowhash{'column'} ) )
         {
 
+            if ($rowhash{'column'} =~ /\W/) {
+                warn "Possible SQL injection in column '$rowhash{column}' in order_by\n";
+                next;
+            }
+
             $clause .= ( $clause ? ", " : " " );
             $clause .= $rowhash{'alias'} . "." if $rowhash{'alias'};
             $clause .= $rowhash{'column'} . " ";
@@ -1326,6 +1322,10 @@ sub _group_clause {
         } elsif ( ( $rowhash{'alias'} )
             and ( $rowhash{'column'} ) )
         {
+            if ($rowhash{'column'} =~ /\W/) {
+                warn "Possible SQL injection in column '$rowhash{column}' in group_by\n";
+               next;
+            }
 
             $clause .= ( $clause ? ", " : " " );
             $clause .= $rowhash{'alias'} . ".";
