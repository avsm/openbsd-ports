$OpenBSD: patch-hotspot_src_os_bsd_vm_os_bsd_inline_hpp,v 1.2 2008/03/19 18:05:43 kurt Exp $
--- hotspot/src/os/bsd/vm/os_bsd.inline.hpp.orig	Wed Nov  7 12:41:29 2007
+++ hotspot/src/os/bsd/vm/os_bsd.inline.hpp	Wed Nov  7 12:41:35 2007
@@ -61,7 +61,15 @@ inline bool os::uses_stack_guard_pages() {
 
 inline bool os::allocate_stack_guard_pages() {
   assert(uses_stack_guard_pages(), "sanity check");
+#if !defined(__FreeBSD__) || __FreeBSD__ < 5
+  // Since FreeBSD 4 uses malloc() for allocating the thread stack
+  // there is no need to do anything extra to allocate the guard pages
+  return false;
+#else
+  // FreeBSD 5+ uses mmap MAP_STACK for allocating the thread stacks.
+  // Must 'allocate' them or guard pages are ignored.
   return true;
+#endif
 }
 
 
@@ -108,6 +116,107 @@ inline int os::closedir(DIR *dirp)
   assert(dirp != NULL, "just checking");
   return ::closedir(dirp);
 }
+
+//XXXBSD: ported from solaris version
+//////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
+
+// macros for interruptible io and system calls and system call restarting 
+
+#define _INTERRUPTIBLE(_setup, _cmd, _result, _thread, _clear, _before, _after, _int_enable) \
+do { \
+  _setup; \
+  _before; \
+  OSThread* _osthread = _thread->osthread(); \
+  if (_int_enable && _thread->has_last_Java_frame()) { \
+    /* this is java interruptible io stuff */ \
+    if (os::is_interrupted(_thread, _clear))  { \
+      os::Bsd::bump_interrupted_before_count(); \
+      _result = OS_INTRPT; \
+    } else { \
+      /* _cmd always expands to an assignment to _result */ \
+      if ((_cmd) < 0 && errno == EINTR  \
+       && os::is_interrupted(_thread, _clear)) { \
+        os::Bsd::bump_interrupted_during_count(); \
+        _result = OS_INTRPT; \
+      } \
+    } \
+  } else { \
+    /* this is normal blocking io stuff */ \
+    _cmd; \
+  } \
+  _after; \
+} while(false)
+
+// Interruptible io support + restarting of interrupted system calls
+
+#ifndef ASSERT
+
+#define INTERRUPTIBLE(_cmd, _result, _clear) do { \
+  _INTERRUPTIBLE( JavaThread* _thread = (JavaThread*)ThreadLocalStorage::thread(),_result = _cmd, _result, _thread, _clear, , , UseVMInterruptibleIO); \
+} while((_result == OS_ERR) && (errno == EINTR))
+
+#else 
+
+// This adds an assertion that it is only called from thread_in_native
+// The call overhead is skipped for performance in product mode
+#define INTERRUPTIBLE(_cmd, _result, _clear) do { \
+  _INTERRUPTIBLE(JavaThread* _thread = os::Bsd::setup_interruptible_native(), _result = _cmd, _result, _thread, _clear, , os::Bsd::cleanup_interruptible_native(_thread), UseVMInterruptibleIO ); \
+} while((_result == OS_ERR) && (errno == EINTR))
+
+#endif
+
+// Used for calls from _thread_in_vm, not from _thread_in_native
+#define INTERRUPTIBLE_VM(_cmd, _result, _clear) do { \
+  _INTERRUPTIBLE(JavaThread* _thread = os::Bsd::setup_interruptible(), _result = _cmd, _result, _thread, _clear, , os::Bsd::cleanup_interruptible(_thread), UseVMInterruptibleIO ); \
+} while((_result == OS_ERR) && (errno == EINTR))
+
+/* Use NORESTART when the system call cannot return EINTR, when something other
+   than a system call is being invoked, or when the caller must do EINTR 
+   handling. */
+
+#ifndef ASSERT
+
+#define INTERRUPTIBLE_NORESTART(_cmd, _result, _clear) \
+  _INTERRUPTIBLE( JavaThread* _thread = (JavaThread*)ThreadLocalStorage::thread(),_result = _cmd, _result, _thread, _clear, , , UseVMInterruptibleIO)
+
+#else
+
+// This adds an assertion that it is only called from thread_in_native
+// The call overhead is skipped for performance in product mode
+#define INTERRUPTIBLE_NORESTART(_cmd, _result, _clear) \
+  _INTERRUPTIBLE(JavaThread* _thread = os::Bsd::setup_interruptible_native(), _result = _cmd, _result, _thread, _clear, , os::Bsd::cleanup_interruptible_native(_thread), UseVMInterruptibleIO )
+
+#endif
+
+// Don't attend to UseVMInterruptibleIO. Always allow interruption.
+// Also assumes that it is called from the _thread_blocked state.
+// Used by os_sleep().
+
+#define INTERRUPTIBLE_NORESTART_VM_ALWAYS(_cmd, _result, _thread, _clear) \
+  _INTERRUPTIBLE(os::Bsd::setup_interruptible_already_blocked(_thread), _result = _cmd, _result, _thread, _clear, , , true )
+
+#define INTERRUPTIBLE_RETURN_INT(_cmd, _clear) do { \
+  int _result; \
+  do { \
+    INTERRUPTIBLE(_cmd, _result, _clear); \
+  } while((_result == OS_ERR) && (errno == EINTR)); \
+  return _result; \
+} while(false)
+
+#define INTERRUPTIBLE_RETURN_INT_VM(_cmd, _clear) do { \
+  int _result; \
+  do { \
+    INTERRUPTIBLE_VM(_cmd, _result, _clear); \
+  } while((_result == OS_ERR) && (errno == EINTR)); \
+  return _result; \
+} while(false)
+
+#define INTERRUPTIBLE_RETURN_INT_NORESTART(_cmd, _clear) do { \
+  int _result; \
+  INTERRUPTIBLE_NORESTART(_cmd, _result, _clear); \
+  return _result; \
+} while(false)
 
 // macros for restartable system calls
 
