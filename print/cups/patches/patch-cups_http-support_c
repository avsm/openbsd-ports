$OpenBSD: patch-cups_http-support_c,v 1.1 2010/03/31 16:20:02 ajacoutot Exp $

Avahi support, from Fedora.

--- cups/http-support.c.orig	Fri Jun 12 02:21:58 2009
+++ cups/http-support.c	Thu Dec 10 15:48:31 2009
@@ -55,6 +55,11 @@
 #  include <dns_sd.h>
 #  include <poll.h>
 #endif /* HAVE_DNSSD */
+#ifdef HAVE_AVAHI
+#  include <avahi-client/client.h>
+#  include <avahi-client/lookup.h>
+#  include <avahi-common/simple-watch.h>
+#endif /* HAVE_AVAHI */
 
 
 /*
@@ -121,6 +126,24 @@ static void		resolve_callback(DNSServiceRef sdRef,
 					 void *context);
 #endif /* HAVE_DNSSD */
 
+#ifdef HAVE_AVAHI
+static void	avahi_resolve_uri_client_cb(AvahiClient *client,
+					    AvahiClientState state,
+					    void *simple_poll);
+static void	avahi_resolve_uri_resolver_cb(AvahiServiceResolver *resolver,
+					      AvahiIfIndex interface,
+					      AvahiProtocol protocol,
+					      AvahiResolverEvent event,
+					      const char *name,
+					      const char *type,
+					      const char *domain,
+					      const char *host_name,
+					      const AvahiAddress *address,
+					      uint16_t port,
+					      AvahiStringList *txt,
+					      AvahiLookupResultFlags flags,
+					      void *context);
+#endif /* HAVE_AVAHI */
 
 /*
  * 'httpAssembleURI()' - Assemble a uniform resource identifier from its
@@ -1349,15 +1372,26 @@ _httpResolveURI(
 
   if (strstr(hostname, "._tcp"))
   {
+#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)
+    char		*regtype,	/* Pointer to type in hostname */
+			*domain;	/* Pointer to domain in hostname */
 #ifdef HAVE_DNSSD
     DNSServiceRef	ref,		/* DNS-SD master service reference */
 			domainref,	/* DNS-SD service reference for domain */
 			localref;	/* DNS-SD service reference for .local */
     int			domainsent = 0;	/* Send the domain resolve? */
-    char		*regtype,	/* Pointer to type in hostname */
-			*domain;	/* Pointer to domain in hostname */
     _http_uribuf_t	uribuf;		/* URI buffer */
     struct pollfd	polldata;	/* Polling data */
+#else /* HAVE_AVAHI */
+    AvahiSimplePoll	*simple_poll;
+    AvahiClient		*client;
+    int			error;
+    struct
+    {
+      AvahiSimplePoll	*poll;
+      _http_uribuf_t	uribuf;
+    } user_data;
+#endif /* HAVE_DNSSD */
 
 
     if (logit)
@@ -1395,8 +1429,13 @@ _httpResolveURI(
     if (domain)
       *domain++ = '\0';
 
+#ifdef HAVE_DNSSD
     uribuf.buffer  = resolved_uri;
     uribuf.bufsize = resolved_size;
+#else
+    user_data.uribuf.buffer = resolved_uri;
+    user_data.uribuf.bufsize = resolved_size;
+#endif
 
     resolved_uri[0] = '\0';
 
@@ -1411,6 +1450,7 @@ _httpResolveURI(
 
     uri = NULL;
 
+#ifdef HAVE_DNSSD
     if (DNSServiceCreateConnection(&ref) == kDNSServiceErr_NoError)
     {
       localref = ref;
@@ -1486,7 +1526,37 @@ _httpResolveURI(
 
       DNSServiceRefDeallocate(ref);
     }
+#else /* HAVE_AVAHI */
+    if ((simple_poll = avahi_simple_poll_new ()) != NULL)
+    {
+      if ((client = avahi_client_new (avahi_simple_poll_get (simple_poll),
+				      0, avahi_resolve_uri_client_cb,
+				      &simple_poll, &error)) != NULL)
+      {
+	user_data.poll = simple_poll;
+	if (avahi_service_resolver_new (client, AVAHI_IF_UNSPEC,
+					AVAHI_PROTO_UNSPEC, hostname,
+					regtype, domain, AVAHI_PROTO_UNSPEC, 0,
+					avahi_resolve_uri_resolver_cb,
+					&user_data) != NULL)
+	{
+	  avahi_simple_poll_loop (simple_poll);
 
+	 /*
+	  * Collect the result.
+	  */
+
+	  if (resolved_uri[0])
+	    uri = resolved_uri;
+	}
+
+	avahi_client_free (client);
+      }
+
+      avahi_simple_poll_free (simple_poll);
+    }
+#endif /* HAVE_DNSSD */
+
     if (logit)
     {
       if (uri)
@@ -1497,13 +1567,13 @@ _httpResolveURI(
       fputs("STATE: -connecting-to-device\n", stderr);
     }
 
-#else
+#else /* HAVE_DNSSD || HAVE_AVAHI */
    /*
     * No DNS-SD support...
     */
 
     uri = NULL;
-#endif /* HAVE_DNSSD */
+#endif /* HAVE_DNSSD || HAVE_AVAHI */
 
     if (logit && !uri)
       _cupsLangPuts(stderr, _("Unable to find printer!\n"));
@@ -1707,6 +1777,105 @@ resolve_callback(
                 uribuf->buffer));
 }
 #endif /* HAVE_DNSSD */
+
+#ifdef HAVE_AVAHI
+static void
+avahi_resolve_uri_client_cb (AvahiClient *client,
+			     AvahiClientState state,
+			     void *simple_poll)
+{
+  DEBUG_printf(("avahi_resolve_uri_client_callback(client=%p, state=%d, "
+		"simple_poll=%p)\n", client, state, simple_poll));
+
+  /*
+   * If the connection drops, quit.
+   */
+
+  if (state == AVAHI_CLIENT_FAILURE)
+    avahi_simple_poll_quit (simple_poll);
+}
+
+static void
+avahi_resolve_uri_resolver_cb (AvahiServiceResolver *resolver,
+			       AvahiIfIndex interface,
+			       AvahiProtocol protocol,
+			       AvahiResolverEvent event,
+			       const char *name,
+			       const char *type,
+			       const char *domain,
+			       const char *host_name,
+			       const AvahiAddress *address,
+			       uint16_t port,
+			       AvahiStringList *txt,
+			       AvahiLookupResultFlags flags,
+			       void *context)
+{
+  const char		*scheme;	/* URI scheme */
+  char			rp[256];	/* Remote printer */
+  AvahiStringList	*pair;
+  char			*value;
+  size_t		valueLen = 0;
+  char			addr[AVAHI_ADDRESS_STR_MAX];
+  struct
+  {
+    AvahiSimplePoll	*poll;
+    _http_uribuf_t	uribuf;
+  }		*poll_uribuf = context;
+
+  DEBUG_printf(("avahi_resolve_uri_resolver_callback(resolver=%p, "
+		"interface=%d, protocol=%d, event=%d, name=\"%s\", "
+		"type=\"%s\", domain=\"%s\", host_name=\"%s\", address=%p, "
+		"port=%d, txt=%p, flags=%d, context=%p)\n",
+		resolver, interface, protocol, event, name, type, domain,
+		host_name, address, port, txt, flags, context));
+
+  if (event != AVAHI_RESOLVER_FOUND)
+  {
+    avahi_service_resolver_free (resolver);
+    avahi_simple_poll_quit (poll_uribuf->poll);
+    return;
+  }
+
+ /*
+  * Figure out the scheme from the full name...
+  */
+
+  if (strstr(type, "_ipp."))
+    scheme = "ipp";
+  else if (strstr(type, "_printer."))
+    scheme = "lpd";
+  else if (strstr(type, "_pdl-datastream."))
+    scheme = "socket";
+  else
+    scheme = "riousbprint";
+
+ /*
+  * Extract the "remote printer key from the TXT record...
+  */
+
+  if ((pair = avahi_string_list_find (txt, "rp")) != NULL)
+  {
+    avahi_string_list_get_pair (pair, NULL, &value, &valueLen);
+    rp[0] = '/';
+    memcpy (rp + 1, value, valueLen);
+    rp[valueLen + 1] = '\0';
+  }
+  else
+    rp[0] = '\0';
+
+ /*
+  * Assemble the final device URI...
+  */
+
+  avahi_address_snprint (addr, AVAHI_ADDRESS_STR_MAX, address);
+  httpAssembleURI(HTTP_URI_CODING_ALL, poll_uribuf->uribuf.buffer,
+		  poll_uribuf->uribuf.bufsize, scheme, NULL,
+		  addr, port, rp);
+  DEBUG_printf(("avahi_resolve_uri_resolver_callback: Resolved URI is \"%s\"\n",
+		poll_uribuf->uribuf.buffer));
+  avahi_simple_poll_quit (poll_uribuf->poll);
+}
+#endif /* HAVE_AVAHI */
 
 
 /*
