$OpenBSD: patch-src_constraints_c,v 1.1 2008/07/02 17:42:55 ajacoutot Exp $
--- src/constraints.c.orig	Mon Jan  7 23:39:42 2008
+++ src/constraints.c	Wed Jul  2 13:53:20 2008
@@ -691,8 +691,7 @@ constrain_maximization (MetaWindow         *window,
                         ConstraintPriority  priority,
                         gboolean            check_only)
 {
-  MetaRectangle target_size;
-  MetaRectangle min_size, max_size;
+  MetaRectangle min_size, max_size, work_area;
   gboolean hminbad, vminbad;
   gboolean horiz_equal, vert_equal;
   gboolean constraint_already_satisfied;
@@ -704,51 +703,20 @@ constrain_maximization (MetaWindow         *window,
   if (!window->maximized_horizontally && !window->maximized_vertically)
     return TRUE;
 
-  /* Calculate target_size = maximized size of (window + frame) */
-  if (window->maximized_horizontally && window->maximized_vertically)
-    target_size = info->work_area_xinerama;
-  else
-    {
-      /* Amount of maximization possible in a single direction depends
-       * on which struts could occlude the window given its current
-       * position.  For example, a vertical partial strut on the right
-       * is only relevant for a horizontally maximized window when the
-       * window is at a vertical position where it could be occluded
-       * by that partial strut.
-       */
-      MetaDirection  direction;
-      GSList        *active_workspace_struts;
-
-      if (window->maximized_horizontally)
-        direction = META_DIRECTION_HORIZONTAL;
-      else
-        direction = META_DIRECTION_VERTICAL;
-      active_workspace_struts = window->screen->active_workspace->all_struts;
-
-      target_size = info->current;
-      extend_by_frame (&target_size, info->fgeom);
-      meta_rectangle_expand_to_avoiding_struts (&target_size,
-                                                &info->entire_xinerama,
-                                                direction,
-                                                active_workspace_struts);
-   }
-  /* Now make target_size = maximized size of client window */
-  unextend_by_frame (&target_size, info->fgeom);
-
-  /* Check min size constraints; max size constraints are ignored for maximized
-   * windows, as per bug 327543.
-   */
+  work_area = info->work_area_xinerama;
+  unextend_by_frame (&work_area, info->fgeom);
   get_size_limits (window, info->fgeom, FALSE, &min_size, &max_size);
-  hminbad = target_size.width < min_size.width && window->maximized_horizontally;
-  vminbad = target_size.height < min_size.height && window->maximized_vertically;
+
+  hminbad = work_area.width < min_size.width && window->maximized_horizontally;
+  vminbad = work_area.height < min_size.height && window->maximized_vertically;
   if (hminbad || vminbad)
     return TRUE;
 
   /* Determine whether constraint is already satisfied; exit if it is */
-  horiz_equal = target_size.x      == info->current.x &&
-                target_size.width  == info->current.width;
-  vert_equal  = target_size.y      == info->current.y &&
-                target_size.height == info->current.height;
+  horiz_equal = work_area.x      == info->current.x &&
+                work_area.width  == info->current.width;
+  vert_equal  = work_area.y      == info->current.y &&
+                work_area.height == info->current.height;
   constraint_already_satisfied =
     (horiz_equal || !window->maximized_horizontally) &&
     (vert_equal  || !window->maximized_vertically);
@@ -758,13 +726,13 @@ constrain_maximization (MetaWindow         *window,
   /*** Enforce constraint ***/
   if (window->maximized_horizontally)
     {
-      info->current.x      = target_size.x;
-      info->current.width  = target_size.width;
+      info->current.x      = work_area.x;
+      info->current.width  = work_area.width;
     }
   if (window->maximized_vertically)
     {
-      info->current.y      = target_size.y;
-      info->current.height = target_size.height;
+      info->current.y      = work_area.y;
+      info->current.height = work_area.height;
     }
   return TRUE;
 }
